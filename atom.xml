<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EiffelZero&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ihopezero.github.io/"/>
  <updated>2019-10-15T13:28:31.209Z</updated>
  <id>https://ihopezero.github.io/</id>
  
  <author>
    <name>EiffelZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>践踏</title>
    <link href="https://ihopezero.github.io/2019/10/15/%E8%B7%B5%E8%B8%8F/"/>
    <id>https://ihopezero.github.io/2019/10/15/践踏/</id>
    <published>2019-10-15T12:53:19.000Z</published>
    <updated>2019-10-15T13:28:31.209Z</updated>
    
    <content type="html"><![CDATA[<p>题意：<br>1操作 加一条线段<br>2操作 删一条线段<br>3查询 有多少条线段满足x+kt（t是整数）<br><a id="more"></a><br><a href="https://ac.nowcoder.com/acm/problem/21125" target="_blank" rel="noopener">传送门</a></p><p>考虑在模k意义下，每条线段都是1到2个区间，如果这条线段的长度大于k的话，那么区间[0，k-1]就满足题意。<br>树状数组维护区间和，单点查询即可。<br>当k=0的时候，则判断有多少个线段经过某个点，离散化，树状数组维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[MAXN],up;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">pair&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=up) tree[x]+=a,x+=x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) res+=tree[x],x-=x&amp;(-x);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k,op,l,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fafa\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        up=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">            <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&gt;=k)</span><br><span class="line">                &#123;</span><br><span class="line">                    add(<span class="number">1</span>,<span class="number">1</span>);           <span class="comment">//[1,k-1]</span></span><br><span class="line">                    add(k+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l=(l%k)+<span class="number">1</span>;</span><br><span class="line">                r=(r%k)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=r) &#123;add(l,<span class="number">1</span>); add(r+<span class="number">1</span>,<span class="number">-1</span>);&#125;       <span class="comment">//一条线段[l,r]</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    add(<span class="number">1</span>,<span class="number">1</span>);               <span class="comment">//两条线段[1,r]和[l,k+1]</span></span><br><span class="line">                    add(r+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                    add(l,<span class="number">1</span>);</span><br><span class="line">                    add(k+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)          <span class="comment">//删除线段则是添加的逆操作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">                <span class="keyword">if</span>(r-l+<span class="number">1</span>&gt;=k)</span><br><span class="line">                &#123;</span><br><span class="line">                    add(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                    add(k+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l=(l%k)+<span class="number">1</span>;</span><br><span class="line">                r=(r%k)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=r)&#123;</span><br><span class="line">                    add(l,<span class="number">-1</span>); add(r+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    add(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                    add(r+<span class="number">1</span>,<span class="number">1</span>);         </span><br><span class="line">                    add(l,<span class="number">-1</span>);</span><br><span class="line">                    add(k+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;l);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(l%k+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        up=<span class="number">2</span>*n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].second,&amp;a[i].first.first);</span><br><span class="line">            vec.push_back(a[i].first.first);</span><br><span class="line">            <span class="keyword">if</span>(a[i].second&lt;=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i].first.second);</span><br><span class="line">                vec.push_back(a[i].first.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.begin(),vec.end());</span><br><span class="line">        vec.erase(unique(vec.begin(),vec.end()),vec.end()); <span class="comment">//离散化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].second==<span class="number">1</span>)          <span class="comment">//离散化后，二分查询所需l,r</span></span><br><span class="line">            &#123;</span><br><span class="line">                l=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+<span class="number">1</span>;</span><br><span class="line">                r=lower_bound(vec.begin(),vec.end(),a[i].first.second)-vec.begin()+<span class="number">1</span>;</span><br><span class="line">                add(l,<span class="number">1</span>);</span><br><span class="line">                add(r+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i].second==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                l=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+<span class="number">1</span>;</span><br><span class="line">                r=lower_bound(vec.begin(),vec.end(),a[i].first.second)-vec.begin()+<span class="number">1</span>;</span><br><span class="line">                add(l,<span class="number">-1</span>);</span><br><span class="line">                add(r+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum(x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：&lt;br&gt;1操作 加一条线段&lt;br&gt;2操作 删一条线段&lt;br&gt;3查询 有多少条线段满足x+kt（t是整数）&lt;br&gt;
    
    </summary>
    
    
      <category term="树状数组" scheme="https://ihopezero.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="离散化" scheme="https://ihopezero.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>VVQ与线段</title>
    <link href="https://ihopezero.github.io/2019/10/15/VVQ%E4%B8%8E%E7%BA%BF%E6%AE%B5/"/>
    <id>https://ihopezero.github.io/2019/10/15/VVQ与线段/</id>
    <published>2019-10-15T12:52:59.000Z</published>
    <updated>2019-10-15T13:47:20.752Z</updated>
    
    <content type="html"><![CDATA[<p>题意：求任意两条线段的异或最大值。<br>定义线段的异或值为它们并的长度减他们交的长度<br><a id="more"></a></p><p>题解：有两种情况<br>1：线段a内部包含线段b 贡献：(a.r-a.l)-(b.r-b.l);<br>2.线段a与线段b相交   贡献：(a.r+b.l-b.l-b.r);<br>先根据l进行排序，然后计算贡献即可.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pa[MAX_N];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    A(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;l=x;r=y;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> A &amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (r-l)&lt;(x.r-x.l);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    B(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;l=x;r=y;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> B &amp;x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l+r&gt;x.l+x.r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;pa[i].first,&amp;pa[i].second);</span><br><span class="line">    sort(pa+<span class="number">1</span>,pa+<span class="number">1</span>+n);</span><br><span class="line">    priority_queue&lt;A&gt; pq1;  pq1.push(A(pa[<span class="number">1</span>].first,pa[<span class="number">1</span>].second));</span><br><span class="line">    priority_queue&lt;B&gt; pq2;  pq2.push(B(pa[<span class="number">1</span>].first,pa[<span class="number">1</span>].second));</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pq1.size()&amp;&amp;pq1.top().r&lt;pa[i].second) pq1.pop();</span><br><span class="line">        <span class="keyword">while</span>(pq2.size()&amp;&amp;pq2.top().r&lt;pa[i].first)  pq2.pop();</span><br><span class="line">        <span class="keyword">if</span>(pq1.size()) ans=max(ans,pq1.top().r-pq1.top().l-pa[i].second+pa[i].first);       <span class="comment">//计算包含关系</span></span><br><span class="line">        <span class="keyword">if</span>(pq2.size()) ans=max(ans,pa[i].first+pa[i].second-pq2.top().l-pq2.top().r);       <span class="comment">//计算相交关系</span></span><br><span class="line">        pq1.push(A(pa[i].first,pa[i].second));</span><br><span class="line">        pq2.push(B(pa[i].first,pa[i].second));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：求任意两条线段的异或最大值。&lt;br&gt;定义线段的异或值为它们并的长度减他们交的长度&lt;br&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="https://ihopezero.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="优先队列" scheme="https://ihopezero.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>统计颜色</title>
    <link href="https://ihopezero.github.io/2019/10/15/%E7%BB%9F%E8%AE%A1%E9%A2%9C%E8%89%B2/"/>
    <id>https://ihopezero.github.io/2019/10/15/统计颜色/</id>
    <published>2019-10-15T12:52:42.000Z</published>
    <updated>2019-10-15T13:42:26.264Z</updated>
    
    <content type="html"><![CDATA[<p>题意：<br>n个桶按顺序排列，我们用1~n给桶标号。有两种操作：<br>1 l r c 区间[l,r]中的每个桶中都放入一个颜色为c的球 (1≤l,r ≤n,l≤r,0≤c≤60)<br>2 l r   查询区间[l,r]的桶中有多少种不同颜色的球     (1≤l,r ≤n,l≤r)<br><a id="more"></a></p><p>用long long的不同位来表示不同颜色。区间合并用’|’(或)即可，update区间时就用 1&lt;&lt;c 的值来update.</p><p><a href="https://ac.nowcoder.com/acm/problem/15667" target="_blank" rel="noopener">传送门</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll tree[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll tag[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll N,M;</span><br><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getans</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=x&amp;<span class="number">1</span>;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p]=tree[lc(p)]|tree[rc(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(ll p,ll l,ll r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p]=tag[p]|k;</span><br><span class="line">    tree[p]=tree[p]|k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    fun(lc(p),l,mid,tag[p]);</span><br><span class="line">    fun(rc(p),mid+<span class="number">1</span>,r,tag[p]);</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll nl,ll nr,ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="keyword">if</span>(tag[p]!=<span class="number">0</span>) push_down(p,l,r);</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid)res=res|query(nl,nr,lc(p),l,mid);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) res=res|query(nl,nr,rc(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl,ll nr,ll p,ll l,ll r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">    &#123;</span><br><span class="line">        tag[p]=tag[p]|k;</span><br><span class="line">        tree[p]=tree[p]|k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tag[p]!=<span class="number">0</span>) push_down(p,l,r);</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid)update(nl,nr,rc(p),mid+<span class="number">1</span>,r,k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;M)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">        <span class="built_in">memset</span>(tag,<span class="number">0</span>,<span class="keyword">sizeof</span>(tag));</span><br><span class="line">        <span class="keyword">while</span>(M--)</span><br><span class="line">       &#123;</span><br><span class="line">           ll b;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b);</span><br><span class="line">           <span class="keyword">if</span>(b==<span class="number">1</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               ll x,y,z;</span><br><span class="line">               <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">               ll temp=<span class="built_in">pow</span>(<span class="number">2</span>,z);</span><br><span class="line">               update(x,y,<span class="number">1</span>,<span class="number">1</span>,N,temp);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               ll x,y;</span><br><span class="line">               <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x,&amp;y);</span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,getans(query(x,y,<span class="number">1</span>,<span class="number">1</span>,N)));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：&lt;br&gt;n个桶按顺序排列，我们用1~n给桶标号。有两种操作：&lt;br&gt;1 l r c 区间[l,r]中的每个桶中都放入一个颜色为c的球 (1≤l,r ≤n,l≤r,0≤c≤60)&lt;br&gt;2 l r   查询区间[l,r]的桶中有多少种不同颜色的球     (1≤l,r ≤n,l≤r)&lt;br&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="https://ihopezero.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Sum</title>
    <link href="https://ihopezero.github.io/2019/10/15/Sum/"/>
    <id>https://ihopezero.github.io/2019/10/15/Sum/</id>
    <published>2019-10-15T12:52:22.000Z</published>
    <updated>2019-10-15T13:53:42.480Z</updated>
    
    <content type="html"><![CDATA[<p>题意：<br>考虑维护一个这样的问题：<br>（1） 给出一个数组A，标号为1~n<br>（2） 修改数组中的一个位置。<br>（3） 询问区间[l,r]中所有子集的位运算and之和mod($10^9$+7)。<br><a id="more"></a><br><a href="https://ac.nowcoder.com/acm/problem/" target="_blank" rel="noopener">传送门</a><br>题解：<br>按位建立线段树,每一颗线段树维护每一位从1到n的区间和。<br>第p位的值为a,则贡献为：$2^p$*($2^a$-1);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N];</span><br><span class="line"><span class="keyword">int</span> tree[MAX_N&lt;&lt;<span class="number">2</span>][<span class="number">32</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">32</span>];</span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%MOD;</span><br><span class="line">        x=x*x%MOD;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     tree[p][t]=(tree[lc(p)][t]+tree[rc(p)][t])%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[p][i]=(a[l]&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc(p),l,mid);</span><br><span class="line">    build(rc(p),mid+<span class="number">1</span>,r);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">       push_up(p,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> p,<span class="keyword">int</span> l ,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[i]=(cnt[i]+tree[p][i])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) query(nl,nr,lc(p),l,mid);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;nr) query(nl,nr,rc(p),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> nl,<span class="keyword">int</span> nr,<span class="keyword">int</span> p,<span class="keyword">int</span> l ,<span class="keyword">int</span> r,<span class="keyword">int</span> k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">    &#123;</span><br><span class="line">        a[l]=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[p][i]=(a[l]&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid) update(nl,nr,lc(p),l,mid,k);</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;nr) update(nl,nr,rc(p),mid+<span class="number">1</span>,r,k);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">       push_up(p,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">int</span> m; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> b; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            update(x,x,<span class="number">1</span>,<span class="number">1</span>,n,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">            query(l,r,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">            ll ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=(ans+(((mod_pow(<span class="number">2</span>,cnt[i])<span class="number">-1</span>)%MOD)*(mod_pow(<span class="number">2</span>,i)%MOD))%MOD)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：&lt;br&gt;考虑维护一个这样的问题：&lt;br&gt;（1） 给出一个数组A，标号为1~n&lt;br&gt;（2） 修改数组中的一个位置。&lt;br&gt;（3） 询问区间[l,r]中所有子集的位运算and之和mod($10^9$+7)。&lt;br&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="https://ihopezero.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="树状数组" scheme="https://ihopezero.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://ihopezero.github.io/2019/10/11/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://ihopezero.github.io/2019/10/11/线段树/</id>
    <published>2019-10-11T12:10:08.000Z</published>
    <updated>2019-10-11T12:48:53.690Z</updated>
    
    <content type="html"><![CDATA[<p>线段树模板<br>线段树是处理符合结合律的高效数据结构；<br>线段树专门处理区间问题的；<br>线段树的每个节点都表示一个区间，当l==r的时候，意味着区间长度为1，也就是表元素；<br>线段是是一颗完全二叉树，即每个节点要么是叶子节点要么就有两个孩子节点。<br><a id="more"></a><br><a href="https://www.luogu.org/problem/P3372" target="_blank" rel="noopener">线段树模板题</a></p><h2 id="递归建树："><a href="#递归建树：" class="headerlink" title="递归建树："></a>递归建树：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;      <span class="comment">//左孩子</span></span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;    <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p]=tree[lc(p)]+tree[rc(p)];            <span class="comment">//这是维护区间和的线段树，维护区间最大最小值的类似；</span></span><br><span class="line">    <span class="comment">//tree[p]=min(tree[lc(p)],tree[rc(p)]); //维护区间最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span>              </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p]=<span class="number">0</span>;                               <span class="comment">//tag标记，先不管，下面讲</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc(p),l,mid);                     <span class="comment">//递归左子树</span></span><br><span class="line">    build(rc(p),mid+<span class="number">1</span>,r);                   <span class="comment">//递归右子树</span></span><br><span class="line">    push_up(p);                             <span class="comment">//回溯时，维护父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h2><p>单点修改是区间修改的子问题，也就是修改区间长度为1的区间。放在一起谈。<br>对于区间修改，我们需要引用一个tag标记；<br>原因：当修改区间的一个元素时，它就需要push_up来更新它的父节点，时间复杂度O(nlogn)，这很低效，当我们引入tag标记时，则可以使区间更新接近O(logn);</p><h3 id="tag标记"><a href="#tag标记" class="headerlink" title="tag标记"></a>tag标记</h3><p>当某个区间被修改时，就给这个区间打上标记,当用到这个区间的子区间的时候，我们才从父节点往子节点下传更新值.来看一下代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(ll p,ll l,ll r,ll k)</span>    <span class="comment">// p表示该节点，[l,r]表示该节点表示的区间，k表示增量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p]=tag[p]+k;            <span class="comment">//记录增量</span></span><br><span class="line">    tree[p]=tree[p]+(r-l+<span class="number">1</span>)*k;  <span class="comment">//更新当前节点的值，因为符合结合律，所以直接可以计算得</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p,ll l,ll r)</span>      <span class="comment">//下传tag标记</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;                </span><br><span class="line">    fun(lc(p),l,mid,tag[p]);           <span class="comment">//下传给左孩子</span></span><br><span class="line">    fun(rc(p),mid+<span class="number">1</span>,r,tag[p]);          <span class="comment">//下传给右孩子</span></span><br><span class="line">    tag[p]=<span class="number">0</span>;                       <span class="comment">//下传完，恢复标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl,ll nr,ll p,ll l,ll r,ll k)</span>        <span class="comment">//区间修改，[nl,nr]表示修改的区间，p表示该区间的节点，[l,r]表示该节点表示的区间，k表示增量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)            <span class="comment">//当需要修改的区间完全覆盖当前区间，我们就给该区间打上tag标记，并且更新一下该节点的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        tag[p]+=k;</span><br><span class="line">        tree[p]+=(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tag[p]!=<span class="number">0</span>) push_down(p,l,r);             <span class="comment">//没有完全覆盖则需要继续找，如果当前节点有tag标记，说明它的孩子节点没有被更新，我们要先下放tag标记</span></span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k);     <span class="comment">//更新左子树</span></span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid)update(nl,nr,rc(p),mid+<span class="number">1</span>,r,k);    <span class="comment">//更新右子树</span></span><br><span class="line">    push_up(p);                                 <span class="comment">//回溯时，维护父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll nl,ll nr,ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];                    <span class="comment">//当查询的区间已经完全包括该区间时，直接return</span></span><br><span class="line">    <span class="keyword">if</span>(tag[p]!=<span class="number">0</span>) push_down(p,l,r);                     <span class="comment">//如果标记不为0,则说明该区间有修改，需要push_down传递给子节点，且需要在递归子节点前！！！</span></span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid)res+=query(nl,nr,lc(p),l,mid);           <span class="comment">//递归左孩子</span></span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) res+=query(nl,nr,rc(p),mid+<span class="number">1</span>,r);         <span class="comment">//递归右孩子</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ll tree[MAX_N&lt;&lt;<span class="number">2</span>];          <span class="comment">//线段树的节点，因为从树顶往下建树，所以需要4N的大小；</span></span><br><span class="line">ll a[MAX_N];                <span class="comment">//存原数组</span></span><br><span class="line">ll tag[MAX_N&lt;&lt;<span class="number">2</span>];           <span class="comment">//标记</span></span><br><span class="line">ll N,M;</span><br><span class="line"><span class="function">ll <span class="title">lc</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>;&#125;      </span><br><span class="line"><span class="function">ll <span class="title">rc</span><span class="params">(ll x)</span> </span>&#123;<span class="keyword">return</span> x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p]=tree[lc(p)]+tree[rc(p)];          </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(ll p,ll l,ll r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p]=tag[p]+k;</span><br><span class="line">    tree[p]=tree[p]+(r-l+<span class="number">1</span>)*k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    fun(lc(p),l,mid,tag[p]);</span><br><span class="line">    fun(rc(p),mid+<span class="number">1</span>,r,tag[p]);</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span>              <span class="comment">//递归建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[p]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(lc(p),l,mid);</span><br><span class="line">    build(rc(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll nl,ll nr,ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) <span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="keyword">if</span>(tag[p]!=<span class="number">0</span>) push_down(p,l,r);</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid)res+=query(nl,nr,lc(p),l,mid);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid) res+=query(nl,nr,rc(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl,ll nr,ll p,ll l,ll r,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr)</span><br><span class="line">    &#123;</span><br><span class="line">        tag[p]+=k;</span><br><span class="line">        tree[p]+=(r-l+<span class="number">1</span>)*k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tag[p]!=<span class="number">0</span>) push_down(p,l,r);</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k);</span><br><span class="line">    <span class="keyword">if</span>(nr&gt;mid)update(nl,nr,rc(p),mid+<span class="number">1</span>,r,k);</span><br><span class="line">    push_up(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;N,&amp;M);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">   build(<span class="number">1</span>,<span class="number">1</span>,N);</span><br><span class="line">   <span class="keyword">while</span>(M--)</span><br><span class="line">   &#123;</span><br><span class="line">       ll b;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b);</span><br><span class="line">       <span class="keyword">if</span>(b==<span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ll x,y,z;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">           update(x,y,<span class="number">1</span>,<span class="number">1</span>,N,z);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           ll x,y;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;x,&amp;y);</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,query(x,y,<span class="number">1</span>,<span class="number">1</span>,N));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树模板&lt;br&gt;线段树是处理符合结合律的高效数据结构；&lt;br&gt;线段树专门处理区间问题的；&lt;br&gt;线段树的每个节点都表示一个区间，当l==r的时候，意味着区间长度为1，也就是表元素；&lt;br&gt;线段是是一颗完全二叉树，即每个节点要么是叶子节点要么就有两个孩子节点。&lt;br&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="https://ihopezero.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>逆序数</title>
    <link href="https://ihopezero.github.io/2019/10/08/%E9%80%86%E5%BA%8F%E6%95%B0/"/>
    <id>https://ihopezero.github.io/2019/10/08/逆序数/</id>
    <published>2019-10-08T11:22:20.000Z</published>
    <updated>2019-10-11T04:06:38.113Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://www.luogu.org/problem/P1908" target="_blank" rel="noopener">https://www.luogu.org/problem/P1908</a><br>题目链接：<a href="https://ac.nowcoder.com/acm/problem/15163" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15163</a><br>题意：给n个数，求这n个数的逆序对。（$a_i$&lt;$a_j$&amp;&amp;i&gt;j）<br><a id="more"></a></p><h1 id="归并排序做法："><a href="#归并排序做法：" class="headerlink" title="归并排序做法："></a>归并排序做法：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N];</span><br><span class="line"><span class="keyword">int</span> b[MAX_N];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    mergesort(s,mid);</span><br><span class="line">    mergesort(mid+<span class="number">1</span>,t);</span><br><span class="line">    <span class="keyword">int</span> i=s;<span class="keyword">int</span> j=mid+<span class="number">1</span>;<span class="keyword">int</span> k=s;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=t)&#123;                <span class="comment">//合并两个区间</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j]) b[k++]=a[i++];   <span class="comment">//满足顺序，直接用b数组存储</span></span><br><span class="line">        <span class="keyword">else</span> &#123;b[k++]=a[j++]; ans+=mid+<span class="number">1</span>-i;&#125;  <span class="comment">//当第一个区间的数比第二区间的数大，则它的逆序数为mid+1-i,i为这个数在第一个区间的位置.</span></span><br><span class="line">        <span class="comment">/*例如:合并左区间4,5,6 和 右区间1,2,3；</span></span><br><span class="line"><span class="comment">        对于1来讲它的逆序对就有4,5,6,；</span></span><br><span class="line"><span class="comment">        对于2来讲它的逆序对就有5,6;</span></span><br><span class="line"><span class="comment">        对于3来讲它的逆序对就有6;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) b[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=t) b[k++]=a[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=s;l&lt;=t;l++) a[l]=b[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    mergesort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组做法："><a href="#树状数组做法：" class="headerlink" title="树状数组做法："></a>树状数组做法：</h1><p>1.首先我们要知道树状数组是可以用来维护前缀和;</p><p>2.我们利用桶排的思想来求逆序对数,即遍历数组a,然后用b数组存储a[i]出现的次数(b[a[i]]++)。对于每个a[i]来说，它的逆序数为i-(1~$b_i$)的前缀和；如果直接遍历b的话太慢，所以我们用树状数组来维护前缀和。</p><p>3.当n很大的时候，我们不足以开这么大的b数组来存储，于是我们可以对a数组进行离散化，先将a数组排序，然后用1~n来表示a数组的相对大小。</p><p>4.要注意出现相同的数的时候，我们要将出现在后面的数排在后面。不然$a_i$=$a_j$ &amp;&amp; i &lt; j的时候，排序可能会让$a_j$排在$a_i$前面，导致处理$a_i$时会将$a_j$误判为逆序对.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N];</span><br><span class="line"><span class="keyword">int</span> b[MAX_N];</span><br><span class="line"><span class="keyword">int</span> tree[MAX_N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> val;    </span><br><span class="line">&#125;node[MAX_N];   <span class="comment">//用结构体来存储原来的值和位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span>       </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node x,Node y)</span>      <span class="comment">//排序法则</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.val==y.val)<span class="keyword">return</span> x.index&lt;y.index;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span>        <span class="comment">//给第i位数加x</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i]+=x;</span><br><span class="line">        i+=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span>         <span class="comment">//求1~i的前缀和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s+=tree[i];</span><br><span class="line">        i-=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;node[i].val);</span><br><span class="line">        node[i].index=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(node+<span class="number">1</span>,node+<span class="number">1</span>+n,cmp);  <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[node[i].index]=i;   <span class="comment">//离散化  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        add(b[i],<span class="number">1</span>);        </span><br><span class="line">        ans+=i-sum(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>因为树状数组要排序，复杂度已经O(nlogn)了，还要进行维护树状数组操作，在数比较大的时候会比归并慢。<br>但如果n比较小的情况下，用树状数组做会比较快，不用离散化的情况下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problem/P1908&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.luogu.org/problem/P1908&lt;/a&gt;&lt;br&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15163&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15163&lt;/a&gt;&lt;br&gt;题意：给n个数，求这n个数的逆序对。（$a_i$&amp;lt;$a_j$&amp;amp;&amp;amp;i&amp;gt;j）&lt;br&gt;
    
    </summary>
    
    
      <category term="树状数组" scheme="https://ihopezero.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="离散化" scheme="https://ihopezero.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="归并排序" scheme="https://ihopezero.github.io/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>食物链</title>
    <link href="https://ihopezero.github.io/2019/10/05/%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <id>https://ihopezero.github.io/2019/10/05/食物链/</id>
    <published>2019-10-05T09:08:20.000Z</published>
    <updated>2019-10-05T13:56:00.623Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/problem/16884" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16884</a>    </p><p>题意：有N只动物，这些动物属于A、B、C的其中一种；已知A吃B、B吃C、C吃A。接着有K条信息，第一种：x和y是同类；第二种：x吃y。 问有多少条信息是假的？<br><a id="more"></a></p><p>思路：对于每只动物i创建3个元素i-A,i-B,i-C，并用3*N个元素建立并查集。<br>维护并查集：<br>第一种：x和y同类： unite(x-A,y-A),unite(x-B,y-B),unite(x-c,y-c);<br>第二种：x吃y：   unite(x-A,y-B),unite(x-B,y-C),unite(x-C,y-A);<br>如果出现第i条信息发生冲突 则说明是假话，ans++;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> par[MAXN];</span><br><span class="line"><span class="keyword">int</span> height[MAXN];</span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        par[i]=i;</span><br><span class="line">        height[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> par[x]=Find(par[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=Find(x);</span><br><span class="line">    y=Find(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(height[x]&lt;height[y])</span><br><span class="line">    &#123;</span><br><span class="line">        par[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        par[y]=x;</span><br><span class="line">        <span class="keyword">if</span>(height[x]==height[y]) height[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Find(x)==Find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init(<span class="number">3</span>*N);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t,x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>||N&lt;x||y&lt;=<span class="number">0</span>||N&lt;y) &#123;ans++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(same(x,y+N)||same(x,y+<span class="number">2</span>*N)) ans++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                unite(x,y);</span><br><span class="line">                unite(x+N,y+N);</span><br><span class="line">                unite(x+<span class="number">2</span>*N,y+<span class="number">2</span>*N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(same(x,y)||same(x,y+<span class="number">2</span>*N)) ans++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                unite(x,y+N);</span><br><span class="line">                unite(x+N,y+<span class="number">2</span>*N);</span><br><span class="line">                unite(x+<span class="number">2</span>*N,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;K);</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16884&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16884&lt;/a&gt;    &lt;/p&gt;
&lt;p&gt;题意：有N只动物，这些动物属于A、B、C的其中一种；已知A吃B、B吃C、C吃A。接着有K条信息，第一种：x和y是同类；第二种：x吃y。 问有多少条信息是假的？&lt;br&gt;
    
    </summary>
    
    
      <category term="并查集" scheme="https://ihopezero.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2010]游戏</title>
    <link href="https://ihopezero.github.io/2019/10/05/SCOI2010-%E6%B8%B8%E6%88%8F/"/>
    <id>https://ihopezero.github.io/2019/10/05/SCOI2010-游戏/</id>
    <published>2019-10-05T08:59:16.000Z</published>
    <updated>2019-10-05T13:56:02.515Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="https://ac.nowcoder.com/acm/problem/20566?&amp;headNav=acm" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/20566?&amp;headNav=acm</a><br>题意：给n个装备，每个装备有两个属性，并且最多只能使用一次。求由这些点的属性能最大匹配到的值。<br><a id="more"></a><br>思路：把每个属性看成点，每个装备看成边。然后连接成k个连通块，如果该连通块为树状，则答案只能是k-1；如果连通块为环状，则答案为k。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[MAXN];      <span class="comment">//记录是否能达到</span></span><br><span class="line"><span class="keyword">int</span> fa[MAXN];       <span class="comment">//记录父节点</span></span><br><span class="line"><span class="keyword">int</span> n;              </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x]==x ? x : fa[x]=fun(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=fun(x);</span><br><span class="line">    <span class="keyword">int</span> b=fun(y);</span><br><span class="line">    <span class="keyword">if</span>(a==b) &#123;</span><br><span class="line">        vis[a]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) swap(a,b);      <span class="comment">//看见有大佬的交换写法有：x^=y^=x^=y;  将a为小，b为大</span></span><br><span class="line">    vis[a]=<span class="number">1</span>;               </span><br><span class="line">    fa[a]=b;                <span class="comment">//将小点的父节点为大点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++) fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        unite(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==n&amp;&amp;vis[i])</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20566?&amp;amp;headNav=acm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/20566?&amp;amp;headNav=acm&lt;/a&gt;&lt;br&gt;题意：给n个装备，每个装备有两个属性，并且最多只能使用一次。求由这些点的属性能最大匹配到的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="并查集" scheme="https://ihopezero.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="二分图" scheme="https://ihopezero.github.io/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Valentine&#39;s Day</title>
    <link href="https://ihopezero.github.io/2019/09/29/Valentine-s-Day/"/>
    <id>https://ihopezero.github.io/2019/09/29/Valentine-s-Day/</id>
    <published>2019-09-29T08:13:53.000Z</published>
    <updated>2019-10-05T13:54:12.826Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6693" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6693</a></p><p>题意：给n个礼物让女朋友开心的概率，女朋友只能开心一次。求送多少件礼物让女朋友开心的概率最大？<br><a id="more"></a></p><p>思路：贪心去概率大的礼物，对于第i件物品，该物品开心的概率为P[i],能让女朋友开心的概率为win<em>（1-P[i]）+lose</em>P[i];然后就遍历所有礼物，当win变小的时候可以提前退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> P[<span class="number">10000</span>+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span> </span>&#123;<span class="keyword">return</span> a&gt;b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;P[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sort(P+<span class="number">1</span>,P+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="keyword">double</span> win=P[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">double</span> lose=<span class="number">1</span>-P[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> temp=P[i]*lose+(<span class="number">1</span>-P[i])*win;</span><br><span class="line">             <span class="keyword">if</span>(temp&lt;=win) <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">else</span> </span><br><span class="line">             &#123;</span><br><span class="line">                 win=temp;</span><br><span class="line">                lose*=<span class="number">1</span>-P[i];</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.12lf\n"</span>,win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6693&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6693&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：给n个礼物让女朋友开心的概率，女朋友只能开心一次。求送多少件礼物让女朋友开心的概率最大？&lt;br&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://ihopezero.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>Block Breaker</title>
    <link href="https://ihopezero.github.io/2019/09/29/Block-Breaker/"/>
    <id>https://ihopezero.github.io/2019/09/29/Block-Breaker/</id>
    <published>2019-09-29T05:37:24.000Z</published>
    <updated>2019-10-05T13:50:39.235Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=6699" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6699</a></p><p>题意：给n*m矩阵，外围包着层墙，q次操作，每次操作击落(x,y)的方块，一个方块掉落可能会影响到附近的方块掉落，如果方块的上下或者左右夹不住该方块，则该方块掉落。DFS就可以了。<br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[x][y])temp++;</span><br><span class="line">            vis[x][y]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nx=x+dx[i];</span><br><span class="line">                <span class="keyword">int</span> ny=y+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny])</span><br><span class="line">                &#123;</span><br><span class="line">                    temp+=dfs(nx,ny,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((!vis[x<span class="number">-1</span>][y]&amp;&amp;!vis[x+<span class="number">1</span>][y])||(!vis[x][y+<span class="number">1</span>]&amp;&amp;!vis[x][y<span class="number">-1</span>])&amp;&amp;z==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[x][y]) temp++;</span><br><span class="line">                vis[x][y]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx=x+dx[i];</span><br><span class="line">                    <span class="keyword">int</span> ny=y+dy[i];</span><br><span class="line">                    <span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny])</span><br><span class="line">                    &#123;</span><br><span class="line">                        temp+=dfs(nx,ny,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[x][y]) &#123;vis[x][y]=<span class="number">1</span>;temp++;&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dfs(x,y,<span class="number">0</span>)+temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=6699&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://acm.hdu.edu.cn/showproblem.php?pid=6699&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题意：给n*m矩阵，外围包着层墙，q次操作，每次操作击落(x,y)的方块，一个方块掉落可能会影响到附近的方块掉落，如果方块的上下或者左右夹不住该方块，则该方块掉落。DFS就可以了。&lt;br&gt;
    
    </summary>
    
    
      <category term="DFS" scheme="https://ihopezero.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Haybale Feast</title>
    <link href="https://ihopezero.github.io/2019/09/27/Haybale-Feast/"/>
    <id>https://ihopezero.github.io/2019/09/27/Haybale-Feast/</id>
    <published>2019-09-27T10:51:04.000Z</published>
    <updated>2019-09-27T10:58:09.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链接：<a href="https://ac.nowcoder.com/acm/contest/625/C" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/625/C</a><br>来源：牛客网<br><a id="more"></a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll m;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"><span class="keyword">int</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ind=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//freopen("data.in","r",stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;f[i],&amp;s[i]);</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=f[i];</span><br><span class="line">        <span class="keyword">while</span>(ind&lt;=i&amp;&amp;sum-f[ind]&gt;=m)&#123;</span><br><span class="line">            sum-=f[ind]; ind++;         <span class="comment">//找到满足条件的ind位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail&amp;&amp;p[head]&lt;ind) head++;          <span class="comment">//当队首的位置小于ind位置，队首出队</span></span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail&amp;&amp;s[p[tail]]&lt;=s[i]) tail--;    <span class="comment">//当 当前元素大于队尾，出队</span></span><br><span class="line">        p[++tail]=i;                                <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=m) ans=min(ans,(ll)s[p[head]]);     <span class="comment">//当满足条件时，求最优解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/625/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/625/C&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;br&gt;
    
    </summary>
    
    
      <category term="牛客网" scheme="https://ihopezero.github.io/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
      <category term="单调队列" scheme="https://ihopezero.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="尺取法" scheme="https://ihopezero.github.io/tags/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2009]生日礼物</title>
    <link href="https://ihopezero.github.io/2019/09/26/SCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9/"/>
    <id>https://ihopezero.github.io/2019/09/26/SCOI2009-生日礼物/</id>
    <published>2019-09-26T09:13:10.000Z</published>
    <updated>2019-10-05T13:56:07.746Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="https://ac.nowcoder.com/acm/problem/20565?&amp;headNav=acm" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/20565?&amp;headNav=acm</a><br><a id="more"></a></p><p>思路：先排序，然后该种类没入队的入队，如果全部种类没满且前面出现过这个种类，就更新该种类的坐标；如果全部种类满了就求解当前长度。</p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">light a[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> tt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(light y,light z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y.x&lt;z.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=num;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;xx);</span><br><span class="line">            a[++cnt].x=xx;</span><br><span class="line">            a[cnt].type=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(tail&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[a[tail].type]==<span class="number">0</span>) sum++;</span><br><span class="line">        vis[a[tail].type]=a[tail].x;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[head].x!=vis[a[head].type]) head++;</span><br><span class="line">        <span class="keyword">if</span>(sum==k) ans=min(ans,a[tail].x-a[head].x);</span><br><span class="line">        tail++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20565?&amp;amp;headNav=acm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/20565?&amp;amp;headNav=acm&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="单调队列" scheme="https://ihopezero.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Neat Tree</title>
    <link href="https://ihopezero.github.io/2019/09/24/Neat%20Tree/"/>
    <id>https://ihopezero.github.io/2019/09/24/Neat Tree/</id>
    <published>2019-09-24T12:08:29.000Z</published>
    <updated>2019-10-05T13:56:20.130Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="https://ac.nowcoder.com/acm/problem/15815?&amp;headNav=acm" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15815?&amp;headNav=acm</a><br><a id="more"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="keyword">int</span> l[MAX_N];</span><br><span class="line"><span class="keyword">int</span> r[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sta.size()&amp;&amp;a[sta.top()]&gt;a[i]) sta.pop();             <span class="comment">//注意这里的"&gt;"号不是&gt;=</span></span><br><span class="line">            l[i]=sta.empty()?<span class="number">1</span>:sta.top()+<span class="number">1</span>;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sta.size()) sta.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sta.size()&amp;&amp;a[sta.top()]&gt;=a[i]) sta.pop();            <span class="comment">//这里是"&gt;="，避免前后两个区间重合。</span></span><br><span class="line">            r[i]=sta.empty()?n:sta.top()<span class="number">-1</span>;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sta.size()) sta.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans-=(ll)a[i]*((ll)(r[i]-i+<span class="number">1</span>)*(ll)(i-l[i]+<span class="number">1</span>)<span class="number">-1</span>);        <span class="comment">//一个[a,b]区间里的集合为b-a+1,1是指为空的时候。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sta.size()&amp;&amp;a[sta.top()]&lt;a[i]) sta.pop();</span><br><span class="line">            l[i]=sta.empty()?<span class="number">1</span>:sta.top()+<span class="number">1</span>;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sta.size()) sta.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sta.size()&amp;&amp;a[sta.top()]&lt;=a[i]) sta.pop();</span><br><span class="line">            r[i]=sta.empty()?n:sta.top()<span class="number">-1</span>;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(sta.size()) sta.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=(ll)a[i]*((ll)(r[i]-i+<span class="number">1</span>)*(ll)(i-l[i]+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以两次循环就做完了，一次循环就能求出L和R。进栈的时候可以求出L[i]，出栈的时候可以求出sta.top的R;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15815?&amp;amp;headNav=acm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15815?&amp;amp;headNav=acm&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="单调栈" scheme="https://ihopezero.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="https://ihopezero.github.io/2019/09/20/Trie%E6%A0%91/"/>
    <id>https://ihopezero.github.io/2019/09/20/Trie树/</id>
    <published>2019-09-20T08:14:33.000Z</published>
    <updated>2019-10-05T13:53:36.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> tri[MAX_N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> color[MAX_N];</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> * a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> alen=<span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;alen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tri[p][temp])</span><br><span class="line">        &#123;</span><br><span class="line">            tri[p][temp]=k;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        p=tri[p][temp];</span><br><span class="line">    &#125;</span><br><span class="line">    color[p]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">char</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> alen=<span class="built_in">strlen</span>(a);</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;alen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=a[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tri[p][temp])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p=tri[p][temp];</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> color[p]==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t,q;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        Insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(Query(s)) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;字典树&quot;&gt;&lt;a href=&quot;#字典树&quot; class=&quot;headerlink&quot; title=&quot;字典树&quot;&gt;&lt;/a&gt;字典树&lt;/h1&gt;
    
    </summary>
    
    
      <category term="前缀树" scheme="https://ihopezero.github.io/tags/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    
      <category term="字典树" scheme="https://ihopezero.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>高精</title>
    <link href="https://ihopezero.github.io/2019/09/19/%E9%AB%98%E7%B2%BE/"/>
    <id>https://ihopezero.github.io/2019/09/19/高精/</id>
    <published>2019-09-19T08:44:39.000Z</published>
    <updated>2019-09-26T09:20:28.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高精度模板"><a href="#高精度模板" class="headerlink" title="高精度模板"></a>高精度模板</h1><a id="more"></a><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> FOR(i, a, b) for(int i = a; i &lt;= b; i++)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _FOR(i, a, b) for(int i = a; i &gt;= b; i--)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BigInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">20500</span>;</span><br><span class="line">    <span class="keyword">int</span> num[M + <span class="number">10</span>], len;</span><br><span class="line"></span><br><span class="line">    BigInt() &#123; clean(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[M + <span class="number">10</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        len = <span class="built_in">strlen</span>(str);</span><br><span class="line">        FOR(i, <span class="number">1</span>, len)</span><br><span class="line">            num[i] = str[len - i] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _FOR(i, len, <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, num[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">itoBig</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    clean();</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">    num[len++] = x % <span class="number">10</span>;</span><br><span class="line">    x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(len != <span class="number">1</span>) len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigInt &amp;cmp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(len != cmp.len) <span class="keyword">return</span> len &lt; cmp.len;</span><br><span class="line">        _FOR(i, len, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(num[i] != cmp.num[i]) <span class="keyword">return</span> num[i] &lt; cmp.num[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> BigInt &amp;cmp) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cmp &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> BigInt &amp;cmp) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(cmp &lt; *<span class="keyword">this</span>); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> BigInt &amp;cmp) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cmp &lt; *<span class="keyword">this</span> || *<span class="keyword">this</span> &lt; cmp; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigInt &amp;cmp) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(cmp &lt; *<span class="keyword">this</span> || *<span class="keyword">this</span> &lt; cmp); &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span> + (<span class="keyword">const</span> BigInt &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt S;</span><br><span class="line">        S.len = max(len, A.len);</span><br><span class="line">        FOR(i, <span class="number">1</span>, S.len)&#123;</span><br><span class="line">            S.num[i] += num[i] + A.num[i];</span><br><span class="line">            <span class="keyword">if</span>(S.num[i] &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                S.num[i] -= <span class="number">10</span>;</span><br><span class="line">                S.num[i + <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(S.num[S.len + <span class="number">1</span>]) S.len++;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span> - (<span class="keyword">const</span> BigInt &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt S;</span><br><span class="line">        S.len = max(len, A.len);</span><br><span class="line">        FOR(i, <span class="number">1</span>, S.len)&#123;</span><br><span class="line">            S.num[i] += num[i] - A.num[i];</span><br><span class="line">            <span class="keyword">if</span>(S.num[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                S.num[i] += <span class="number">10</span>;</span><br><span class="line">                S.num[i + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!S.num[S.len] &amp;&amp; S.len &gt; <span class="number">1</span>) S.len--;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span> * (<span class="keyword">const</span> BigInt &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt S;</span><br><span class="line">        <span class="keyword">if</span>((A.len == <span class="number">1</span> &amp;&amp; A.num[<span class="number">1</span>] == <span class="number">0</span>) || (len == <span class="number">1</span> &amp;&amp; num[<span class="number">1</span>] == <span class="number">0</span>)) <span class="keyword">return</span> S;</span><br><span class="line">        S.len = A.len + len - <span class="number">1</span>;</span><br><span class="line">        FOR(i, <span class="number">1</span>, len)</span><br><span class="line">            FOR(j, <span class="number">1</span>, A.len)&#123;</span><br><span class="line">                S.num[i + j - <span class="number">1</span>] += num[i] * A.num[j];</span><br><span class="line">                S.num[i + j] += S.num[i + j - <span class="number">1</span>] / <span class="number">10</span>;</span><br><span class="line">                S.num[i + j - <span class="number">1</span>] %= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(S.num[S.len + <span class="number">1</span>]) S.len++;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span> / (<span class="keyword">const</span> BigInt &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">        BigInt S;</span><br><span class="line">        <span class="keyword">if</span>((A.len == <span class="number">1</span> &amp;&amp; A.num[<span class="number">1</span>] == <span class="number">0</span>) || (len == <span class="number">1</span> &amp;&amp; num[<span class="number">1</span>] == <span class="number">0</span>)) <span class="keyword">return</span> S;</span><br><span class="line">        BigInt R, N;</span><br><span class="line">        S.len = <span class="number">0</span>;</span><br><span class="line">        _FOR(i, len, <span class="number">1</span>)&#123;</span><br><span class="line">        N.itoBig(<span class="number">10</span>);</span><br><span class="line">R = R * N;</span><br><span class="line">N.itoBig(num[i]);</span><br><span class="line">R = R + N;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">        FOR(j, <span class="number">1</span>, <span class="number">10</span>)&#123;</span><br><span class="line">        N.itoBig(j);</span><br><span class="line">        <span class="keyword">if</span>(N * A &gt; R)&#123;</span><br><span class="line">        flag = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">S.num[++S.len] = flag;</span><br><span class="line">N.itoBig(flag);</span><br><span class="line">R = R - N * A;</span><br><span class="line">&#125;</span><br><span class="line">FOR(i, <span class="number">1</span>, S.len / <span class="number">2</span>) swap(S.num[i], S.num[len - i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(!S.num[S.len] &amp;&amp; S.len &gt; <span class="number">1</span>) S.len--;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span> % (<span class="keyword">const</span> BigInt &amp;A) <span class="keyword">const</span> &#123;</span><br><span class="line">    BigInt S;</span><br><span class="line">    BigInt P = *<span class="keyword">this</span> / A;</span><br><span class="line">    S = *<span class="keyword">this</span> - P * A;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;高精度模板&quot;&gt;&lt;a href=&quot;#高精度模板&quot; class=&quot;headerlink&quot; title=&quot;高精度模板&quot;&gt;&lt;/a&gt;高精度模板&lt;/h1&gt;
    
    </summary>
    
    
      <category term="高精" scheme="https://ihopezero.github.io/tags/%E9%AB%98%E7%B2%BE/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://ihopezero.github.io/2019/08/18/%E6%8E%92%E5%BA%8F/"/>
    <id>https://ihopezero.github.io/2019/08/18/排序/</id>
    <published>2019-08-18T07:05:54.000Z</published>
    <updated>2019-10-05T13:44:56.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;=left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i=left; <span class="keyword">int</span> j=right;</span><br><span class="line">    <span class="keyword">int</span> key=arr[(i+j)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]&lt;key)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i==right)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[j]&gt;key)&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">if</span>(j==left)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">            swap(arr[i],arr[j]);</span><br><span class="line">            i++;j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    QuickSort(arr,left,j);</span><br><span class="line">    QuickSort(arr,i,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> s,<span class="keyword">int</span> t,<span class="keyword">int</span> temp[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;=t) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    mergesort(arr,s,mid,temp);</span><br><span class="line">    mergesort(arr,mid+<span class="number">1</span>,t,temp);</span><br><span class="line">    <span class="keyword">int</span> i=s; <span class="keyword">int</span> j=mid+<span class="number">1</span>; <span class="keyword">int</span> k=s;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j]) temp[k++]=arr[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=arr[i]++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=t) temp[k++]=arr[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=s;l&lt;=t;l++) arr[l]=temp[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;
    
    </summary>
    
    
      <category term="排序" scheme="https://ihopezero.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Applese涂颜色</title>
    <link href="https://ihopezero.github.io/2019/04/29/Applese%E6%B6%82%E9%A2%9C%E8%89%B2/"/>
    <id>https://ihopezero.github.io/2019/04/29/Applese涂颜色/</id>
    <published>2019-04-29T08:15:18.000Z</published>
    <updated>2019-10-05T13:50:10.163Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接： <a href="https://ac.nowcoder.com/acm/contest/330/E" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/330/E</a><br><a id="more"></a></p><blockquote><p>费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}≡1(mod p)$。</p><p>在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: $a^{φ(n)}≡1(mod n)$<br>φ(n)为欧拉函数，定义为不超过n的整数中与n互素的个数。<br>欧拉降幂公式： $a^b≡a^{bmodφ(n)+φ(n)}mod n$</p></blockquote><p>题意：求出$2^n$。<br>思路：快速幂求$2^n$，问题是n太大了。肯定用数组存，然后利用<br>费马小定理：$2^nmod m=2^{n mod (m-1）}modm$ （这个怎么推我还不知道）</p><p>我写的AC代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x,ll n)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> n,m;</span><br><span class="line">    ll a;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n.size();i++)&#123;</span><br><span class="line">            a=(a*<span class="number">10</span>+n[i]-<span class="string">'0'</span>)%(mod<span class="number">-1</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mod_pow(<span class="number">2</span>,a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接： &lt;a href=&quot;https://ac.nowcoder.com/acm/contest/330/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/contest/330/E&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://ihopezero.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="费马小定理" scheme="https://ihopezero.github.io/tags/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ACM模板</title>
    <link href="https://ihopezero.github.io/2019/04/28/ACM%E6%A8%A1%E6%9D%BF/"/>
    <id>https://ihopezero.github.io/2019/04/28/ACM模板/</id>
    <published>2019-04-28T12:54:14.000Z</published>
    <updated>2019-10-06T06:45:22.020Z</updated>
    
    <content type="html"><![CDATA[<p>一些比赛用的模板<br><a id="more"></a></p><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂-O-logn"><a href="#快速幂-O-logn" class="headerlink" title="快速幂  O(logn)"></a>快速幂  O(logn)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法1：</span></span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x,ll n, ll mod)</span></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)res=res*x%mod;</span><br><span class="line">        x=x*x%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法2:</span></span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x,ll n, ll mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll res=mod_pow(x*x%mod,n/<span class="number">2</span>,mod);</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=res*x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;vec&gt; mat;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e8</span>+<span class="number">7</span>;   <span class="comment">//模的大小</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat &amp;A,mat &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">C</span><span class="params">(A.size(),vec(B[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;B.size();k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;B[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                C[i][j]=(C[i][j]+A[i][k]*B[k][j])%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat A,ll n)</span></span>&#123;</span><br><span class="line">    <span class="function">mat <span class="title">B</span><span class="params">(A.size(),vec(A.size()))</span></span>;      <span class="comment">// 输出矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">        B[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) B=mul(B,A);</span><br><span class="line">        A=mul(A,A);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GCD-欧几里得算法-O（log-max-a-b-）"><a href="#GCD-欧几里得算法-O（log-max-a-b-）" class="headerlink" title="GCD 欧几里得算法 O（log max(a,b)）"></a>GCD 欧几里得算法 O（log max(a,b)）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F(x)是斐波那契数列</span><br><span class="line">GCD(F[n],F[m])=F[gcd(n,m)</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展欧几里得算法  ax+by=gcd(a,b);</span></span><br><span class="line"><span class="keyword">int</span> extgcd(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; x,<span class="keyword">int</span>&amp; y)&#123;</span><br><span class="line">    <span class="keyword">int</span> d=a;</span><br><span class="line">    <span class="keyword">if</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        d=extgcd(b,a%b,y,x);</span><br><span class="line">        y-=(a/b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="素数筛表"><a href="#素数筛表" class="headerlink" title="素数筛表"></a>素数筛表</h2><p>时间复杂度接近O(n)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> prime[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) prime[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*prime[j]]=i;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二次探测定理："><a href="#二次探测定理：" class="headerlink" title="二次探测定理："></a>二次探测定理：</h2><p>奇素数p（即除2外的素数）<br>$xmodp^2=1$的解只有x=1和x=p-1</p><h2 id="素数定理："><a href="#素数定理：" class="headerlink" title="素数定理："></a>素数定理：</h2><p>随着x的增长,$π(x)/(x/ln(x))=1$，(π(x)为小于x的素数的个数)</p><h2 id="递推式转矩阵"><a href="#递推式转矩阵" class="headerlink" title="递推式转矩阵"></a>递推式转矩阵</h2><div align="center"><img src="http://bmob-cdn-24907.b0.upaiyun.com/2019/05/09/0e7a868240b49c958051f02581ec0a29.jpg"></div><h2 id="费马小定理和欧拉公式"><a href="#费马小定理和欧拉公式" class="headerlink" title="费马小定理和欧拉公式"></a>费马小定理和欧拉公式</h2><blockquote><p>费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}≡1(mod p)$。<br><img src="https://img-blog.csdn.net/20180528204641199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNjc5Mjk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"><br>费马小定理：$2^nmod m=2^{n mod (m-1）}modm$ （这个怎么推我还不知道）</p><p>在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: $a^{φ(n)}≡1(mod n)$<br>φ(n)为欧拉函数，定义为不超过n的整数中与n互素的个数。<br>欧拉降幂公式： $a^b≡a^{bmodφ(n)+φ(n)}mod n$<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求欧拉函数值.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(;n%i==<span class="number">0</span>;n/=i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="number">1</span>) res=res/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><p>Lucas定理是用来求 c(n,m) mod p，p为素数的值。<br>表达式：C(n,m)%p=C(n/p,m/p)*C(n%p,m%p)%p<br>Lucas定理：我们令n=sp+q , m=tp+r .（q ，r ≤p）<br>那么:<br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/e824b899a9014c08cc666bea0c7b02087bf4f424.jpg"><br>&lt;/div&gt;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span> <span class="params">(ll n , ll m , <span class="keyword">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">1l</span>l*comb (n%p , m%p , p) * Lucas (n/p,m/p,p)%p ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//comb()函数中，因为q ， r &lt; p , 所以这部分暴力完成即可。</span></span><br><span class="line"><span class="comment">//C++求C(n, m) mod 10007    版本二 要求p z在100000左右</span></span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;       <span class="comment">//f[n] = n!</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=p; ++i) f[i] = f[i<span class="number">-1</span>] * i % p;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a, ll x, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>)  ret = ret * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll n, ll k, <span class="keyword">int</span> p)</span>        <span class="comment">//C (n, k) % p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ll ret = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (n &amp;&amp; k) </span><br><span class="line">        &#123;</span><br><span class="line">        ll nn = n % p, kk = k % p;</span><br><span class="line">        <span class="keyword">if</span> (nn &lt; kk) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//inv (f[kk]) = f[kk] ^ (p - 2) % p</span></span><br><span class="line">        ret = ret * f[nn] * pow_mod (f[kk] * f[nn-kk] % p, p - <span class="number">2</span>, p) % p;</span><br><span class="line">        n /= p, k /= p;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init (p);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%I64d\n"</span>, Lucas (n, m, p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="BBP公式"><a href="#BBP公式" class="headerlink" title="BBP公式"></a>BBP公式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_C 56000</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10000</span>, b, c = MAX_C, d, e, f[MAX_C + <span class="number">1</span>], g, n, ans, cnt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* BBP公式   参照CCDN的姬小野博客   本人还不会....</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n))&#123;</span><br><span class="line">    <span class="keyword">for</span> (; b - c; )</span><br><span class="line">        f[b++] = a / <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (; d = <span class="number">0</span>, g = c * <span class="number">2</span>;</span><br><span class="line">         c -= <span class="number">14</span>, ans = e + d / a, e = d % a, cnt++)</span><br><span class="line">    &#123; <span class="keyword">if</span> (cnt * <span class="number">4</span> &gt; n) <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">for</span> (b = c; d += f[b]*a, f[b] = d % --g, d /= g--, --b; d *= b); &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; (ans / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; ((ans / <span class="number">100</span>) % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; ((ans / <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">4</span> == <span class="number">3</span>) <span class="built_in">cout</span> &lt;&lt; (ans % <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><h3 id="任意两点间的最短路问题-Floyd算法"><a href="#任意两点间的最短路问题-Floyd算法" class="headerlink" title="任意两点间的最短路问题(Floyd算法)"></a>任意两点间的最短路问题(Floyd算法)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAX_v][MAX_V]  <span class="comment">//无法到达时，权值为INF，主对角线为0</span></span><br><span class="line"><span class="keyword">int</span> V   <span class="comment">// 顶点数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;V;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;V;j++)&#123;</span><br><span class="line">                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单源最短路问题-Dijkstra算法"><a href="#单源最短路问题-Dijkstra算法" class="headerlink" title="单源最短路问题(Dijkstra算法)"></a>单源最短路问题(Dijkstra算法)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAX_V][MAX_V];     <span class="comment">//图的临接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_V];               <span class="comment">//顶点s（起点）到各点的最短距离</span></span><br><span class="line"><span class="keyword">bool</span> used[MAX_V];           <span class="comment">//是否已经访问过</span></span><br><span class="line"><span class="keyword">int</span> V;                      <span class="comment">//顶点数</span></span><br><span class="line"><span class="keyword">int</span> prev[MAX_V];            <span class="comment">//前趋顶点 （路径还原）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+v,INF);</span><br><span class="line">    fill(used,used+V,<span class="literal">false</span>);</span><br><span class="line">    fill(prev,prev+V,<span class="number">-1</span>);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;V;u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u]&amp;&amp;(v==<span class="number">-1</span>||d[u]&lt;d[v])) v=u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;V;u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[u]&gt;d[v]+cost[v][u])&#123;</span><br><span class="line">                d[u]=d[v]+cost[v][u];</span><br><span class="line">                prev[u]=v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//到顶点t的最短路</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_path(<span class="keyword">int</span> t)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(;t!=<span class="number">-1</span>;t=prev[t]) path.push_back(t);</span><br><span class="line">    reverse(path.begin(),path.end());</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cost[MAX_V][MAX_V];         <span class="comment">//临接矩阵表示边</span></span><br><span class="line"><span class="keyword">int</span> mincost[MAX_V];             <span class="comment">//从集合X出发的边到每个顶点的最小权值</span></span><br><span class="line"><span class="keyword">bool</span> used[MAX_V];               <span class="comment">//顶点i是否包含在集合X中</span></span><br><span class="line"><span class="keyword">int</span> V;                          <span class="comment">//顶点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">        mincost[i]=INF;</span><br><span class="line">        used[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mincost[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;V;u++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!used[u]&amp;&amp;(v==<span class="number">-1</span>||mincost[u]&lt;mincost[v])) v=u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        used[v]=<span class="literal">true</span>;                <span class="comment">//把顶点v加入X</span></span><br><span class="line">        res+=mincost[v];             <span class="comment">//把边的长度加到结果里</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;V;u++)&#123;</span><br><span class="line">            mincost[u]=min(mincost[u],cost[v][u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,cost;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> edge&amp; e1,<span class="keyword">const</span> edge&amp; e2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> e1.cost &lt; e2.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> par[MAX_N]   <span class="comment">//父亲</span></span><br><span class="line"><span class="keyword">int</span> rank[MAX_N]     <span class="comment">//数的高度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_union_find</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        par[i]=i;</span><br><span class="line">        rank[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> par[x]=find(par[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=find(x);</span><br><span class="line">    y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(rank[x]&lt;rank[y])&#123;</span><br><span class="line">        par[x]=y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        par[y]=x;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y])rank[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edge es[MAX_E];</span><br><span class="line"><span class="keyword">int</span> V,E;            <span class="comment">//顶点数和边数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(es,es+E,comp);     <span class="comment">//将边排序</span></span><br><span class="line">    init_union_find(V);     <span class="comment">//并查集初始化</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">        edge e=es[i];</span><br><span class="line">        <span class="keyword">if</span>(!same(e.u,e.v))&#123;</span><br><span class="line">            unite(e.u,e.v);</span><br><span class="line">            res+=e.cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大流最小割问题"><a href="#最大流最小割问题" class="headerlink" title="最大流最小割问题"></a>最大流最小割问题</h2><p>摘自：<a href="https://blog.csdn.net/yo_bc/article/details/72825629" target="_blank" rel="noopener">https://blog.csdn.net/yo_bc/article/details/72825629</a></p><h3 id="FORD-FULKERSON-FF"><a href="#FORD-FULKERSON-FF" class="headerlink" title="FORD-FULKERSON(FF)"></a>FORD-FULKERSON(FF)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[maxn*maxn];</span><br><span class="line"><span class="keyword">int</span> no, n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], pre[maxn], rec[maxn], flow[maxn];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">no = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态邻接表存边 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[no].v = v; edge[no].w = w;</span><br><span class="line">edge[no].next = head[u]; head[u] = no++;</span><br><span class="line">edge[no].v = u; edge[no].w = <span class="number">0</span>;</span><br><span class="line">edge[no].next = head[v]; head[v] = no++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"><span class="keyword">while</span>(!stk.empty()) stk.pop();</span><br><span class="line">pre[S] = S; flow[S] = inf;</span><br><span class="line">stk.push(S);</span><br><span class="line"><span class="keyword">while</span>(!stk.empty())<span class="comment">//用栈迭代替代dfs深搜 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top = stk.top(); stk.pop();</span><br><span class="line"><span class="keyword">int</span> k = head[top];</span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pre[edge[k].v] == <span class="number">-1</span> &amp;&amp; edge[k].w &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flow[edge[k].v] = min(flow[top], edge[k].w);</span><br><span class="line">pre[edge[k].v] = top;</span><br><span class="line">rec[edge[k].v] = k;</span><br><span class="line">stk.push(edge[k].v);</span><br><span class="line">&#125;</span><br><span class="line">k = edge[k].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre[T] != <span class="number">-1</span>) <span class="keyword">return</span> flow[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FF</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, add;</span><br><span class="line"><span class="keyword">while</span>((add = dfs(s, t)) != <span class="number">-1</span>)<span class="comment">//直到找不到增广路 </span></span><br><span class="line">&#123;</span><br><span class="line">ans += add;</span><br><span class="line"><span class="keyword">int</span> k = t;</span><br><span class="line"><span class="keyword">while</span>(k != s)</span><br><span class="line">&#123;</span><br><span class="line">edge[rec[k]].w -= add;</span><br><span class="line">edge[rec[k]^<span class="number">1</span>].w += add;</span><br><span class="line">k = pre[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n) </span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">add(u, v, w); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; FF(<span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Edmonds-Karp-EK"><a href="#Edmonds-Karp-EK" class="headerlink" title="Edmonds-Karp(EK)"></a>Edmonds-Karp(EK)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[maxn*maxn];</span><br><span class="line"><span class="keyword">int</span> no, n, m;</span><br><span class="line"><span class="keyword">int</span> head[maxn], pre[maxn], rec[maxn], flow[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">no = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态邻接表存边 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[no].v = v; edge[no].w = w;</span><br><span class="line">edge[no].next = head[u]; head[u] = no++;</span><br><span class="line">edge[no].v = u; edge[no].w = <span class="number">0</span>;</span><br><span class="line">edge[no].next = head[v]; head[v] = no++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pre, <span class="number">-1</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">pre[S] = S; flow[S] = inf;</span><br><span class="line">q.push(S);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top = q.front(); q.pop();</span><br><span class="line"><span class="keyword">int</span> k = head[top];</span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pre[edge[k].v] == <span class="number">-1</span> &amp;&amp; edge[k].w &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">flow[edge[k].v] = min(flow[top], edge[k].w);</span><br><span class="line">pre[edge[k].v] = top;</span><br><span class="line">rec[edge[k].v] = k;</span><br><span class="line">q.push(edge[k].v);</span><br><span class="line">&#125;</span><br><span class="line">k = edge[k].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre[T] != <span class="number">-1</span>) <span class="keyword">return</span> flow[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, add;</span><br><span class="line"><span class="keyword">while</span>((add = dfs(s, t)) != <span class="number">-1</span>)<span class="comment">//直到找不到增广路 </span></span><br><span class="line">&#123;</span><br><span class="line">ans += add;</span><br><span class="line"><span class="keyword">int</span> k = t;</span><br><span class="line"><span class="keyword">while</span>(k != s)</span><br><span class="line">&#123;</span><br><span class="line">edge[rec[k]].w -= add;</span><br><span class="line">edge[rec[k]^<span class="number">1</span>].w += add;</span><br><span class="line">k = pre[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n) </span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">add(u, v, w); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; EK(<span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> v, w, next;</span><br><span class="line">&#125;edge[maxn*maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn], pre[maxn], rec[maxn], head[maxn], block[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, no;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="comment">//静态邻接表存边 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[no].v = v; edge[no].w = w;</span><br><span class="line">edge[no].next = head[u]; head[u] = no++;</span><br><span class="line">edge[no].v = u; edge[no].w = <span class="number">0</span>;</span><br><span class="line">edge[no].next = head[v]; head[v] = no++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">no = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//初始化一定要注意把所涉及的都覆盖到 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">&#123; </span><br><span class="line">dis[i] = inf;</span><br><span class="line">block[i] = <span class="number">0</span>;<span class="comment">//标记阻塞点 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(!q.empty()) q.pop();</span><br><span class="line">dis[S] = <span class="number">0</span>; q.push(S);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())<span class="comment">//生成层次图 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tp = q.front(); q.pop();</span><br><span class="line"><span class="keyword">int</span> k = head[tp];</span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[edge[k].v] == inf &amp;&amp; edge[k].w)</span><br><span class="line">&#123;</span><br><span class="line">dis[edge[k].v] = dis[tp] + <span class="number">1</span>;</span><br><span class="line">q.push(edge[k].v);</span><br><span class="line">&#125;</span><br><span class="line">k = edge[k].next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> top = S, ans = <span class="number">0</span>, flow = inf;</span><br><span class="line">pre[S] = S; init(S, T);</span><br><span class="line"><span class="keyword">while</span>(dis[T] != inf)<span class="comment">//当S无法到达T，不能再增广了 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = head[top];</span><br><span class="line"><span class="keyword">while</span>(k != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[k].w &amp;&amp; dis[edge[k].v] == dis[top]+<span class="number">1</span> </span><br><span class="line">&amp;&amp; !block[edge[k].v]) <span class="keyword">break</span>;</span><br><span class="line">k = edge[k].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k != <span class="number">-1</span>)<span class="comment">//找到下一节点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = edge[k].v;</span><br><span class="line">flow = min(flow, edge[k].w);</span><br><span class="line">pre[v] = top; rec[v] = k;</span><br><span class="line">top = v;</span><br><span class="line"><span class="keyword">if</span>(top == T)</span><br><span class="line">&#123;</span><br><span class="line">ans += flow;</span><br><span class="line">v = <span class="number">-1</span>; k = T;</span><br><span class="line"><span class="keyword">while</span>(k != S)</span><br><span class="line">&#123;</span><br><span class="line">edge[rec[k]].w -= flow;</span><br><span class="line">edge[rec[k]^<span class="number">1</span>].w += flow;</span><br><span class="line"><span class="keyword">if</span>(!edge[rec[k]].w) v = k;<span class="comment">//寻找距S最近的一个"瓶颈"边 </span></span><br><span class="line">k = pre[k];</span><br><span class="line">&#125;</span><br><span class="line">flow = inf;<span class="comment">//此处flow必须在外面，大佬的板子可能没注意到，我认为是必须的 </span></span><br><span class="line"><span class="keyword">if</span>(v != <span class="number">-1</span>)<span class="comment">//找到"瓶颈"边 </span></span><br><span class="line">&#123;</span><br><span class="line">top = pre[v];</span><br><span class="line">k = top;</span><br><span class="line"><span class="keyword">while</span>(k != S)</span><br><span class="line">&#123;</span><br><span class="line">flow = min(edge[rec[k]].w, flow);</span><br><span class="line">k = pre[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">block[top] = <span class="number">1</span>;<span class="comment">//找不到下一节点成为阻塞点 </span></span><br><span class="line">top = pre[top];<span class="comment">//回溯 </span></span><br><span class="line"><span class="keyword">if</span>(block[S]) init(S, T);<span class="comment">//如果S被阻塞，重新计算层次图</span></span><br><span class="line"><span class="comment">//阻塞点的产生也造成了flow的最小值可能是后面的值，虽然进行一次</span></span><br><span class="line"><span class="comment">//增广并没什么问题，但上述寻找瓶颈边的判断则是必须的了。 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line">pre_init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">add(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dinic(<span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************比赛版本***********************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*maxn;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> w; <span class="keyword">int</span> v, next;&#125; edge[maxm];</span><br><span class="line"><span class="keyword">int</span> pre[maxn], rec[maxn], head[maxn], block[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, no;</span><br><span class="line"><span class="keyword">int</span> S, T;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">no = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[no].v = v; edge[no].w = w;</span><br><span class="line">edge[no].next = head[u]; head[u] = no++;</span><br><span class="line">edge[no].v = u; edge[no].w = <span class="number">0</span>;</span><br><span class="line">edge[no].next = head[v]; head[v] = no++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="built_in">memset</span>(block, <span class="number">0</span>, <span class="keyword">sizeof</span> block);</span><br><span class="line">q.push(S); dis[S] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> top = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = head[top]; k != <span class="number">-1</span>; k = edge[k].next)</span><br><span class="line"><span class="keyword">if</span>(dis[edge[k].v] == inf &amp;&amp; edge[k].w)</span><br><span class="line">dis[edge[k].v] = dis[top]+<span class="number">1</span>, q.push(edge[k].v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, flow = inf;</span><br><span class="line"><span class="keyword">int</span> top = S;</span><br><span class="line">reset(S, T); pre[S] = S;</span><br><span class="line"><span class="keyword">while</span>(dis[T] != inf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k, tmp;</span><br><span class="line"><span class="keyword">for</span>(k = head[top]; k != <span class="number">-1</span>; k = edge[k].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[k].w &amp;&amp; dis[edge[k].v]==dis[top]+<span class="number">1</span> &amp;&amp; </span><br><span class="line">!block[edge[k].v]) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">tmp = edge[k].v;</span><br><span class="line">flow = min(flow, edge[k].w);</span><br><span class="line">pre[tmp] = top, rec[tmp] = k;</span><br><span class="line">top = tmp;</span><br><span class="line"><span class="keyword">if</span>(top == T)</span><br><span class="line">&#123;</span><br><span class="line">ans += flow; tmp = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(; top != S; top = pre[top])</span><br><span class="line">&#123;</span><br><span class="line">edge[rec[top]].w -= flow;</span><br><span class="line">edge[rec[top]^<span class="number">1</span>].w += flow;</span><br><span class="line"><span class="keyword">if</span>(!edge[rec[top]].w) tmp = top;</span><br><span class="line">&#125;</span><br><span class="line">flow = inf;</span><br><span class="line"><span class="keyword">if</span>(tmp != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">top = pre[tmp];</span><br><span class="line"><span class="keyword">for</span>(; top != S; top = pre[top])</span><br><span class="line">flow = min(flow, edge[rec[top]].w);</span><br><span class="line">top = pre[tmp];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">block[top] = <span class="number">1</span>;</span><br><span class="line">top = pre[top];</span><br><span class="line"><span class="keyword">if</span>(block[S]) reset(S, T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapping</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">add(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n))</span><br><span class="line">&#123;</span><br><span class="line">S = <span class="number">1</span>, T = n;</span><br><span class="line">init();</span><br><span class="line">mapping();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dinic(S, T));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shortest-Augmenting-Paths-SAP"><a href="#Shortest-Augmenting-Paths-SAP" class="headerlink" title="Shortest Augmenting Paths(SAP"></a>Shortest Augmenting Paths(SAP</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*maxn; <span class="comment">//一定要好好计算边的数量   </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> v, w, next;  </span><br><span class="line">&#125;edge[maxm];  </span><br><span class="line"><span class="keyword">int</span> dis[maxn], pre[maxn], rec[maxn], head[maxn], gap[maxn], now[maxn];  </span><br><span class="line"><span class="keyword">int</span> n, m, no, up;  <span class="comment">//up指逆层次图可能还有增广路时dis的上界 </span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  </span><br><span class="line"><span class="comment">//静态邻接表存边   </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    edge[no].v = v; edge[no].w = w;  </span><br><span class="line">    edge[no].next = head[u]; head[u] = no++;  </span><br><span class="line">    edge[no].v = u; edge[no].w = <span class="number">0</span>;  </span><br><span class="line">    edge[no].next = head[v]; head[v] = no++;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    no = <span class="number">0</span>;  up = n;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; ++i)   </span><br><span class="line">    &#123;</span><br><span class="line">    now[i] = head[i];   <span class="comment">//now用作当前弧的优化   </span></span><br><span class="line">    <span class="comment">//注意这里now数组要把所有用到的标号都存过来  </span></span><br><span class="line">    gap[i] = <span class="number">0</span>, dis[i] = inf;</span><br><span class="line">    <span class="comment">//初始化一定要注意把所涉及的都覆盖到   </span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();  </span><br><span class="line">    dis[T] = <span class="number">0</span>; q.push(T);  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())   <span class="comment">//生成逆层次图   </span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> tp = q.front(); q.pop();  </span><br><span class="line">        ++gap[dis[tp]];  </span><br><span class="line">        <span class="keyword">int</span> k = head[tp];  </span><br><span class="line">        <span class="keyword">while</span>(k != <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(dis[edge[k].v] == inf &amp;&amp; edge[k^<span class="number">1</span>].w)  </span><br><span class="line">            &#123;  </span><br><span class="line">                dis[edge[k].v] = dis[tp]+<span class="number">1</span>;  </span><br><span class="line">                q.push(edge[k].v);  </span><br><span class="line">            &#125;  </span><br><span class="line">            k = edge[k].next;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SAP</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, flow = inf, top = S;  </span><br><span class="line">    pre[S] = S; init(S, T);  </span><br><span class="line">    <span class="keyword">while</span>(dis[S] &lt; up)    <span class="comment">//当S到T的距离大于等于点的个数时肯定就不能再增广了   </span></span><br><span class="line">    &#123;                   <span class="comment">//切记此处与节点数比较，因为通过方向变会造成距离可能达到节点数  </span></span><br><span class="line">        <span class="keyword">if</span>(top == T)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ans += flow;  </span><br><span class="line">            <span class="keyword">while</span>(top != S) <span class="comment">//修改残留网络，并置top为S   </span></span><br><span class="line">            &#123;  </span><br><span class="line">                edge[rec[top]].w -= flow;  </span><br><span class="line">                edge[rec[top]^<span class="number">1</span>].w += flow;  </span><br><span class="line">                top = pre[top];  </span><br><span class="line">            &#125;  </span><br><span class="line">            flow = inf;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> k = now[top];  </span><br><span class="line">        <span class="keyword">while</span>(k != <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> v = edge[k].v;  </span><br><span class="line">            <span class="keyword">if</span>(edge[k].w &amp;&amp; dis[top] == dis[v]+<span class="number">1</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                flow = min(flow, edge[k].w);  </span><br><span class="line">                pre[v] = top; rec[v] = k;  </span><br><span class="line">                now[top] = k;<span class="comment">//当前弧的优化   </span></span><br><span class="line">                top = v;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            k = edge[k].next;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> mind = n;  </span><br><span class="line">            <span class="keyword">if</span>(--gap[dis[top]] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//出现断层，间隙优化   </span></span><br><span class="line">            <span class="keyword">int</span> k = now[top] = head[top];<span class="comment">//改变当前点的距离标号，也要清除之前的当前弧优化的影响   </span></span><br><span class="line">            <span class="keyword">while</span>(k != <span class="number">-1</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(edge[k].w &amp;&amp; mind&gt;dis[edge[k].v]) mind = dis[edge[k].v];  </span><br><span class="line">                k = edge[k].next;  </span><br><span class="line">            &#125;  </span><br><span class="line">            ++gap[dis[top] = mind+<span class="number">1</span>];  </span><br><span class="line">            top = pre[top];<span class="comment">//回溯到上一个点   </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line">pre_init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">add(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; SAP(<span class="number">1</span>, n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************比赛版本***********************/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">205</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = maxn*maxn;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> w; <span class="keyword">int</span> v, next;&#125; edge[maxm];  </span><br><span class="line"><span class="keyword">int</span> pre[maxn], rec[maxn], head[maxn], gap[maxn], now[maxn];  </span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, no, up;  </span><br><span class="line"><span class="keyword">int</span> S, T; </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    edge[no].v = v; edge[no].w = w;  </span><br><span class="line">    edge[no].next = head[u]; head[u] = no++;  </span><br><span class="line">    edge[no].v = u; edge[no].w = <span class="number">0</span>;  </span><br><span class="line">    edge[no].next = head[v]; head[v] = no++;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pre_init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    no = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span> gap);  </span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; ++i)   </span><br><span class="line">    now[i] = head[i];</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) q.pop();  </span><br><span class="line">    dis[T] = <span class="number">0</span>; q.push(T);  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> tp = q.front(); q.pop();  </span><br><span class="line">        ++gap[dis[tp]];  </span><br><span class="line">        <span class="keyword">int</span> k = head[tp];  </span><br><span class="line">        <span class="keyword">while</span>(k != <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(dis[edge[k].v] == inf &amp;&amp; edge[k^<span class="number">1</span>].w)  </span><br><span class="line">            &#123;  </span><br><span class="line">                dis[edge[k].v] = dis[tp]+<span class="number">1</span>;  </span><br><span class="line">                q.push(edge[k].v);  </span><br><span class="line">            &#125;  </span><br><span class="line">            k = edge[k].next;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SAP</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, flow = inf;</span><br><span class="line"><span class="keyword">int</span> top = S;  </span><br><span class="line">    pre[S] = S; init(S, T);  </span><br><span class="line">    <span class="keyword">while</span>(dis[S] &lt; up)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(top == T)  </span><br><span class="line">        &#123;  </span><br><span class="line">            ans += flow;  </span><br><span class="line">            <span class="keyword">while</span>(top != S)</span><br><span class="line">            &#123;  </span><br><span class="line">                edge[rec[top]].w -= flow;  </span><br><span class="line">                edge[rec[top]^<span class="number">1</span>].w += flow;  </span><br><span class="line">                top = pre[top];  </span><br><span class="line">            &#125;  </span><br><span class="line">            flow = inf;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> k = now[top];  </span><br><span class="line">        <span class="keyword">while</span>(k != <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> v = edge[k].v;  </span><br><span class="line">            <span class="keyword">if</span>(edge[k].w &amp;&amp; dis[top] == dis[v]+<span class="number">1</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                flow = min(flow, edge[k].w);  </span><br><span class="line">                pre[v] = top; rec[v] = k;  </span><br><span class="line">                now[top] = k; top = v;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            k = edge[k].next;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">-1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> mind = up;  </span><br><span class="line">            <span class="keyword">if</span>(--gap[dis[top]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> k = now[top] = head[top];</span><br><span class="line">            <span class="keyword">while</span>(k != <span class="number">-1</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(edge[k].w &amp;&amp; mind&gt;dis[edge[k].v]) mind = dis[edge[k].v];  </span><br><span class="line">                k = edge[k].next;  </span><br><span class="line">            &#125;  </span><br><span class="line">            ++gap[dis[top] = mind+<span class="number">1</span>];  </span><br><span class="line">            top = pre[top];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mapping</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w); </span><br><span class="line">        add(u, v, w);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n))  </span><br><span class="line">    &#123;  </span><br><span class="line">up = n, S = <span class="number">1</span>, T = n;</span><br><span class="line">        pre_init();  </span><br><span class="line">        mapping();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SAP(S, T)); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> CP[MAX][MAX];           <span class="comment">//cp[i][j]=1 表示i能和j组cp</span></span><br><span class="line"><span class="keyword">bool</span> used[MAX];             <span class="comment">//记录是否已经被访问</span></span><br><span class="line"><span class="keyword">int</span> linked[MAX];            <span class="comment">//linked[i]=j 表示i和j组cp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=N;i++)&#123;    </span><br><span class="line"><span class="keyword">if</span> (CP[x][i]==<span class="literal">true</span> &amp;&amp; used[i]==<span class="literal">false</span>)      </span><br><span class="line">&#123;</span><br><span class="line">used[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (linked[i]==<span class="number">0</span> || fun(linked[i])) &#123; </span><br><span class="line">linked[j]=x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(linked,<span class="number">0</span>,<span class="keyword">sizeof</span>(linked));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">       <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));</span><br><span class="line">       <span class="keyword">if</span>(fun(i)) </span><br><span class="line">           ans++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转载： https://blog.csdn.net/qq_32265245/article/details/53046750</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    |求解最大匹配问题|</span></span><br><span class="line"><span class="comment">    |dfs实现|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v1, v2;  </span><br><span class="line"><span class="keyword">bool</span> Map[<span class="number">501</span>][<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">int</span> link[<span class="number">501</span>];  </span><br><span class="line"><span class="keyword">int</span> result;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= v2; ++y)  &#123;  </span><br><span class="line">        <span class="keyword">if</span> (Map[x][y] &amp;&amp; !visit[y])  &#123;  </span><br><span class="line">            visit[y] = <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (link[y] == <span class="number">0</span> || dfs(link[y]))  &#123;  </span><br><span class="line">                link[y] = x;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125; &#125; &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= v1; x++)  &#123;  </span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="literal">false</span>,<span class="keyword">sizeof</span>(visit));  </span><br><span class="line">        <span class="keyword">if</span> (dfs(x))  </span><br><span class="line">            result++;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="博弈"><a href="#博弈" class="headerlink" title="博弈"></a>博弈</h1><h2 id="巴仕博弈（Bash-Game）"><a href="#巴仕博弈（Bash-Game）" class="headerlink" title="巴仕博弈（Bash Game）"></a>巴仕博弈（Bash Game）</h2><p>描述：<br>只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(n%(m+<span class="number">1</span>))</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"first"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"second"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h2><p>描述：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜<br>1，我们用（a[k]，b[k]）（a[k] ≤ b[k] ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势。</p><p>2，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。</p><p>3，奇异局（举例）</p><p>首先列举人们已经发现的前几个奇异局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）</p><p>（8，13）、（9，15）、（11，18）、（12，20）。</p><p>通过观察发现：a[0]=b[0]=0,a[k]是未在前面出现过的最小自然数,而 b[k]= a[k] + k。</p><p>4，奇异局势有如下三条性质：</p><p>1）任何自然数都包含且仅包含在一个奇异局势中。</p><p>2）任意操作都可以使奇异局势变为非奇异局势。</p><p>3）必有一种操作可以使非奇异局势变为奇异局势。</p><p>5，奇异局势公式：</p><p>a[k]=[k*(1+√5)/2]，b[k]=a[k]+k。</p><p>(k=0,1,2……，[ ]表示取整）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//威佐夫博弈模板</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Gsr=(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)</span><br><span class="line">            swap(a,b);</span><br><span class="line">        <span class="keyword">if</span>(a == (<span class="keyword">int</span>)(Gsr*(b-a))) <span class="comment">//奇异局势，先拿者输</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"First Lose"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"First Win"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Nim博弈"><a href="#Nim博弈" class="headerlink" title="Nim博弈"></a>Nim博弈</h2><p>描述：有n堆石子，每堆各有$a_i$课石子。Alice和Bob轮流从非空的石子堆中取走至少一颗石子。<br>Alice先取，取光所有石子的一方获胜。当双方都采取最优策略时，谁会获胜？</p><p>结论：计算所有$a_i$的异或值，如果非零则先手胜，为零则后手胜。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Nim模板</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Gsr=(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> N，A[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) x^=A[i];</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">0</span>) </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Bob"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>描述：Alice和Bob在玩这样一个游戏。给定k个数字$a_1,a_2,···,a_k$。一开始，有n堆硬币，每堆各有$x_i$枚硬币。Alice和Bob轮流选出一堆硬币，从中取出一些硬币。每次所取硬币的枚数一定要在$a_1,a_2,···,a_k$当中。Alice先取，取光硬币的一方获胜。当双方都采取最优策略时，谁会获胜？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SG函数模板</span></span><br><span class="line"><span class="keyword">int</span> N,K,X[MAX_N]，A[MAX_K];</span><br><span class="line"><span class="comment">//利用动态规划计算grundy值的数组</span></span><br><span class="line"><span class="keyword">int</span> grundy[MAX_X+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//轮到自己时为0则必败</span></span><br><span class="line">    grundy[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算grundy值</span></span><br><span class="line">    <span class="keyword">int</span> max_x=*max_element(X,X+N);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=max_x;j++)&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;=j) s.insert(grundy[j-A[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.count(g)!=<span class="number">0</span>)g++;</span><br><span class="line">        grundy[j]=g;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//判断胜负</span></span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) x^=grundy[X[i]];</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">"Alice"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Bob"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些比赛用的模板&lt;br&gt;
    
    </summary>
    
    
      <category term="模板" scheme="https://ihopezero.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>NB群友</title>
    <link href="https://ihopezero.github.io/2019/04/27/NB%E7%BE%A4%E5%8F%8B/"/>
    <id>https://ihopezero.github.io/2019/04/27/NB群友/</id>
    <published>2019-04-27T14:33:38.000Z</published>
    <updated>2019-10-05T13:56:18.886Z</updated>
    
    <content type="html"><![CDATA[<p>一道出题人出的签到题，结果大部分人没签到。<br>于我而言，是看到数据量很大就慌了，觉得会超时，题面较长也没看下来。<br><a id="more"></a><br>题目链接：<a href="https://ac.nowcoder.com/acm/contest/625/A" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/625/A</a></p><p>题意：找出满足$L&lt;=数位积&lt;=R$的数的个数.</p><blockquote><p>思路：问题转换成求$数位积&lt;=R的个数-数位积&lt;=(L-1)的个数$，题解给的是dfs枚举2∼9每个数字出现的次数，然后再组合数统计一下答案，剪剪枝。<br>题解链接： <a href="https://fshp971.com/2019-scut-contest-easy/" target="_blank" rel="noopener">https://fshp971.com/2019-scut-contest-easy/</a><br>题解给的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REP(i,a,b) for(int i=a; i&lt;=b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PER(i,a,b) for(int i=a; i&gt;=b; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MP make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PB push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> DB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxT = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> LL MaxInt = (<span class="number">1L</span>L&lt;&lt;<span class="number">32</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">LL Fac[<span class="number">100</span>], InvFac[<span class="number">100</span>];</span><br><span class="line">LL C[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">LL lim;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(LL now, <span class="keyword">int</span> pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pt&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        LL ret = <span class="number">1</span>;</span><br><span class="line">        REP(i,<span class="number">2</span>,<span class="number">9</span>) &#123;</span><br><span class="line">            s += cnt[i];</span><br><span class="line">            ret = ret * C[s][cnt[i]] % P;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ret = <span class="number">0</span>;</span><br><span class="line">    cnt[pt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now &lt;= lim) &#123;</span><br><span class="line">        ret = (ret + dfs(now, pt<span class="number">-1</span>)) % P;</span><br><span class="line">        now *= pt, ++cnt[pt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        C[i][<span class="number">0</span>] = C[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; i; ++k) C[i][k] = (C[i<span class="number">-1</span>][k] + C[i<span class="number">-1</span>][k<span class="number">-1</span>]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--) &#123;</span><br><span class="line">        LL a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">        lim = b;</span><br><span class="line">        LL sb = dfs(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">        lim = a<span class="number">-1</span>;</span><br><span class="line">        LL sa = dfs(<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">        LL ans = (sb - sa + P) % P;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>看到另一篇题解说的是搜索过程枚举每一位数，然后记录一下状态值，剪枝<br>链接： <a href="https://www.cnblogs.com/ymzjj/p/10713187.html" target="_blank" rel="noopener">https://www.cnblogs.com/ymzjj/p/10713187.html</a></p><p>AC的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll M=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="built_in">map</span> &lt; ll, ll&gt; mp;</span><br><span class="line">ll L,R;</span><br><span class="line">ll res;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mp.count(x))&#123;</span><br><span class="line">        <span class="keyword">return</span> mp[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ll temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=i)&#123;</span><br><span class="line">            temp+=dfs(x/i)+<span class="number">1</span>;       <span class="comment">//枚举每一位数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp[x]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;L,&amp;R);</span><br><span class="line">        res=(dfs(R)-dfs(L<span class="number">-1</span>))%M;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道出题人出的签到题，结果大部分人没签到。&lt;br&gt;于我而言，是看到数据量很大就慌了，觉得会超时，题面较长也没看下来。&lt;br&gt;
    
    </summary>
    
    
      <category term="牛客网" scheme="https://ihopezero.github.io/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Word-Search Wonder</title>
    <link href="https://ihopezero.github.io/2019/04/27/Word-Search-Wonder/"/>
    <id>https://ihopezero.github.io/2019/04/27/Word-Search-Wonder/</id>
    <published>2019-04-27T11:45:10.000Z</published>
    <updated>2019-10-05T13:54:20.028Z</updated>
    
    <content type="html"><![CDATA[<p>题目链接: <a href="http://poj.org/problem?id=1501" target="_blank" rel="noopener">http://poj.org/problem?id=1501</a><br><a id="more"></a></p><p>题意：给一个字符矩阵，再给“单词”，在矩阵中找到单词，输出单词首元素的坐标和末元素的坐标。</p><blockquote><p>思路：是一道深搜，需要注意的是深搜的方向由始至终只能往一个方向，水平，<br>垂直还有斜线，而其他只需要理解好题目套模板即可做出，还有就是本题不需要<br>标记数组，因为深搜方向只有一个，途中不会碰到已访问的点。</p></blockquote><p>下面是AC代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> mat[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="keyword">int</span> first_x,first_y,last_x,last_y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> i,<span class="keyword">int</span> dx,<span class="keyword">int</span> dy)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="string">'\0'</span>)&#123;</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">        last_x=dx;</span><br><span class="line">        last_y=dy;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nx=<span class="number">2</span>*dx-x,ny=<span class="number">2</span>*dy-y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>&lt;nx&amp;&amp;nx&lt;=n&amp;&amp;<span class="number">0</span>&lt;ny&amp;&amp;ny&lt;=n&amp;&amp;mat[nx][ny]==a[i])&#123;</span><br><span class="line">        dfs(dx,dy,i+<span class="number">1</span>,nx,ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;mat[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>,a)!=EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[<span class="number">0</span>]==mat[i][j]&amp;&amp;!flag)&#123;</span><br><span class="line">                    <span class="comment">//dfs(i,j,1);</span></span><br><span class="line">                    first_x=i;first_y=j;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> dx=<span class="number">-1</span>;dx&lt;=<span class="number">1</span>;dx++)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> dy=<span class="number">-1</span>;dy&lt;=<span class="number">1</span>;dy++)&#123;</span><br><span class="line">                            <span class="keyword">int</span> nx=i+dx,ny=j+dy;</span><br><span class="line">                            <span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="string">'\0'</span>)&#123;</span><br><span class="line">                                flag=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(mat[nx][ny]==a[<span class="number">1</span>]&amp;&amp;!flag)&#123;</span><br><span class="line">                                dfs(i,j,<span class="number">2</span>,nx,ny);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d,%d %d,%d\n"</span>,first_x,first_y,last_x,last_y);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not found\n"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目链接: &lt;a href=&quot;http://poj.org/problem?id=1501&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=1501&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="DFS" scheme="https://ihopezero.github.io/tags/DFS/"/>
    
  </entry>
  
</feed>
