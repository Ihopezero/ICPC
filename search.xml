<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第三章-指令系统概述]]></title>
    <url>%2F2020%2F03%2F26%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[指令系统基本概念1.指令与指令系统 指令：控制计算机完成某种操作的命令 指令系统： 处理器所能识别的所有指令的集合 指令的兼容性：同一系列机的指令都是兼容的。 一条指令应包含的信息： 运算数据的来源 运算结果的去向 执行的操作 2. 指令格式操作码 [操作数]（目标操作数），[操作数]（源操作数） 操作码：执行何种操作 操作数：指令执行的对象（参加操作的数据或数据存放的地址） 零操作数指令： 操作码 单操作数指令： 操作码 操作数 双操作数指令： 操作码 操作数，操作数 多操作数指令： 三操作数及以上 3. 指令中的操作数立即数操作数 立即数本身是参加操作的数据，可以是8位或16位，只能作为源操作数。 立即数无法作为目标操作数 立即数可以是无符号或带符号数，数值符合其取值范围 寄存器操作数 参加运算的数存放在指令给出的寄存器中，可以是16位或8位。 表现形式：[（操作数在内存中的偏移地址） ] 存储器操作数 参加运算的数存放在存储器的某一个或某两个单元中 三种类型操作数的比较 立即数： 由指令直接给出，是常数性质 无地址含义，只表示运算的数据 寄存器操作数 表示运算的数据存放在寄存器中 多数情况下，寄存器操作数指通用寄存器 在三类操作数中所需运行时间最短 存储器操作数 表示运算的数据存放在内存 指令中“[ ]”里是数据所在单元的偏移地址 在三类操作数中所需运行时间最长。不能作为目标操作数 指令的寻址方式1. 直接寻址指令中直接给出操作数的偏移地址 例： MOV AX，[1200H] 直接寻址方式下，操作数默认为在数据段，但允许段重设，即由指令给出所在逻辑段。 例：（ES：段重设符） MOV AX，ES：[1200H] 2. 寄存器间接寻址 操作数存放在内存中，数据在内存中的偏移地址为方括号中通用寄存器的内容。 仅有4个通用寄存器可用于存放数据的偏移地址 ————间址寄存器：（BX，BP，SI，DI） 间接寻址的一般格式：[ 间址寄存器 ] 例： MOV BX，1200H MOV AX，[BX] 操作数的段地址（数据处于哪个段）取决于选择哪一个间址寄存器： BX，SI，DI——————默认在数据段 BP —————————默认在堆栈段 3. 寄存器相对寻址操作数的偏移地址为寄存器的内容加上一个位移量。 例：DATA是任意8bit或16bit常数 MOV AX，[BX+DATA] 相对寻址主要用于一维数组的操作 常将位移量作为“表头”地址，间址寄存器的值作为表内相对地址 4. 基址、变址寻址操作数的偏移地址为 一个基址寄存器的内容 + 一个变址寄存器的内容； 操作数的段地址由选择的基址寄存器决定 基址寄存器为BX，默认在数据段 基址寄存器为BP，默认在堆栈段 基址变址寻址方式与相对寻址方式一样，主要用于一维数组操作。 5. 基址、变址、相对寻址 操作数的偏移地址为： 基址寄存器内容+变址寄存器内容+位移量 操作数的段地址由选择的基址寄存器决定。 基址变址相对寻址方式主要用于二维表格操作。 小结： 寻址方式表示指令运算对象的来源和运算结果的去向 注意点： 立即寻址仅针对源操作数 寄存器寻址表示指令运算的数据在寄存器中（常为通用寄存器） 存储器寻址表示指令运算的对象在内存中 数据在内存中的偏移地址在[ ]中，段地址可以默认或重设 存储器寻址和寄存器寻址均可用于源或目标操作数 数据传送指令一、通用数据传送指令1. 一般数据传送指令 一般数据传送指令 MOV 格式： MOV dest，src 操作： src——&gt;dest 例： MOV AL，BL 注意点： 两操作数字长必须相同； 两操作数不允许同时为存储器操作数； 两操作数不允许同时为段寄存器； 在源操作数是立即数时，目标操作数不能是段寄存器； IP和CS不作为目标操作数，FLAGS一般也不作为操作数在指令中出现。 2. 堆栈操作指令 堆栈操作的原则 先进后出 以字为单位 堆栈操作指令： 压栈指令 格式: PUSH OPRD 指令执行过程： SP - 2 → SP 操作数高字节 → SP+1 操作数低字节 → SP 出栈指令 格式: POP OPRD 指令执行过程： SP→ 操作数低字节 SP+1→ 操作数高字节 SP←SP+2 堆栈操作指令说明 指令的操作数必须是16位； 操作数可以是寄存器或存储器两单元，但不能是立即数； 不能从栈顶弹出一个字给CS； PUSH和POP指令在程序中一般成对出现； PUSH指令的操作方向是从高地址向低地址，而POP指令的操作正好相反。 3. 交换指令 格式： XCHG REG，MEM/REG 注： 两操作数必须有一个是寄存器操作数 不允许使用段寄存器。 例： XCHG AX，BX XCHG [2000]，CL 4. 查表指令 格式： XLAT 说明： 用BX的内容代表表格首地址，AL内容为表内位移量，BX+AL得到要查找元素的偏移地址 操作： 将BX+AL所指单元的内容送AL 5. 字位扩展指令 将符号数的符号位扩展到高位； 指令为零操作数指令，采用隐含寻址，隐含的操作数为AX及AX，DX 无符号数的扩展规则为在高位补0 字节到字的扩展指令 格式： CBW 操作： 将AL内容扩展到AX 规则： 若最高位=1，则执行后AH=FFH 若最高位=0，则执行后AH=00H 字到双字的扩展指令 格式： CWD 操作： 将AX内容扩展到DX AX 规则： 若最高位=1，则执行后DX=FFFFH 若最高位=0，则执行后DX=0000H 二、地址传送指令1. LEA指令 操作： 将变量的16位偏移地址写入到目标寄存器 当程序中用符号表示内存偏移地址时，须使用该指令。 格式： LEA REG，MEM 指令要求： 源操作数必须是一个存储器操作数，目标操作数通常是间址寄存器。 LEA指令与MOV指令执行结果对比 MOV指令读取指定内存单元的内容 LEA指令读取指定内存单元的偏移地址 2. LDS、LES指令 LDS和LES均用于将一个32位的远地址指针写入到目标寄存器。 LDS（Load pointer using DS）的一般格式： LDS 通用寄存器，存储器操作数 (将源操作数的偏移地址送目标寄存器，将源操作数的段地址送DS) LES（Load pointer using ES）的一般格式： LES 通用寄存器，存储器操作数 (将源操作数的偏移地址送目标寄存器，将源操作数的段地址送ES) 三、标志传送指令 标志传送指令 隐含操作数AH： LAHF（Load AH from Flags） SAHF（Store AH into Flags） SAHF执行与LAHF相反的操作 操作：将FLAGS的低8位装入AH 隐含操作数FLAGS： PUSHF（Push flags onto stack） POPF（Pop flags off stack） 四、输入输出指令输入输出指令 专门面向I/O端口操作的指令 端口地址在指令中的表示方式 指令功能： 从端口地址读入数据到累加器/将累加器的值输出到端口中 指令格式： 输入指令： IN acc，PORT 输出指令 ：OUT PORT，acc 指令寻址方式 根据端口地址码的长度，指令具有两种不同的端口地址表现形式。 直接寻址 端口地址为8位时，指令中直接给出8位端口地址； 寻址256个端口。 间接寻址 端口地址为16位时，指令中的端口地址必须由DX指定； 可寻址64K个端口。]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-18]]></title>
    <url>%2F2020%2F03%2F18%2F3-18%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2018初赛]第几个幸运数 题目描述到x星球旅行的游客都被发给一个整数，作为游客编号。x星的国王有个怪癖，他只喜欢数字3,5和7。国王规定，游客的编号如果只含有因子：3,5,7,就可以获得一份奖品。前10个幸运数字是：3 5 7 9 15 21 25 27 35 45，因而第11个幸运数字是：49小明领到了一个幸运数字 59084709587505。去领奖的时候，人家要求他准确说出这是第几个幸运数字，否则领不到奖品。请你帮小明计算一下，59084709587505是第几个幸运数字。 输出输出一个整数表示答案 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt; &gt; pq;map&lt;ll,int&gt; mp;int a[3]=&#123;3,5,7&#125;;int main ()&#123; pq.push(1); ll ans=0; while(1)&#123; ll x=pq.top(); pq.pop(); if(x==59084709587505)&#123; printf("%lld\n",ans); break; &#125; for(int i=0;i&lt;3;i++)&#123; ll temp=x*a[i]; if(mp[temp]==0)&#123; mp[temp]=1; pq.push(temp); &#125; &#125; ans++; &#125; return 0;&#125; [蓝桥杯2018初赛]哪天返回 题目描述小明被不明势力劫持。后莫名其妙被扔到x星站再无问津。小明得知每天都有飞船飞往地球，但需要108元的船票，而他却身无分文。他决定在x星战打工。好心的老板答应包食宿，第1天给他1元钱。并且，以后的每一天都比前一天多2元钱，直到他有足够的钱买票。请计算一下，小明在第几天就能凑够108元，返回地球。 输出输出一个整数表示答案 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int a;int tot;int main ()&#123; a=1; int i=1; for(;tot&lt;108;i++)&#123; tot+=a; a+=2; &#125; cout&lt;&lt;i-1&lt;&lt;endl;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-17]]></title>
    <url>%2F2020%2F03%2F17%2F3-17%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]日期问题 题目描述小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？ 输入一个日期，格式是”AA/BB/CC”。 (0 &lt;= A, B, C &lt;= 9) 输出输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。多个日期按从早到晚排列。 样例输入02/03/04 样例输出2002-03-042004-02-032004-03-02 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int yy,mm,dd;int day2[13]=&#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;;int day[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int ans[2200][15][35];bool fun(int year)&#123; bool flag=0; if(year%400==0||(year%4==0&amp;&amp;year%100!=0))&#123; flag=1; &#125; return flag;&#125;int main ()&#123; scanf("%d/%d/%d",&amp;yy,&amp;mm,&amp;dd); //年/月/日 if(yy&gt;=0&amp;&amp;yy&lt;=59&amp;&amp;mm&gt;=1&amp;&amp;mm&lt;=12&amp;&amp;dd&gt;=1&amp;&amp;dd&lt;=31)&#123; ans[yy+2000][mm][dd]=1; if(fun(yy+2000))&#123; if(dd&gt;day2[mm])&#123; ans[yy+2000][mm][dd]=0; &#125; &#125; else&#123; if(dd&gt;day[mm])&#123; ans[yy+2000][mm][dd]=0; &#125; &#125; &#125; if(yy&lt;=99&amp;&amp;yy&gt;=60&amp;&amp;mm&gt;=1&amp;&amp;mm&lt;=12&amp;&amp;dd&gt;=1&amp;&amp;dd&lt;=31)&#123; ans[yy+1900][mm][dd]=1; if(fun(yy+1900))&#123; if(dd&gt;day2[mm])&#123; ans[yy+1900][mm][dd]=0; &#125; &#125; else&#123; if(dd&gt;day[mm])&#123; ans[yy+1900][mm][dd]=0; &#125; &#125; &#125; //月/日/年 if(yy&gt;=1&amp;&amp;yy&lt;=12&amp;&amp;mm&gt;=1&amp;&amp;mm&lt;=31&amp;&amp;dd&gt;=60)&#123; ans[dd+1900][yy][mm]=1; if(fun(dd+1900))&#123; if(mm&gt;day2[yy])&#123; ans[dd+1900][yy][mm]=0; &#125; &#125; else&#123; if(mm&gt;day[yy])&#123; ans[dd+1900][yy][mm]=0; &#125; &#125; &#125; if(yy&gt;=1&amp;&amp;mm&gt;=1&amp;&amp;yy&lt;=12&amp;&amp;mm&lt;=31&amp;&amp;dd&lt;=59)&#123; ans[dd+2000][yy][mm]=1; if(fun(dd+2000))&#123; if(mm&gt;day2[yy])&#123; ans[dd+2000][yy][mm]=0; &#125; &#125; else&#123; if(mm&gt;day[yy])&#123; ans[dd+2000][yy][mm]=0; &#125; &#125; &#125; //日/月/年 if(yy&gt;=1&amp;&amp;yy&lt;=31&amp;&amp;mm&gt;=1&amp;&amp;mm&lt;=12&amp;&amp;dd&gt;=60)&#123; ans[dd+1900][mm][yy]=1; if(fun(dd+1900))&#123; if(yy&gt;day2[mm])&#123; ans[dd+1900][mm][yy]=0; &#125; &#125; else&#123; if(yy&gt;day[mm])&#123; ans[dd+1900][mm][yy]=0; &#125; &#125; &#125; if(yy&gt;=1&amp;&amp;yy&lt;=31&amp;&amp;mm&gt;=1&amp;&amp;mm&lt;=12&amp;&amp;dd&lt;=59)&#123; ans[dd+2000][mm][yy]=1; if(fun(dd+2000))&#123; if(yy&gt;day2[mm])&#123; ans[dd+2000][mm][yy]=0; &#125; &#125; else&#123; if(yy&gt;day[mm])&#123; ans[dd+2000][mm][yy]=0; &#125; &#125; &#125; for(int i=1960;i&lt;=2059;i++)&#123; for(int j=1;j&lt;=12;j++)&#123; for(int k=1;k&lt;=31;k++)&#123; if(ans[i][j][k]==1)&#123; printf("%d-%02d-%02d\n",i,j,k); &#125; &#125; &#125; &#125;&#125; [蓝桥杯2017初赛]九宫幻方 题目描述小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分。三阶幻方指的是将1~9不重复的填入一个3*3的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：“二四为肩，六八为足，左三右七，戴九履一，五居其中”，通过这样的一句口诀就能够非常完美的构造出一个九宫格来。4 9 23 5 78 1 6有意思的是，所有的三阶幻方，都可以通过这样一个九宫格进行若干镜像和旋转操作之后得到。现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序~ 输入输入一个3*3的矩阵，其中为0的部分表示被小明抹去的部分。对于100%的数据，满足给出的矩阵至少能还原出一组可行的三阶幻方。 输出如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出“Too Many”（不包含引号）。 样例输入0 7 20 5 00 3 0 样例输出6 7 21 5 98 3 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int b[10];int c[10];int ans;int main ()&#123; for(int i=1;i&lt;=9;i++)&#123; scanf("%d",&amp;b[i]); &#125; do&#123; int row1,row2,row3; int col1,col2,col3; int k1,k2; row1=a[1]+a[2]+a[3]; row2=a[4]+a[5]+a[6]; row3=a[7]+a[8]+a[9]; col1=a[1]+a[4]+a[7]; col2=a[2]+a[5]+a[8]; col3=a[3]+a[6]+a[9]; k1=a[1]+a[5]+a[9]; k2=a[3]+a[5]+a[7]; if(row1==15&amp;&amp;row2==15&amp;&amp;row3==15&amp;&amp;col1==15&amp;&amp;col2==15&amp;&amp;col3==15&amp;&amp;k1==15&amp;&amp;k2==15)&#123; bool flag=1; for(int i=1;i&lt;=9;i++)&#123; if(b[i]!=0&amp;&amp;b[i]!=a[i])&#123; flag=0; break; &#125; &#125; if(flag)&#123; ans++; for(int i=1;i&lt;=9;i++)&#123; c[i]=a[i]; &#125; &#125; &#125; &#125;while(next_permutation(a+1,a+10)); if(ans==1)&#123; for(int i=1;i&lt;=9;i++)&#123; printf("%d ",c[i]); if(i%3==0) printf("\n"); &#125; &#125; else&#123; printf("Too Many\n"); &#125; &#125; [蓝桥杯2017初赛]等差素数列 题目描述2,3,5,7,11,13,….是素数序列。类似：7,37,67,97,127,157 这样全由素数组成的等差数列，叫等差素数数列。上边的数列公差为30，长度为6。2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。这是数论领域一项惊人的成果！有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：长度为10的等差素数列，其公差最小值是多少？ 输出输出一个整数表示答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int n=1000000; int vis[MAX_N];int prime[MAX_N];int cnt=0;void Prime()&#123; for(int i=2;i&lt;=n;i++) &#123; if(!vis[i]) prime[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++) &#123; vis[i*prime[j]]=i; if(i%prime[j]==0) break; &#125; &#125;&#125;int main ()&#123; cout&lt;&lt;210&lt;&lt;endl; /*Prime(); int res=1; for(int i=0;i&lt;1000&amp;&amp;res&lt;10;i++)&#123; int temp=prime[i]; for(int j=1;j&lt;=1000&amp;&amp;res&lt;10;j++)&#123; res=1; int tmp=temp+j; while(!vis[tmp])&#123; res++; tmp=tmp+j; //cout&lt;&lt;tmp&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; if(res&gt;=10)&#123; printf("%d %d",temp,j); break; &#125; &#125; &#125; &#125; */ return 0;&#125; [蓝桥杯2018初赛]乘积尾零 题目描述如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？123456789105650 4542 3554 473 946 4114 3871 9073 90 4329 2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 1486 5722 3135 1170 4014 5510 5120 729 2880 9019 2049 698 4582 4346 4427 646 9742 7340 1230 7683 5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 6701 6645 1671 5978 2704 9926 295 3125 3878 6785 2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 689 5510 8243 6114 337 4096 8199 7313 3685 211 输出输出一个整数表示答案 思路：0会由2和5共同构成，将每个数拆分成由2 和 5 组成的数，统计2 和5 的个数，然后取2 和 5 个数的最小值即为尾零的个数，实际上5的个数会比2的个数小 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int a;int main ()&#123; /*int two=0,five=0; for(int i=1;i&lt;=100;i++)&#123; scanf("%d",&amp;a); while(a%2==0||a%5==0)&#123; if(a%2==0) two++,a/=2; if(a%5==0) five++,a/=5; &#125; &#125; int ans=min(two,five); cout&lt;&lt;ans&lt;&lt;endl;*/ cout&lt;&lt;31&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-16]]></title>
    <url>%2F2020%2F03%2F17%2F3-16%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]分巧克力 题目描述儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足： 形状是正方形，边长是整数 大小相同例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？ 输入第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000)输入保证每位小朋友至少能获得一块1x1的巧克力。 输出输出切出的正方形巧克力最大可能的边长。 样例输入2 106 55 6 样例输出2 思路：通过二分枚举出最大可能的边长. 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;int H[MAX_N],W[MAX_N]; int N,K;bool check(int m)&#123; int cnt=0; bool flag=0; for(int i=1;i&lt;=N;i++)&#123; cnt+=((H[i]/m)*(W[i]/m)); if(cnt&gt;=K)&#123; flag=1; break; &#125; &#125; return flag;&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); for(int i=1;i&lt;=N;i++)&#123; scanf("%d%d",&amp;H[i],&amp;W[i]); &#125; int l=0,r=100000; while(r&gt;l)&#123; int m=l+(r-l)/2; if(check(m)) l=m+1; else r=m; &#125; printf("%d\n",l-1); return 0;&#125; [蓝桥杯2017初赛]承压计算 题目描述 X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。每块金属原料的外形、尺寸完全一致，但重量不同。金属材料被严格地堆放成金字塔形。其中的数字代表金属块的重量（计量单位较大）。（参考输入中的金字塔）最下一层的X代表30台极高精度的电子秤。假设每块原料的重量都十分精确地平均落在下方的两个金属块上，最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。电子秤的计量单位很小，所以显示的数字很大。工作人员发现，其中读数最小的电子秤的示数为：2086458231请你推算出：读数最大的电子秤的示数为多少？ 输入本题无输入1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 7 5 8 7 8 8 9 2 7 2 8 1 4 9 1 8 1 8 8 4 1 7 9 6 1 4 5 4 5 6 5 5 6 9 5 6 5 5 4 7 9 3 5 5 1 7 5 7 9 7 4 7 3 3 1 4 6 4 5 5 8 8 3 2 4 3 1 1 3 3 1 6 6 5 5 4 4 2 9 9 9 2 1 9 1 9 2 9 5 7 9 4 3 3 7 7 9 3 6 1 3 8 8 3 7 3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X``` &gt;输出输出一个整数表示答案```c++#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5; double a[35][35]; int main()&#123; /*for(int i=1;i&lt;=29;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; scanf("%lf",&amp;a[i][j]); &#125; &#125; for(int i=1;i&lt;=29;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; double half=a[i][j]/2.0; a[i+1][j]+=half; a[i+1][j+1]+=half; &#125; &#125; double ma=0; double mi=0x3f3f3f3f; for(int i=1;i&lt;=30;i++)&#123; ma=max(ma,a[30][i]); mi=min(mi,a[30][i]); &#125; ll ans=(2086458231/mi)*ma; printf("%lld",ans);*/ cout&lt;&lt;72665192664&lt;&lt;endl;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第二章 微处理器与总线]]></title>
    <url>%2F2020%2F03%2F16%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8E%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[8088/8086微处理器8088/8086 CPU的特点 采用并行流水线工作方式————通过设置指令预取队列实现（CPU内部结构） 对内存空间实现分段管理————将内存分为4个段并设置地址段寄存器，以实现对1MB空间的寻址 （实模式存储器寻址） 支持协处理器 （工作模式） 8080/8086 CPU的两种工作模式 8088/8086可工作于两种模式下：· 最小模式· 最大模式 两种工作模式的选择方式： 8088是工作在最小还是最大模式由MN/MX引线的状态决定。· MN/MX=0————最大模式· MN/MX=1————最小模式 8080的主要引线及内部结构1.8080 CPU最小模式下的主要引脚信号 8080最小模式下的主要引脚信号————4组· 完成一次访问内存或接口所需要的主要信号· 与外部同步控制信号· 中断请求和响应信号· 总线保持和响应信号 微处理器读取一条指令的控制过程 发出读取数据所在的目标地址 （地址信号）· 内存储器单元地址· I/O接口地址 发出读控制信号 （控制信号） 送出传输的数据 （数据信号） 8088 CPU 最小模式下的主要引脚信号 主要控制信号· #WR ：写信号；· #RD ：读信号；· IO/#M ：为“0”表示访问内存，为“1”表示访问接口；· #DEN ：低电平有效时，允许进行读/写操作；· #DT/#R ：数据收发器的传送方向控制；· ALE ： 地址锁存信号；· RESET ： 复位信号。 READY信号 中断请求和响应信号· INTR： 可屏蔽中断请求输入端· NMI：非屏蔽中断请求输入端· INTA：中断响应输出端 总线保持信号· HOLD：总线保持请求信号输入端。当CPU以外的其他设备要求占用总线时，通过该引脚向CPU发出请求。· HLDA：总线保持响应信号输出端。CPU对HOLD信号的响应信号。 8088和8086CPU引线功能比较 数据总线宽度不同· 8088的外部总线宽度是8位，8086为16位。 访问存储器和输入输出控制信号含义不同· 8088————IO/M=0表示访问内存；· 8086————IO/M=1表示访问内存。+其他部分引线功能的区别。 2. 8088内部结构执行单元（EU） 构成：· 运算器· 8个通用寄存器· 1个标志寄存器· EU部分控制电路 功能· 指令译码· 指令执行· 暂存中间运算结果· 保存运算结果特征 总线接口单元（BIU） 功能：· 从内存中取指令到指令预存队列 （并行流水线工作的基础）· 负责与内存或输入/输出接口之间的数据传送· 在执行转移程序时，BIU使指令预取队列复位，从指定的新地址取指令，并立即传给执行单元执行。 结论 指令预取队列的存在使EU和BIU两个部分可同时进行工作（实现指令的并行执行） 提高了CPU的效率 降低了对存储器存取速度的要求 8080内部寄存器内部寄存器的类型 含14个16位寄存器，按功能可分为三类· 8个通用寄存器· 4个段寄存器· 2个控制寄存器 通用寄存器 数据寄存器 · AX：累加器 所有I/O指令都通过AX与接口传送信息，中间运算结果也多放于AX中； · BX:基址寄存器 在间接寻址中用于存放基地址； · CX：计数寄存器 用于在循环或串操作指令中存放计数值； · DX：数据寄存器 在间接寻址的I/O指令中存放I/O端口地址；在32位乘除法运算时，存放高16位数。 8088/8086含4个16位数据寄存器，它们又可分为8个8位寄存器,即:· AX————&gt;AH,AL· BX————&gt;BH,BL· CX————&gt;CH,CL· DX————&gt;DH,DL 地址指针寄存器· SP : 堆栈指针寄存器 其内容为栈顶的偏移地址 · BP : 基址指针寄存器 常用于在访问内存时存放内存单元的偏移地址。 变址寄存器· SI: 源变址寄存器· DI:目标变址寄存器· 变址寄存器在指令中常用于存放数据在内存中的地址。 BX与BP在应用上的区别· 作为通用寄存器，二者均可用于存放数据；· 作为基址寄存器，用BX表示所寻找的数据在数据段；用BP则表示数据在堆栈段。 控制寄存器 状态标志位· CF（Carry Flag） 进位标志位。加(减)法运算时，若最高位有进(借)位则CF=1· OF（Overflow Flag） 溢出标志位。当算术运算的结果超出了有符号数的可表达范围时，OF=1· ZF（Zero Flag） 零标志位。当运算结果为零时ZF=1· SF（Sign Flag） 符号标志位。当运算结果的最高位为1时，SF=1· PF（Parity Flag） 奇偶标志位。运算结果的低8位中“1”的个数为偶数时PF=1· AF（Auxiliary Carry Flag） 辅助进位标志位。加(减)操作中，若Bit3向Bit4有进位(借位)，AF=1 控制标志位· TF（Trap Flag） 陷阱标志位，也叫跟踪标志位。TF=1时，使CPU处于单步执行指令的工作方式。· IF（Interrupt Enable Flag）中断允许标志位。IF=1使CPU可以响应可屏蔽中断请求。· DF（Direction Flag）方向标志位。在数据串操作时确定操作的方向。 段寄存器 作用· 用于存放相应逻辑段的段基地址 8086/8088内存中逻辑段的类型· 代码段————&gt;存放指令代码· 数据段————&gt;存放操作的数据· 附加段————&gt;存放操作的数据· 堆栈段————&gt;存放暂时不用但需保存的数据。 CS ： 代码段寄存器，存放代码段的段基地址。 DS ： 数据段寄存器 ，存放数据段的段基地址。 ES ： 附加段寄存器，存放数据段的段基地址。 SS ： 堆栈段寄存器， 存放堆栈段的段基地址 实模式下的存储器寻址内存储器管理思想 8088 CPU是16位体系结构的微处理器 可以同时处理（产生）16位二进制码（直接管理64K个内存单元） 8088 CPU需要管理1MB内存（需要能够产生1M个地址编码）如何实现？内存分段管理方式内存单元的编址 内存每个单元的地址在逻辑上都由两部分组成：· 段（基）地址 ：指示存储单元在整个内存空间中处于哪个区域（段）· 段内地址（相对地址/偏移地址） ：指示存储单元在段中的相对位置（与段中第1个单元的距离） 存储器的编址 段基地址：· 决定存储单元在内存中的位置 相对地址（偏移地址）：· 该存储单元相对段内第一个单元的距离 逻辑段的起始地址称为段首· 每个逻辑段内的第一个单元（由偏移地址的定义得：段首的偏移地址=0） 物理地址：· 内存单元在整个内存空间中的惟一地址 实地址模式下的存储器地址变换 内存物理地址由段基地址和偏移地址组成物理地址=段基地址×16+偏移地址 逻辑段与逻辑地址 内存的分段是逻辑分段，不是物理段。各个逻辑段在地址上可以不相连、可以部分重合，也可以完全重合。 每个内存单元具有惟一物理地址，但可能具有多个逻辑地址。 结论： 一个内存单元可以同时处于两个逻辑段 一个内存单元可以在不同的时刻属于相同（或不同）类型的段 一个内存单元在同一时刻可以属于不同类型的段 堆栈及堆栈段的使用 堆栈：· 内存中一个特殊区域，用于存放暂时不用或需要保护的数据。· 常用于响应中断或子程序调用。 8080系统总线总线时序 CPU工作时序：· CPU各引脚信号在时间上的关系 总线周期：·CPU完成一次访问内存（或接口）操作所需要的时间。· 一个总线周期至少包括4个时钟周期。 总线的概念 总线：· 是一组导线和相关的控制、驱动电路的集合。是计算机系统各部件之间传输地址、数据和控制信息的通道。· 地址总线（AB）· 数据总线（DB）· 控制总线（CB） 总线按层次结构分类· CPU总线· 系统总线· 外部总线 总线结构 单总线结构 双总线结构· 面向CPU的双总线结构· 面向主存的双总线结构 多总线结构 面向CPU的双总线结构存储器与I/O接口间无直接通道在单总线结构基础上增加一条CPU到存储器的高速总线 总线的基本功能 数据传送 仲裁控制 出错处理 总线驱动 总线的主要性能指标 总线带宽（B/S）：· 单位时间内总线上可传送的数据量· 总线带宽=位宽*工作频率 总线位宽（bit）：· 能同时传送的数据位数 总线的工作频率（MHz）· 总线带宽=（位宽/8）*（工作频率/每个存取周期的时钟数）]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-15]]></title>
    <url>%2F2020%2F03%2F15%2F3-15%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]Excel地址 题目描述Excel单元格的地址表示很有趣，它使用字母来表示列号。比如，A表示第1列，B表示第2列，Z表示第26列，AA表示第27列，AB表示第28列，BA表示第53列，….当然Excel的最大列号是有限度的，所以转换起来不难。如果我们想把这种表示法一般化，可以把很大的数字转换为很长的字母序列呢？本题目既是要求对输入的数字, 输出其对应的Excel地址表示方式。 输入输入存在多组测试数据，对于每组测试数据输入一行包含一个整数输入的整数范围[1,2147483647] 输出对于每组测试数据：输出一行表示答案 样例输入262054 样例输出ZBZZ 思路：进制转换 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a;vector&lt;int&gt; vec;int main()&#123; scanf("%lld",&amp;a); stack &lt;int&gt; sta; while(a)&#123; int tmp=a%26; if(tmp==0)&#123; tmp=26; a--; &#125; sta.push(tmp); a/=26; &#125; while(sta.size())&#123; int tmp=sta.top(); sta.pop(); printf("%c",'@'+tmp); &#125; &#125; [蓝桥杯2017初赛]算式900 题目描述小明的作业本上有道思考题：算式： (□□□□-□□□□)□□=900其中的小方块代表0~9的数字，这10个方块刚好包含了0~9中的所有数字。注意：0不能作为某个数字的首位。小明经过几天的努力，终于做出了答案！如下：(5012-4987)36=900用计算机搜索后，发现还有另外一个解，本题的任务就是：请你算出这另外的一个解。 输出输出格式需要与示例严格一致；括号及运算符号不要用中文输入法；整个算式中不能包含空格。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int main()&#123; /* do&#123; if(a[0]==0||a[4]==0||a[8]==0)&#123; continue; &#125; int aa=a[0]*1000+a[1]*100+a[2]*10+a[3]; int bb=a[4]*1000+a[5]*100+a[6]*10+a[7]; int cc=a[8]*10+a[9]; if((aa-bb)*cc==900)&#123; printf("(%d-%d)*%d\n",aa,bb,cc); &#125; &#125;while(next_permutation(a,a+10));*/ cout&lt;&lt; "(6048-5973)*12=900"&lt;&lt;endl;&#125; [蓝桥杯2017初赛]k倍区间 题目描述给定一个长度为N的数列，A1, A2, … AN。如果其中一段连续的子序列Ai, Ai+1, … Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。你能求出数列中总共有多少个K倍区间吗？ 输入第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000) 输出输出一个整数，代表K倍区间的数目。 样例输入5 212345 样例输出6 借鉴：https://blog.csdn.net/w_x_s_h_h/article/details/79375081 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;ll sum=0;ll a[MAX_N];ll ans[MAX_N];int main()&#123; ll n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; &#125; a[1]%=k; for(int i=2;i&lt;=n;i++)&#123; a[i]=(a[i]+a[i-1])%k; &#125; for(int i=1;i&lt;=n;i++)&#123; sum+=(ans[a[i]]++); &#125; printf("%lld\n",sum+ans[0]); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-14]]></title>
    <url>%2F2020%2F03%2F14%2F3-14%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]青蛙跳杯子 题目描述X星球的流行宠物是青蛙，一般有两种颜色：白色和黑色。X星球的居民喜欢把它们放在一排茶杯里，这样可以观察它们跳来跳去。如下图，有一排杯子，左边的一个是空着的，右边的杯子，每个里边有一只青蛙。WWWBBB其中，W字母表示白色青蛙，B表示黑色青蛙，表示空杯子。X星的青蛙很有些癖好，它们只做3个动作之一 跳到相邻的空杯子里。 隔着1只其它的青蛙（随便什么颜色）跳到空杯子里。 隔着2只其它的青蛙（随便什么颜色）跳到空杯子里。对于上图的局面，只要1步，就可跳成该局面：WWW*BBB本题的任务就是已知初始局面，询问至少需要几步，才能跳成另一个目标局面。 输入输入存在多组测试数据，对于每组测试数据：输入为2行，2个串，表示初始局面和目标局面。输入的串的长度不超过15输出对于每组测试数据：输出要求为一个整数，表示至少需要多少步的青蛙跳。样例输入WWBBWWBBWWWBBBBBBWWW 样例输出210 思路：BFS，起始状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e9+5;string st,ed; map&lt;string,int&gt; mp;int dx[6]=&#123;1,-1,2,-2,3,-3&#125;;int main()&#123; while(cin&gt;&gt;st&gt;&gt;ed)&#123; int ans=0; queue&lt;pair&lt;string,int&gt; &gt; que; que.push(make_pair(st,0)); while(que.size())&#123; string tmp=que.front().first; int step=que.front().second; que.pop(); if(mp[tmp]==1)&#123; continue; &#125; mp[tmp]=1; if(tmp==ed)&#123; ans=step; break; &#125; int now; for(int i=0;i&lt;tmp.size();i++)&#123; if(tmp[i]=='*')&#123; now=i; &#125; &#125; for(int i=0;i&lt;6;i++)&#123; int nw=now+dx[i]; if(nw&gt;=0&amp;&amp;nw&lt;tmp.size())&#123; swap(tmp[now],tmp[nw]); if(mp[tmp]==0)&#123; que.push(make_pair(tmp,step+1)); &#125; swap(tmp[now],tmp[nw]); &#125; &#125; &#125; while(que.size())&#123; que.pop(); &#125; mp.clear(); cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; [蓝桥杯2017初赛]9数算式 题目描述观察如下的算式：9213 x 85674 = 789314562左边的乘数和被乘数正好用到了1~9的所有数字，每个1次。而乘积恰好也是用到了1~9的所有数字，并且每个1次。请你借助计算机的强大计算能力，找出满足如上要求的9数算式一共有多少个？注意： 总数目包含题目给出的那个示例。 乘数和被乘数交换后作为同一方案来看待。 输出输出一个整数表示答案 思路：全排列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e9+5;int a[9]=&#123;1,2,3,4,5,6,7,8,9&#125;;int vis[10];bool fun(ll c)&#123; bool flag=1; while(c&gt;0&amp;&amp;c&lt;999999999)&#123; int tmp=c%10; c/=10; vis[tmp]++; &#125; for(int i=1;i&lt;=9;i++)&#123; if(vis[i]!=1)&#123; flag=0; break; &#125; &#125; return flag;&#125;int main()&#123; /*ll ans=0; do&#123; ll aa,bb,cc; for(int i=1;i&lt;5;i++)&#123; aa=0; bb=0; for(int j=0;j&lt;i;j++)&#123; aa*=10; aa+=a[j]; &#125; for(int k=i;k&lt;9;k++)&#123; bb*=10; bb+=a[k]; &#125; cc=aa*bb; memset(vis,0,sizeof(vis)); if(fun(cc))&#123; // cout&lt;&lt;aa&lt;&lt;endl; // cout&lt;&lt;bb&lt;&lt;endl; // cout&lt;&lt;cc&lt;&lt;endl; // cout&lt;&lt;"---------------------------"&lt;&lt;endl; ans++; &#125; &#125; &#125;while(next_permutation(a,a+9));*/ cout&lt;&lt;1625&lt;&lt;endl;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-13]]></title>
    <url>%2F2020%2F03%2F13%2F3-13%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]正则问题 题目描述 考虑一种简单的正则表达式：只由 x ( ) | 组成的正则表达式。小明想求出这个正则表达式能接受的最长字符串的长度。例如 ((xx|xxx)x|(x|xx))xx 能接受的最长字符串是： xxxxxx，长度是6 输入输入一个由x()|组成的正则表达式。输入长度不超过100，保证合法。 输出输出这个正则表达式能接受的最长字符串的长度。 样例输入((xx|xxx)x|(x|xx))xx样例输出6 参考:https://blog.csdn.net/qq_43328587/article/details/104427256 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e9+5;string a;int ans=0;int i=0;int dfs()&#123; int low=0,le=0; for(;i&lt;a.size();)&#123; if(a[i]=='(')&#123; i++; low=low+dfs(); &#125; else if(a[i]=='x')&#123; i++; low++; &#125; else if(a[i]=='|')&#123; i++; le=max(le,low); low=0; &#125; else &#123; i++; break; &#125; &#125; return max(low,le);&#125;int main()&#123; cin&gt;&gt;a; ans=dfs(); cout&lt;&lt;ans&lt;&lt;endl;&#125; [蓝桥杯2017初赛]包子凑数 题目描述小明几乎每天早晨都会在一家包子铺吃早餐。这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子每种蒸笼都有非常多笼，可以认为是无限笼。每当有顾客想买X个包子，卖包子的大叔就会选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。小明想知道一共有多少种数目是包子大叔凑不出来的。 输入第一行包含一个整数N。(1 &lt;= N &lt;= 100)以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100) 输出输出一行包含一个整数代表答案。如果凑不出的数目有无限多个，输出INF。 样例输入245样例输出6 参考：https://blog.csdn.net/qq_44577309/article/details/104376648 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e9+5;int n,a[105],dp[10005];int main()&#123; scanf("%d",&amp;n); dp[0]=1; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int gcd=a[1]; for(int i=1;i&lt;=n;i++)&#123; gcd=__gcd(gcd,a[i]); &#125; if(gcd!=1)&#123; cout&lt;&lt;"INF"&lt;&lt;endl; &#125; else&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j+a[i]&lt;=10000;j++)&#123; if(dp[j])&#123; dp[j+a[i]]=1; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=10000;i++)&#123; if(dp[i]==0)&#123; //cout&lt;&lt;i&lt;&lt;endl; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-12]]></title>
    <url>%2F2020%2F03%2F13%2F3-12%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]跳蚱蜢 题目描述如图所示： 有9只盘子，排成1个圆圈。其中8只盘子内装着8只蚱蜢，有一个是空盘。我们把这些蚱蜢顺时针编号为 1~8。每只蚱蜢都可以跳到相邻的空盘中，也可以再用点力，越过一个相邻的蚱蜢跳到空盘中。请你计算一下，如果要使得蚱蜢们的队形改为按照逆时针排列，并且保持空盘的位置不变（也就是1-8换位，2-7换位,…），至少要经过多少次跳跃？ 输出输出一个整数表示答案 参考：https://www.cnblogs.com/-Ackerman/p/12245137.html 思路：空盘子想象为9起始状态为123456789，最终状态为876543219，每一步可以想象为9跟距离小于等于2的数字交换位置，bfs搜索出从起始状态到最终状态所需的最少步数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e9+5;/*bool vis[MAX_N] ; int dir[4]=&#123;-1,1,2,-2&#125;;int st=123456789,ed=876543219;int a[9];int ans=0;int sum()&#123; int res=0; for(int i=0;i&lt;9;i++)&#123; res*=10; res+=a[i]; &#125; return res;&#125;*/int main()&#123; /*queue&lt;pair&lt;int,int&gt; &gt; que; que.push(make_pair(st,0)); while(que.size())&#123; int x=que.front().first; int step=que.front().second; que.pop(); if(vis[x])&#123; continue; &#125; vis[x]=1; if(x==ed)&#123; ans=step; break; &#125; int j=8,now; while(x)&#123; if(x%10==9) now=j; a[j--]=x%10; x/=10; &#125; for(int i=0;i&lt;4;i++)&#123; swap(a[now],a[(now+dir[i]+9)%9]); int val=sum(); if(vis[val]!=1)&#123; que.push(make_pair(val,step+1)); &#125; swap(a[now],a[(now+dir[i]+9)%9]); &#125; &#125; printf("%d\n",ans);*/ cout&lt;&lt;20&lt;&lt;endl;&#125; [蓝桥杯2017初赛]方格分割 题目描述6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如图就是可行的分割法。试计算：包括这3种分法在内，一共有多少种不同的分割方法。注意：旋转对称的属于同一种分割法。 输出输出一个整数表示答案 从中心对称点(4,4)开始向四周搜索，走到边界答案+1，搜索的时候，vis是对称的，且答案需要去掉旋转和对称的，需要除4 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e9+5;bool vis[10][10];int dx[4]=&#123;1,0,-1,0&#125;;int dy[4]=&#123;0,1,0,-1&#125;;int ans=0;void dfs(int x,int y)&#123; if(x&lt;=1||x&gt;=7||y&lt;=1||y&gt;=7)&#123; ans++; return ; &#125; for(int i=0;i&lt;=4;i++)&#123; int nx=x+dx[i]; int x2=8-nx; int ny=y+dy[i]; int y2=8-ny; if(nx&gt;=1&amp;&amp;nx&lt;=7&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=7&amp;&amp;!vis[nx][ny])&#123; vis[nx][ny]=1; vis[x2][y2]=1; dfs(nx,ny); vis[nx][ny]=0; vis[x2][y2]=0; &#125; &#125; &#125;int main()&#123; vis[4][4]=1; dfs(4,4); vis[4][4]=0; printf("%d\n",ans/4); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-11]]></title>
    <url>%2F2020%2F03%2F12%2F3-11%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]购物单 题目描述小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。你的任务是计算出，小明最少需要取多少现金。 输入本题无输入，购物单如下，物品名称被隐藏了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950**** 180.90 88折**** 10.25 65折**** 56.14 9折**** 104.65 9折**** 100.30 88折**** 297.15 半价**** 26.75 65折**** 130.62 半价**** 240.28 58折**** 270.62 8折**** 115.87 88折**** 247.34 95折**** 73.21 9折**** 101.00 半价**** 79.54 半价**** 278.44 7折**** 199.26 半价**** 12.97 9折**** 166.30 78折**** 125.50 58折**** 84.98 9折**** 113.35 68折**** 166.57 半价**** 42.56 9折**** 81.90 95折**** 131.78 8折**** 255.89 78折**** 109.17 9折**** 146.69 68折**** 139.33 65折**** 141.16 78折**** 154.74 8折**** 59.42 8折**** 85.44 68折**** 293.70 88折**** 261.79 65折**** 11.30 88折**** 268.27 58折**** 128.29 88折**** 251.03 8折**** 208.39 75折**** 128.88 75折**** 62.06 9折**** 225.87 75折**** 12.89 75折**** 34.28 75折**** 62.16 58折**** 129.12 半价**** 218.37 半价**** 289.69 8折 输出输出一个整数表示答案 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;string a,c;double b;double d; double ans=0;double fun(string e)&#123; double res=0; int i=0; for(;i&lt;e.size()-2;i++)&#123; if(isdigit(e[i]))&#123; res*=10; res+=e[i]-'0'; &#125; else if(c.size()==4&amp;&amp;!isdigit(e[0]))&#123; res=50; break; &#125; else &#123; break; &#125; &#125; if(res&gt;0&amp;&amp;res&lt;10) res/=10; else res/=100; return res;&#125;int main ()&#123; /*while(cin&gt;&gt;a)&#123; cin&gt;&gt;b&gt;&gt;c; d=fun(c); ans+=b*d; //cout&lt;&lt;c&lt;&lt;": "&lt;&lt;d&lt;&lt;endl; &#125;*/ cout&lt;&lt;5200&lt;&lt;endl;&#125; [蓝桥杯2017初赛]贪吃蛇长度 题目描述 小明在爷爷的私人收藏馆里找到一台老式电脑。居然没有图形界面，只能用控制台编程。经过小明的一阵摸索，神奇地设计出了控制台上的贪食蛇游戏。如下图，是游戏时画面截图。1234567891011121314151617181920+-------------------------------------------------+| || H###### #### || # # # || # # # || # #### # # || # # # # # || ######@### # # || # #### # # || # # # # # || ####@#######@### # # || # # # # # || T ##### # # # ## || # # ### ### ## || ################ # # #### || # # # # || ############## #######@########## || # ### || ########################### |+-------------------------------------------------+ 其中，H表示蛇头，T表示蛇尾。#表示蛇的身体，@表示身体交叉重叠的地方。你能说出现在的贪吃蛇长度是多少吗？其实，只要数出#的数目算1，数出@的数目，算2，再加上头尾各算1就计算好了人工数一下？太累眼睛了，聪明的你为什么不让计算机帮忙呢？本题的要求就是： 请填写上图中贪食蛇的长度是多少？ 输出输出一个整数表示答案1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;string a;int ans=0;int main()&#123;/* while(cin&gt;&gt;a)&#123; for(int i=0;i&lt;a.size();i++)&#123; if(a[i]=='#'||a[i]=='T'||a[i]=='H')&#123; ans++; &#125; if(a[i]=='@')&#123; ans+=2; &#125; &#125; &#125;*/ printf("%d\n",190);&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3-10]]></title>
    <url>%2F2020%2F03%2F10%2F3-10%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]纸牌三角形 题目描述A,2,3,4,5,6,7,8,9 共9张纸牌排成一个正三角形（A按1计算）。要求每个边的和相等。下图就是一种排法这样的排法可能会有很多。 A 9 6 4 83 7 5 2如果考虑旋转、镜像后相同的算同一种，一共有多少种不同的排法呢？输出输出一个整数表示答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int a[9]=&#123;1,2,3,4,5,6,7,8,9&#125; ;int ans=0;map&lt;int,int&gt; mp;bool fun()&#123; int aa=a[0]+a[1]+a[3]+a[5]; int bb=a[0]+a[2]+a[4]+a[8]; int cc=a[5]+a[6]+a[7]+a[8]; if(aa==bb&amp;&amp;bb==cc) return 1; else return 0;&#125;void check()&#123; int x=a[0]; for(int i=1;i&lt;9;i++)&#123; x*=10; x+=a[i]; &#125; int y=0; int z=0; //旋转 y=a[5]*100000000+a[6]*10000000+a[3]*1000000+a[7]*100000+a[1]*10000+a[8]*1000+a[4]*100+a[2]*10+a[0]; z=a[8]*100000000+a[4]*10000000+a[7]*1000000+a[2]*100000+a[6]*10000+a[0]*1000+a[1]*100+a[3]*10+a[5]; int xx=0; int yy=0; int zz=0; //镜像 xx=a[0]*100000000+a[1]*1000000+a[2]*10000000+a[3]*10000+a[4]*100000+a[5]+a[6]*10+a[7]*100+a[8]*1000; yy=a[5]*100000000+a[6]*1000000+a[3]*10000000+a[7]*10000+a[1]*100000+a[8]+a[4]*10+a[2]*100+a[0]*1000; zz=a[8]*100000000+a[4]*1000000+a[7]*10000000+a[2]*10000+a[6]*100000+a[0]+a[1]*10+a[3]*100+a[5]*1000; if(mp[x]==0&amp;&amp;mp[y]==0&amp;&amp;mp[z]==0&amp;&amp;mp[xx]==0&amp;&amp;mp[yy]==0&amp;&amp;mp[zz]==0)&#123; ans++; mp[x]=1; mp[y]=1; mp[z]=1; mp[xx]=1; mp[yy]=1; mp[zz]=1; &#125;&#125;int main ()&#123;/* do&#123; if(fun())&#123; check(); &#125; &#125;while(next_permutation(a,a+9)); printf("%d\n",ans);*/ cout&lt;&lt;144&lt;&lt;endl;&#125; [蓝桥杯2017初赛]外星日历 题目描述某星系深处发现了文明遗迹。他们的计数也是用十进制。他们的文明也有日历。日历只有天数，没有年、月的概念。有趣的是，他们也使用了类似“星期”的概念，只不过他们的一个星期包含了9天，为了方便，这里分别记为: A,B,C….H,I从一些资料上看到，他们的23日是星期E他们的190日是星期A他们的343251日是星期I令人兴奋的是，他们居然也预见了“世界末日”的那天，当然是一个很大很大的数字651764141421415346185请你计算一下，这遥远的一天是该文明的星期几？输出输出一个大写字母表示答案12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int mod(string a,int b)&#123; int res=0; for(int i=0;i&lt;a.size();i++)&#123; res=(res*10+(a[i]-'0'))%b; &#125; return res;&#125;int main ()&#123; /*string a; int b; cin&gt;&gt;a&gt;&gt;b; int day=(mod(a,b)+8)%9; char c=day+'A'; printf("%c\n",c);*/ cout&lt;&lt;'G'&lt;&lt;endl; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3.9]]></title>
    <url>%2F2020%2F03%2F09%2F3-9%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2017初赛]迷宫 题目描述X星球的一处迷宫游乐场建在某个小山坡上。它是由10x10相互连通的小房间组成的。房间的地板上写着一个很大的字母。我们假设玩家是面朝上坡的方向站立，则：L表示走到左边的房间，R表示走到右边的房间，U表示走到上坡方向的房间，D表示走到下坡方向的房间。X星球的居民有点懒，不愿意费力思考。他们更喜欢玩运气类的游戏。这个游戏也是如此！开始的时候，直升机把100名玩家放入一个个小房间内。玩家一定要按照地上的字母移动。 迷宫地图如下：UDDLUULRULUURLLLRRRURRUURLDLRDRUDDDDUUUUURUDLLRRUUDURLRLDLRLULLURLLRDURDLULLRDDDUUDDUDUDLL ULRDLUURRR请你计算一下，最后，有多少玩家会走出迷宫? 而不是在里边兜圈子。输出输出一个整数表示答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;char mat[15][15];bool vis[15][15];int ans=0;void dfs(int x,int y)&#123; if(x&lt;1||x&gt;10||y&lt;1||y&gt;10)&#123; ans++; return ; &#125; char ch=mat[x][y]; if(ch=='U'&amp;&amp;!vis[x-1][y])&#123; vis[x-1][y]=1; dfs(x-1,y); vis[x-1][y]=0; &#125; if(ch=='D'&amp;&amp;!vis[x+1][y])&#123; vis[x+1][y]=1; dfs(x+1,y); vis[x+1][y]=0; &#125; if(ch=='R'&amp;&amp;!vis[x][y+1])&#123; vis[x][y+1]=1; dfs(x,y+1); vis[x][y+1]=0; &#125; if(ch=='L'&amp;&amp;!vis[x][y-1])&#123; vis[x][y-1]=1; dfs(x,y-1); vis[x][y-1]=0; &#125; &#125;int main ()&#123; /*char s; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=10;j++)&#123; scanf(" %c",&amp;s); mat[i][j]=s; &#125; &#125; for(int i=1;i&lt;=10;i++)&#123; for(int j=1;j&lt;=10;j++)&#123; vis[i][j]=1; dfs(i,j); vis[i][j]=0; &#125; &#125; printf("%d\n",ans);*/ cout&lt;&lt;31&lt;&lt;endl; return 0;&#125; [蓝桥杯2018初赛]分数 题目描述1/1 + 1/2 + 1/4 + 1/8 + 1/16 + ….每项是前一项的一半，如果一共有20项,求这个和是多少，结果用分数表示出来。类似：3/2当然，这只是加了前2项而已。分子分母要求互质。 输出按格式输出答案 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int main ()&#123; ll a=0; for(int i=0;i&lt;=19;i++)&#123; a+=1&lt;&lt;i; &#125; ll b=1&lt;&lt;19; ll c=__gcd(a,b); a/=c; b/=c; cout&lt;&lt;a&lt;&lt;"/"&lt;&lt;b&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一章 微型计算机基础概论]]></title>
    <url>%2F2020%2F03%2F09%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[微型计算机系统 12345678910111213141516171819202122232425262728293031主机系统： CPU 存储器 输入输出接口 总线微处理器(CPU)： 运算器 控制器 寄存器存储器： 内存储器 外存储器： 联机外存： 硬磁盘 脱机外存： 各种移动存储设备总线： 地址总线（AB） 数据总线（DB） 控制总线（CB）软件系统： 系统软件： 操作系统 编译系统 网络系统 工具软件 应用软件 微机工作过程计算机中指令的执行过程 冯诺依曼计算机1234工作原理： 存储程序工作原理结构特点： 运算器为核心 特点： 程序存储，共享数据，顺序执行 属于顺序处理机，适合确定的算法和数值数据的处理 不足： 与存储器间有大量数据交互，对总线要求很高 执行顺序由程序决定，对大型复杂任务较困难 以运算器为核心，处理效率较低 由PC控制执行顺序，难以进行真正的并行处理 哈佛结构 数制及其转换常用计数制： 十进制二进制(B)十六进制（H）八进制（O） 掌握进制转换 计算机中的编码 数值编码： 二进制码 BCD码 西文字符编码 ASCII码 计算机中的数及其运算计算机中的二进制数表示表示方法：1234定点数： 定点整数 定点小数浮点数 数的性质：12无符号数有符号数 原码反码（数0的反码不是唯一的）补码（通过引进补码，可将减法运算转换为加法运算） 基本逻辑运算和逻辑门命题 逻辑运算：与（AND）或(OR)非(NOT) 算术运算是两个数之间的运算，低位运算结果将对高位运算产生影响逻辑运算是按位进行的运算，低位运算结果对高位运算不产生影响 其他逻辑运算及其门电路逻辑关系与非或非异或同或 第一章小结 微处理器、微型计算机、微型计算机系统三者间有什么不同？ 计算机为什么要采用二进制？除二进制外为什么还有其他计数制？ 什么是无符号数？什么是有符号数？ 为什么要引入补码？ 冯诺依曼计算机具有什么结构特点和基本工作原理？ 利用冯诺依曼计算机执行一条指令需要的基本过程？ 什么是逻辑？真值表的含义？ 不同进制之间如何转换？ 原码、反码和补码之间的关系？ 二进制运算 如何判断运算结果是否溢出？ 基本逻辑门电路的符号及输入与输出的关系（逻辑真值表）]]></content>
      <tags>
        <tag>微机原理及应用、计算机接口技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.8]]></title>
    <url>%2F2020%2F03%2F08%2F3-8%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2016初赛]搭积木 题目描述小明最近喜欢搭数字积木，一共有10块积木，每个积木上有一个数字，0~9。搭积木规则：每个积木放到其它两个积木的上面，并且一定比下面的两个积木数字小。最后搭成4层的金字塔形，必须用完所有的积木下面是两种合格的搭法： 0 1 2 3 4 56 7 8 9 0 3 1 7 5 29 8 6 4请你计算这样的搭法一共有多少种？ 输出一个整数表示答案 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;; bool fun()&#123; bool flag=1; if(a[0]&gt;a[1]||a[0]&gt;a[2]) flag=0; if(a[1]&gt;a[3]||a[1]&gt;a[4]) flag=0; if(a[2]&gt;a[4]||a[2]&gt;a[5]) flag=0; if(a[3]&gt;a[6]||a[3]&gt;a[7]) flag=0; if(a[4]&gt;a[7]||a[4]&gt;a[8]) flag=0; if(a[5]&gt;a[8]||a[5]&gt;a[9]) flag=0; return flag;&#125;int main ()&#123; /* int ans=0; do&#123; if(fun())&#123; ans++; &#125; &#125;while(next_permutation(a,a+10));*/ cout&lt;&lt;768&lt;&lt;endl; return 0;&#125; [蓝桥杯2016初赛]有奖猜谜 题目描述小明很喜欢猜谜语。最近，他被邀请参加了X星球的猜谜活动。每位选手开始的时候都被发给777个电子币。规则是：猜对了，手里的电子币数目翻倍，猜错了，扣除555个电子币, 扣完为止。小明一共猜了15条谜语。战果为：vxvxvxvxvxvxvvx其中v表示猜对了，x表示猜错了。请你计算一下，小明最后手里的电子币数目是多少。输出请填写表示最后电子币数目的数字。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;string a="vxvxvxvxvxvxvvx";int main ()&#123; int ans=777; for(int i=0;i&lt;a.size()&amp;&amp;ans;i++)&#123; if(a[i]=='v'&amp;&amp;ans&gt;0) ans*=2; else ans-=555; &#125; if(ans&gt;0) printf("%d\n",ans); else printf("0\n"); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3.7]]></title>
    <url>%2F2020%2F03%2F07%2F3-7%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2016初赛]煤球数目 题目描述有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），….如果一共有100层，共有多少个煤球？ 输出请填表示煤球总数目的数字。 样例输出 12345678#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;int main ()&#123; cout&lt;&lt;171700&lt;&lt;endl; return 0;&#125; [蓝桥杯2016初赛]冰雹数 题目描述任意给定一个正整数N，如果是偶数，执行： N / 2；如果是奇数，执行： N * 3 + 1生成的新的数字再执行同样的动作，循环往复。通过观察发现，这个数字会一会儿上升到很高，一会儿又降落下来。就这样起起落落的，但最终必会落到“1”这有点像小冰雹粒子在冰雹云中翻滚增长的样子。比如N=9：9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1可以看到，N=9的时候，这个“小冰雹”最高冲到了52这个高度。输入输入存在多组测试数据，对于每组测试数据输入一行包含一个正整数N(N&lt;1000000)输出对于每组测试数据，输出一行包含一个正整数表示答案(答案是指从1到N，小冰雹能冲到的最高高度) 样例输入10100 样例输出529232 思路:直接暴力会超时，从1到n会发现偶数会重复操作，去掉重复操作，直接算奇数的即可。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;int n;int main ()&#123; while(scanf("%d",&amp;n)!=EOF)&#123; ll ans=n; for(int i=3;i&lt;=n;i+=2)&#123; ll j=i; while(j&gt;=i)&#123; if(j&amp;1==1) j=j*3+1; else j/=2; ans=max(ans,j); &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; [蓝桥杯2016初赛]平方怪圈 题目描述如果把一个正整数的每一位都平方后再求和，得到一个新的正整数。对新产生的正整数再做同样的处理。如此一来，你会发现，不管开始取的是什么数字，最终如果不是落入1，就是落入同一个循环圈。请写出这个循环圈中最大的那个数字。输出输出答案即可 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e4+5;int n;int fun(int a)&#123; int res=0; while(a)&#123; int temp=a%10; res+=temp*temp; a/=10; &#125; return res;&#125;int main ()&#123; /*scanf("%d",&amp;n); int ans=0; int new_n; for(int i=1;i&lt;=100;i++)&#123; new_n=fun(n); n=new_n; ans=max(ans,n); cout&lt;&lt;n&lt;&lt;endl; &#125; printf("%d\n",ans);*/ printf("145"); return 0;&#125; [蓝桥杯2016初赛]报纸页数 题目描述X星球日报和我们地球的城市早报是一样的，都是一些单独的纸张叠在一起而已。每张纸印有4版。比如，某张报纸包含的4页是：5,6,11,12，可以确定它应该是最上边的第2张报纸。我们在太空中捡到了一张X星球的报纸，4个页码分别是：1125,1126,1727,1728请你计算这份报纸一共多少页（也就是最大页码,并不是用了几张纸哦）？输出输出答案即可 123456789#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e4+5;int main ()&#123; cout&lt;&lt;1124+1728&lt;&lt;endl; return 0;&#125; [蓝桥杯2016初赛]交换瓶子 题目描述有N个瓶子，编号 1 ~ N，放在架子上。比如有5个瓶子：2 1 3 5 4，要求每次拿起2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：1 2 3 4 5对于这么简单的情况，显然，至少需要交换2次就可以复位。如果瓶子更多呢？你可以通过编程来解决。输入输入存在多组测试数据，对于每组测试数据：第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。 输出对于每组测试数据输出一行，包含一个正整数表示答案 样例输入53 1 2 5 455 4 3 2 1 样例输出32 思路：扫一遍数组，将a[i]上的值和本应该在i位置上的数对调即可 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e4+5;int N;int pos[MAX_N];int a[MAX_N]; int ans;int main ()&#123; while(scanf("%d",&amp;N)!=EOF)&#123; ans=0; for(int i=1;i&lt;=N;i++)&#123; scanf("%d",&amp;a[i]); pos[a[i]]=i; &#125; for(int i=1;i&lt;=N;i++)&#123; if(a[i]==i) continue; int id1=a[i]; int pos1=pos[id1]; int pos2=pos[i]; int id2=a[pos2]; ans++; swap(a[i],a[pos2]); swap(pos[id1],pos[i]); &#125; printf("%d\n",ans); &#125; return 0;&#125; [蓝桥杯2016初赛]凑算式 题目描述凑算式：A+ B/C + DEF/GHI =10这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。这个算式一共有多少种解法？输出输出答案即可 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5; //a,b,c,d,e,f,g,h,iint a[9]=&#123;1,2,3,4,5,6,7,8,9&#125;; int ans=0;int main ()&#123; /*do&#123; // A C GHI +B GHI+C DEF=10*C GHI; int A=a[0]*a[2]*(a[6]*100+a[7]*10+a[8]); int B=a[1]*(a[6]*100+a[7]*10+a[8]); int C=a[2]*(a[3]*100+a[4]*10+a[5]); int D=10*(a[6]*100+a[7]*10+a[8])*a[2]; if(A+B+C==D)&#123; ans++; &#125; &#125;while(next_permutation(a,a+9));*/ cout&lt;&lt;29&lt;&lt;endl; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[3.6]]></title>
    <url>%2F2020%2F03%2F06%2F3-6%2F</url>
    <content type="text"><![CDATA[[蓝桥杯2016初赛]密码脱落 题目描述X星球的考古学家发现了一批古代留下来的密码。这些密码是由A、B、C、D 四种植物的种子串成的序列。仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。你的任务是：给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。 输入输入存在多组测试数据，对于每组测试数据输入一行，表示现在看到的密码串（长度不大于1000） 输出对于每组测试数据要求输出一个正整数，表示至少脱落了多少个种子。 样例输入ABCBAABDCDCBABC 样例输出03 题意：给一个字符串，原本是回文串，现在脱落了几个字母，问最少脱落了多少个字母，使得回文串成现在的字符串。 思路：最大公共子序列..字符串a为题目输入的字符串，字符串b为a的reverse。求得a和b的最大公共子序列，然后a.size()减去最大公共子序列的长度即为答案 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;string a,b;int dp[1005][1005];int main ()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); while(cin&gt;&gt;a)&#123; memset(dp,0,sizeof(dp)); b=a; reverse(b.begin(),b.end()); for(int i=0;i&lt;a.size();i++)&#123; for(int j=0;j&lt;b.size();j++)&#123; if(a[i]==b[j])&#123; dp[i+1][j+1]=dp[i][j]+1; &#125; else&#123; dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]); &#125; &#125; &#125; cout&lt;&lt;(a.size()-dp[a.size()][b.size()])&lt;&lt;endl; &#125; return 0;&#125; [蓝桥杯2016初赛]四平方和 题目描述四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。比如：5 = $0^2 + 0^2 + 1^2 + 2^2$7 = $1^2 + 1^2 + 1^2 + 2^2$（^符号表示乘方的意思）对于一个给定的正整数N，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法 输入输入存在多组测试数据，每组测试数据输入一行为一个正整数N (N&lt;5000000) 输出对于每组测试数据，要求输出4个非负整数，按从小到大排序，中间用空格分开 样例输入512773535 样例输出0 0 1 20 2 2 21 1 267 838 暴力…123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5; int N; int a,b,c,d;int temp; void solve(int n)&#123; for( a=0;a&lt;=temp;a++)&#123; for( b=0;b&lt;=temp;b++)&#123; for( c=0;c&lt;=temp;c++)&#123; d=sqrt(n-a*a-b*b-c*c); if(n==a*a+b*b+c*c+d*d)&#123; return ; &#125; &#125; &#125; &#125; &#125;int main ()&#123; while(scanf("%d",&amp;N)!=EOF)&#123; temp=sqrt(N); solve(N); printf("%d %d %d %d\n",a,b,c,d); &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #570 (Div. 3)]]></title>
    <url>%2F2019%2F11%2F27%2FCodeforces-Round-570-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #570 (Div. 3) A. Nearest Interesting Number12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int a;bool check(int x)&#123; int sum=0; while(x)&#123; sum+=x%10; x/=10; &#125; if(sum%4==0) return 1; else return 0;&#125;int main()&#123; scanf("%d",&amp;a); for(int i=a;i&lt;=10000;i++)&#123; if(check(i)) &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; return 0;&#125; B. Equalize Prices123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int q;int n,k;int a[200];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; sort(a+1,a+1+n); int max_min=a[1]+k; int min_max=a[n]-k; if(max_min&lt;min_max)&#123; puts("-1"); continue; &#125; else&#123; printf("%d\n",max_min); &#125; &#125; return 0;&#125; C. Computer Game12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int q;int k,n,a,b;int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d%d%d",&amp;k,&amp;n,&amp;a,&amp;b); int max_n=k/b; if(max_n&lt;n)&#123; puts("-1"); continue; &#125; if(max_n==n&amp;&amp;b*max_n&gt;=k)&#123; puts("-1"); continue; &#125; if(max_n&gt;=n)&#123; int cnt=0; cnt=k-1-b*n; int ans=0; ans=cnt/(a-b); if(ans&gt;=n)&#123; printf("%d\n",n); &#125; else&#123; printf("%d\n",ans); &#125; &#125; &#125; return 0;&#125; D. Candy Box (easy version)12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int q;int n;int a[MAX_N];bool cmp(int x,int y)&#123; return x&gt;y;&#125;int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) a[i]=0; int temp; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;temp); a[temp]++; &#125; int ans=0; sort(a+1,a+1+n,cmp); int cnt=a[1]; ans+=cnt; for(int i=2;i&lt;=n&amp;&amp;cnt;i++)&#123; if(a[i]&gt;=cnt)&#123; cnt--; ans+=cnt; &#125; else &#123; cnt=a[i]; ans+=a[i]; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; E. Subsequences (easy version)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const int INF=0x3f3f3f3f;int ans=0;queue&lt;pair&lt;string,int&gt; &gt; que;map&lt;string,bool&gt; mp; int n,k; string s;int dis;void bfs()&#123; while(que.size())&#123; string temp=que.front().first; int temp_ans=que.front().second; que.pop(); if(dis==k)&#123; ans+=temp_ans; break; &#125; for(int i=0;i&lt;temp.size();i++)&#123; string temp3=temp; temp3.erase(temp3.begin()+i,temp3.begin()+i+1); string temp2=temp3; if(mp.count(temp2))&#123;continue;&#125; else&#123; mp[temp2]=1; dis++; ans+=n-temp2.size(); if(dis==k)&#123; return ; &#125; que.push(make_pair(temp2,ans)); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; cin&gt;&gt;s; que.push(make_pair(s,ans)); dis=1; bfs(); if(dis&lt;k)&#123; cout&lt;&lt;"-1"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; F. Topforces Strikes Back参考：blog1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int num[MAX_N],cnt,fa[MAX_N],ans;set&lt;int&gt; se; int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; int n,ans=0; cnt=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int x; scanf("%d",&amp;x); se.insert(x); &#125; for(auto i:se)&#123; num[++cnt]=i; //排序 从小到大 &#125; se.clear(); for(int i=cnt;i&gt;=1;i--)&#123; ans=max(ans,num[i]); //找第一个最大的 for(int j=cnt;j&gt;i;j--)&#123; if(num[j]%num[i]!=0)&#123; //找第二个最大的且符合条件的 ans=max(ans,num[i]+num[j]); for(int k=j-1;k&gt;i;k--)&#123; if(num[j]%num[k]!=0&amp;&amp;num[k]%num[i]!=0)&#123; //找第三个最大的且符合条件的 ans=max(ans,num[i]+num[j]+num[k]); //更新答案 break; &#125; &#125; break; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; G. Candy Box (hard version)参考：blog123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int q;int n;int cnt0[MAX_N],cnt1[MAX_N],sa[MAX_N];priority_queue&lt;int&gt; que;bool cmp(int a,int b)&#123; return cnt0[a]+cnt1[a]&gt;cnt0[b]+cnt1[b];&#125; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); if(y) cnt1[x]++; //标记1 else cnt0[x]++; //标记0 sa[i]=i; &#125; while(que.size())que.pop(); sort(sa+1,sa+n+1,cmp); //排序 int now=1,ans=0,num=0; for(int i=n;i&gt;=1;i--)&#123; //从大到小贪心 while(cnt0[sa[now]]+cnt1[sa[now]]&gt;=i)&#123; que.push(cnt1[sa[now]]); //插入标记1的数量 now++; &#125; if(que.empty()) continue; int v=que.top(); que.pop(); ans+=i; //该种类的数量 num+=min(v,i); &#125; printf("%d %d\n",ans,num); for(int i=1;i&lt;=n;i++) cnt0[i]=cnt1[i]=0; &#125; return 0;&#125; H. Subsequences (hard version)参考：blog123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;ll dp[105][105];int pre[30];char s[MAX_N];ll n,k; int main()&#123; scanf("%lld%lld",&amp;n,&amp;k); scanf("%s",s+1); dp[0][0]=1; for(int i=1;i&lt;=n;i++)&#123; dp[i][0]=1; for(int j=1;j&lt;=i;j++)&#123; dp[i][j]=dp[i-1][j-1]+dp[i-1][j]; if(pre[s[i]-'a']) dp[i][j]-=dp[pre[s[i]-'a']-1][j-1]; dp[i][j]=min(dp[i][j],k); &#125; pre[s[i]-'a']=i; &#125; ll ans=0; for(int i=n;i&gt;=0;i--)&#123; ans+=min(dp[n][i],k)*(n-i); k-=dp[n][i]; if(k&lt;=0) break; &#125; if(k&gt;0) puts("-1"); else printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #590 (Div. 3)]]></title>
    <url>%2F2019%2F11%2F26%2FCodeforces-Round-590-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #590 (Div. 3) A. Equalize Prices Again1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int q;int n;int a[105]; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;n); int sum=0; int ans=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum+=a[i]; &#125; if(sum%n==0) ans=sum/n; else ans=sum/n+1; printf("%d\n",ans); &#125; return 0; B1. Social Network (easy version) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int n,k;map&lt;int ,int &gt; mp;int ans[MAX_N];int main()&#123; scanf("%d%d",&amp;n,&amp;k); int id; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;id); if(mp[id]==0)&#123; mp[id]=1; ans[cnt]=id; if(cnt&gt;=k)&#123; mp[ans[cnt-k]]=0; &#125; cnt++; &#125; &#125; if(cnt&lt;=k)&#123; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; printf("%d%c",ans[i],i==0 ? '\n':' '); &#125; &#125; else&#123; printf("%d\n",k); for(int i=cnt-1;i&gt;=cnt-k;i--)&#123; printf("%d%c",ans[i],i==cnt-k ? '\n':' '); &#125; &#125; return 0;&#125; B2. Social Network (hard version) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int n,k;map&lt;int ,int &gt; mp;int ans[MAX_N];int main()&#123; scanf("%d%d",&amp;n,&amp;k); int id; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;id); if(mp[id]==0)&#123; mp[id]=1; ans[cnt]=id; if(cnt&gt;=k)&#123; mp[ans[cnt-k]]=0; &#125; cnt++; &#125; &#125; if(cnt&lt;=k)&#123; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; printf("%d%c",ans[i],i==0 ? '\n':' '); &#125; &#125; else&#123; printf("%d\n",k); for(int i=cnt-1;i&gt;=cnt-k;i--)&#123; printf("%d%c",ans[i],i==cnt-k ? '\n':' '); &#125; &#125; return 0;&#125; C. Pipes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int q;int n;int a[2][MAX_N];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; bool flag=0; scanf("%d",&amp;n); int temp; for(int i=0;i&lt;2;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf("%1d",&amp;temp); if(temp==1||temp==2) a[i][j]=1; else a[i][j]=3; &#125; &#125; int pos=0; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; if(a[pos][i]==1)&#123; cnt++; &#125; else if(a[pos][i]==3&amp;&amp;a[pos^1][i]==3)&#123; cnt++; pos=pos^1; &#125; &#125; if(cnt==n&amp;&amp;pos==1) flag=1; if(flag) puts("YES"); else puts("NO"); &#125; return 0;&#125; D. Distinct Characters Queries1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;const long N = 200000; int q;int n;string s;int tree[MAX_N][30];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int k,int cnt)&#123; while(x&lt;=n)&#123; tree[x][cnt]+=k; x+=lowbit(x); &#125;&#125;int sum(int x,int cnt)&#123; int res=0; while(x&gt;0)&#123; res+=tree[x][cnt]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; string s; cin&gt;&gt;s; n=s.size(); for(int i=0;i&lt;n;i++)&#123; add(i+1,1,s[i]-'a'); &#125; int q; scanf("%d",&amp;q); while(q--)&#123; int op; scanf("%d",&amp;op); if(op==1)&#123; int pos; char c; scanf("%d",&amp;pos); scanf(" %c",&amp;c); add(pos,-1,s[pos-1]-'a'); s[pos-1]=c; add(pos,1,c-'a'); &#125; else&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int ans=0; for(int i=0;i&lt;26;i++)&#123; if((sum(r,i)-sum(l-1,i))&gt;0)&#123; ans++; &#125; &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125; E. Special Permutations 参考：blog 12345678910111213141516171819202122232425262728293031323334353637//差分数组#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int n,m;ll a[MAX_N];ll ans[MAX_N];void up(ll l,ll r,ll v)&#123; ans[l]+=v; ans[r+1]-=v;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;m;i++)&#123; ll l=a[i],r=a[i+1]; if(l&gt;r) swap(l,r); if(l!=r)&#123; up(1,l-1,r-l); up(l,l,r-1); up(l+1,r-1,r-l-1); up(r,r,l); up(r+1,n,r-l); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i!=n)printf("%lld ",ans[i]+=ans[i-1]); else printf("%lld\n",ans[i]+=ans[i-1]); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//暴力#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int n,m;int a[MAX_N],p[MAX_N];ll ans;vector&lt;int&gt; pos[MAX_N]; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); pos[a[i]].push_back(i); &#125; for(int i=1;i&lt;=m-1;i++)&#123; ans+=abs(a[i]-a[i+1]); &#125; printf("%lld ",ans); for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;pos[i].size();j++)&#123; int k=pos[i][j]; if(k&gt;1) ans-=abs(i-p[a[k-1]]); if(k&lt;m) ans-=abs(i-p[a[k+1]]); &#125; for(int j=0;j&lt;pos[i-1].size();j++)&#123; int k=pos[i-1][j]; if(k&gt;1&amp;&amp;a[k-1]!=i) ans-=abs(1-p[a[k-1]]); if(k&lt;m&amp;&amp;a[k+1]!=i) ans-=abs(1-p[a[k+1]]); &#125; p[i]=1; p[i-1]=i; for(int j=0;j&lt;pos[i].size();j++)&#123; int k=pos[i][j]; if(k&gt;1) ans+=abs(1-p[a[k-1]]); if(k&lt;m) ans+=abs(1-p[a[k+1]]); &#125; for(int j=0;j&lt;pos[i-1].size();j++)&#123; int k=pos[i-1][j]; if(k&gt;1&amp;&amp;a[k-1]!=i) ans+=abs(i-p[a[k-1]]); if(k&lt;m&amp;&amp;a[k+1]!=i) ans+=abs(i-p[a[k+1]]); &#125; if(i==n) printf("%lld",ans); else printf("%lld ",ans); &#125; return 0;&#125; F. Yet Another Substring Reverse参考：blog12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const int INF=0x3f3f3f3f;char s[MAX_N];int dp[1&lt;&lt;(20)]; bool vis[20];int main()&#123; scanf("%s",s); int n=strlen(s); for(int i=0;i&lt;n;i++)&#123; //枚举该字符串的所有集合 memset(vis,0,sizeof(vis)); int mask=0,cnt=0; for(int j=i;j&lt;n;j++)&#123; int v=s[j]-'a'; if(vis[v]) break; else vis[v]=1; mask |=(1&lt;&lt;v); cnt++; dp[mask]=cnt; &#125; &#125; for(int i=0;i&lt;(1&lt;&lt;20);i++)&#123; //计算一个集合所有子集的最大值 for(int j=0;j&lt;20;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; dp[i]=max(dp[i],dp[i^(1&lt;&lt;j)]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt; (1&lt;&lt;20);i++)&#123; //求最优解 ans=max(ans,dp[i]+dp[i^((1&lt;&lt;20)-1)]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #598 (Div. 3)]]></title>
    <url>%2F2019%2F11%2F24%2FCodeforces-Round-598-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #598 (Div. 3) A. Payment Without Change123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;int q;ll a,n,b,s; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;n,&amp;s); bool flag=1; if(a*n+b&lt;s) &#123; flag=0; &#125; else&#123; if(s%n&gt;b)&#123; flag=0; &#125; &#125; if(flag) puts("YES"); else puts("NO"); &#125; return 0;&#125; B. Minimize the Permutation1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;const long N = 200000; int q;int n; int a[105];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int pos=0; int last=0; while(last&lt;n)&#123; int min=1000000; for(int i=pos+1;i&lt;=n;i++)&#123; if(min&gt;a[i])&#123; min=a[i]; pos=i; &#125; &#125; for(int i=pos;i&gt;last;i--)&#123; if(a[i-1]&gt;a[i])&#123; swap(a[i-1],a[i]); &#125; &#125; last=pos; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",a[i],i==n ? '\n':' '); &#125; &#125; return 0;&#125; C. Platforms Jumping 参考：blog 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const long N = 200000; int n,m,d;int c[1005];int ans[1005];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;d); int max_len=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;c[i]); max_len+=c[i]; &#125; if((max_len+d*(m+1)-m)&lt;n+1)&#123; puts("NO"); return 0; &#125; puts("YES"); int pos=0; for(int i=1;i&lt;=m;i++)&#123; if(pos+d+max_len&lt;=n) pos+=d; else pos=n+1-max_len; for(int j=pos;j&lt;=pos+c[i]-1;j++)&#123; ans[j]=i; &#125; pos+=c[i]-1; max_len-=c[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i], i==n ? '\n':' '); &#125; return 0;&#125; D. Binary String Minimizing12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const long N = 200000; int q;ll n,k;int a[MAX_N];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%lld%lld",&amp;n,&amp;k); char c; int len=0; for(int i=1;i&lt;=n;i++)&#123; scanf(" %c",&amp;c); if(c=='0')&#123; a[++len]=i; &#125; &#125; for(int i=1;i&lt;=len&amp;&amp;k;i++)&#123; if(k&gt;=(a[i]-i))&#123; k=k-(a[i]-i); a[i]=i; &#125; else&#123; a[i]=a[i]-k; k=0; break; &#125; &#125; int cnt=1; for(int i=1;i&lt;=n;i++)&#123; if(i==a[cnt]&amp;&amp;cnt&lt;=len) &#123; printf("0"); cnt++; &#125; else printf("1"); &#125; printf("\n"); &#125; return 0;&#125; E. Yet Another Division Into Teams 参考:blog123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;pair&lt;int,int &gt; a[MAX_N];int dp[MAX_N],p[MAX_N];int ans[MAX_N];int root,cnt;int n;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].first); a[i].second=i; &#125; sort(a+1,a+1+n); memset(dp,INF,sizeof(dp)); dp[1]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=2;j&lt;=4&amp;&amp;i+j&lt;=n;j++)&#123; int temp=a[i+j].first-a[i].first; if(dp[i+j+1]&gt;dp[i]+temp)&#123; dp[i+j+1]=dp[i]+temp; p[i+j+1]=i; &#125; &#125; &#125; root=n+1; cnt=1; while(root!=1)&#123; for(int i=root-1;i&gt;=p[root];i--)&#123; ans[a[i].second]=cnt; &#125; cnt++; root=p[root]; &#125; printf("%d %d\n",dp[n+1],cnt-1); for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i],i==n ? '\n' :' '); &#125; return 0;&#125; F. Equalizing Two Strings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int q;int n;char s[MAX_N];int s_vis[30]; char t[MAX_N];int t_vis[30]; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; memset(s_vis,0,sizeof(s_vis)); memset(t_vis,0,sizeof(t_vis)); scanf("%d",&amp;n); scanf("%s",s); scanf("%s",t); bool flag=0; for(int i=0;i&lt;n;i++)&#123; s_vis[s[i]-'a']++; t_vis[t[i]-'a']++; &#125; bool flag1=0; for(int i=0;i&lt;26;i++)&#123; if(s_vis[i]!=t_vis[i]) &#123; flag1=1; break; &#125; &#125; if(flag1) &#123; puts("NO"); continue; &#125; for(int i=0;i&lt;26;i++)&#123; if(s_vis[i]&gt;=2||t_vis[i]&gt;=2)&#123; flag=1; break; &#125; &#125; if(flag)&#123; puts("YES"); continue; &#125; else&#123; int num1=0; int num2=0; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(s[i]&gt;s[j])&#123; num1++; &#125; if(t[i]&gt;t[j])&#123; num2++; &#125; &#125; &#125; if((num1&amp;1)==(num2&amp;1))puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F10%2F28%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Trie+Kmp=AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;struct Trie&#123; int fail; int vis[30]; int tail;&#125;tree[MAX_N];int cnt=0;inline void Build(string s) //用所有子串建立字典树&#123; int l=s.length(); int now=0; for(int i=0;i&lt;l;i++) &#123; if(tree[now].vis[s[i]-'a']==0)&#123; tree[now].vis[s[i]-'a']=++cnt; &#125; now=tree[now].vis[s[i]-'a']; &#125; tree[now].tail+=1;&#125;void Get_fail()&#123; //用BFS求失配指针 queue&lt;int&gt; que; for(int i=0;i&lt;26;i++)&#123; if(tree[0].vis[i]!=0)&#123; tree[tree[0].vis[i]].fail=0; que.push(tree[0].vis[i]); &#125; &#125; while(que.size())&#123; int u=que.front(); que.pop(); for(int i=0;i&lt;26;i++)&#123; if(tree[u].vis[i]!=0)&#123; tree[tree[u].vis[i]].fail=tree[tree[u].fail].vis[i]; que.push(tree[u].vis[i]); &#125; else&#123; tree[u].vis[i]=tree[tree[u].fail].vis[i]; &#125; &#125; &#125;&#125;int query(string s)&#123; //查询 int l=s.length(); int now=0,ans=0; for(int i=0;i&lt;l;i++)&#123; now=tree[now].vis[s[i]-'a']; for(int t=now;t&amp;&amp;tree[t].tail!=-1;t=tree[t].fail)&#123; ans+=tree[t].tail; tree[t].tail=-1; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int n; string s; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s; Build(s); &#125; tree[0].fail=0; Get_fail(); cin&gt;&gt;s; cout&lt;&lt;query(s)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆元]]></title>
    <url>%2F2019%2F10%2F24%2F%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[逆元素是指一个可以取消另一给定元素运算的元素，在数学里，逆元素广义化了加法中的加法逆元和乘法中的倒数传送门 若$a*x \equiv1 \pmod {b}$，且a与b互质，那么我们就能定义: x 为 a 的逆元，记为$a^{-1}$ 有三种方法可以求逆元： 扩展GCD1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;int a,p;void Exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) x = 1, y = 0; else Exgcd(b, a % b, y, x), y -= a / b * x;&#125;int main()&#123; ll x, y; scanf("%d%d",&amp;a,&amp;p); Exgcd (a, p, x, y); x = (x % p + p) % p; printf ("%d\n", x); //x是a在mod p下的逆元 return 0;&#125; 费马小定理12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p,n;ll mod_pow(ll x,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;p); for(int i=1;i&lt;=n;i++) &#123; if(i==1) printf("1\n"); else printf("%d\n",mod_pow(i,p-2,p)); &#125; return 0;&#125; 线性递推123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=3e6+5;ll p;ll n;int a[MAX_N];int main()&#123; scanf("%lld%lld",&amp;n,&amp;p); a[1]=1; for(int i=1;i&lt;=n;i++) &#123; if(i!=1)a[i]=(p-p/i)*a[p%i]%p; printf("%d\n",a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas定理]]></title>
    <url>%2F2019%2F10%2F24%2FLucas%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Lucas定理一句话说就是Lucas(m,n,p) = C$\tbinom{m/p}{n/p}$ * Lucas(m%p,n%p,p) 传送门 就是一道Lucas模板题 $C^m_n$ =${n!1/m!1/(n-m)!}$,而$1/m!$的逆元就是$m!$. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p;ll a[100000+5];int T;ll mod_pow(ll x,ll n,ll mod)&#123; //快速幂 ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;ll C(ll n,ll m)&#123; //逆元求组合数 if(m&gt;n) return 0; return (a[n]*mod_pow(a[m],p-2,p))%p*mod_pow(a[n-m],p-2,p)%p;&#125;ll Lucas(ll n,ll m) //Lucas定理&#123; if(!m) return 1; else return C(n%p,m%p)*Lucas(n/p,m/p)%p;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; ll n,m; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;p); a[0]=1; for(int i=1;i&lt;=p;i++) a[i]=(a[i-1]*i)%p; //求i的阶乘. printf("%lld\n",Lucas(n+m,m)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[践踏]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%B7%B5%E8%B8%8F%2F</url>
    <content type="text"><![CDATA[题意：1操作 加一条线段2操作 删一条线段3查询 有多少条线段满足x+kt（t是整数）传送门 考虑在模k意义下，每条线段都是1到2个区间，如果这条线段的长度大于k的话，那么区间[0，k-1]就满足题意。树状数组维护区间和，单点查询即可。当k=0的时候，则判断有多少个线段经过某个点，离散化，树状数组维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+5;const int MOD=1e9+7;typedef long long ll;int tree[MAXN],up;vector&lt;int&gt; vec;pair&lt;pair&lt;int,int&gt;,int&gt; a[MAXN];int T;void add(int x,int a)&#123; while(x&lt;=up) tree[x]+=a,x+=x&amp;(-x);&#125;int sum(int x)&#123; int res=0; while(x) res+=tree[x],x-=x&amp;(-x); return res;&#125;int main()&#123; int n,k,op,l,r; scanf("%d%d",&amp;n,&amp;k); if(n==0) &#123; printf("fafa\n"); return 0; &#125; if(k) &#123; up=k; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;op); if(op==1) &#123; scanf("%d%d",&amp;l,&amp;r); if(r-l+1&gt;=k) &#123; add(1,1); //[1,k-1] add(k+1,-1); continue; &#125; l=(l%k)+1; r=(r%k)+1; if(l&lt;=r) &#123;add(l,1); add(r+1,-1);&#125; //一条线段[l,r] else &#123; add(1,1); //两条线段[1,r]和[l,k+1] add(r+1,-1); add(l,1); add(k+1,-1); &#125; &#125; else if(op==2) //删除线段则是添加的逆操作 &#123; scanf("%d%d",&amp;l,&amp;r); if(r-l+1&gt;=k) &#123; add(1,-1); add(k+1,1); continue; &#125; l=(l%k)+1; r=(r%k)+1; if(l&lt;=r)&#123; add(l,-1); add(r+1,1); &#125; else &#123; add(1,-1); add(r+1,1); add(l,-1); add(k+1,1); &#125; &#125; else &#123; scanf("%d",&amp;l); printf("%d\n",sum(l%k+1)); &#125; &#125; &#125; else&#123; up=2*n; for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;a[i].second,&amp;a[i].first.first); vec.push_back(a[i].first.first); if(a[i].second&lt;=2) &#123; scanf("%d",&amp;a[i].first.second); vec.push_back(a[i].first.second); &#125; &#125; sort(vec.begin(),vec.end()); vec.erase(unique(vec.begin(),vec.end()),vec.end()); //离散化 for(int i=1;i&lt;=n;i++) &#123; if(a[i].second==1) //离散化后，二分查询所需l,r &#123; l=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+1; r=lower_bound(vec.begin(),vec.end(),a[i].first.second)-vec.begin()+1; add(l,1); add(r+1,-1); &#125; else if(a[i].second==2) &#123; l=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+1; r=lower_bound(vec.begin(),vec.end(),a[i].first.second)-vec.begin()+1; add(l,-1); add(r+1,1); &#125; else&#123; int x=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+1; printf("%d\n",sum(x)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VVQ与线段]]></title>
    <url>%2F2019%2F10%2F15%2FVVQ%E4%B8%8E%E7%BA%BF%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[题意：求任意两条线段的异或最大值。定义线段的异或值为它们并的长度减他们交的长度 传送门题解：有两种情况1：线段a内部包含线段b 贡献：(a.r-a.l)-(b.r-b.l);2.线段a与线段b相交 贡献：(a.r+b.l-b.l-b.r);先根据l进行排序，然后计算贡献即可. 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn= 200005;const int INF=0x3fffffff;int Max[maxn&lt;&lt;2],Min[maxn&lt;&lt;2];struct node&#123; int l,r; friend bool operator &lt;(const node &amp;a,const node &amp;b) &#123; return a.l&lt;b.l; &#125; &#125;a[maxn];bool cmp(node a,node b)&#123; return a.l&lt;b.l;&#125; void build(int p,int l,int r)&#123; if(l==r) &#123; Max[p]=a[l].l+a[l].r; Min[p]=a[l].r-a[l].l; return ; &#125; int mid=(l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r); Max[p]=max(Max[p*2],Max[p*2+1]); Min[p]=min(Min[p*2],Min[p*2+1]); &#125;int Quary_Max(int l,int r,int p,int x,int y)&#123; if(l&gt;y||r&lt;x)return 0; if(l&gt;=x&amp;&amp;r&lt;=y)return Max[p]; int mid=(l+r)&gt;&gt;1; return max(Quary_Max(l,mid,p*2,x,y),Quary_Max(mid+1,r,p*2+1,x,y));&#125; int Quary_Min(int l,int r,int root,int x,int y)&#123; if(l&gt;y||r&lt;x)return INF; if(l&gt;=x&amp;&amp;r&lt;=y)return Min[root]; int mid=(l+r)&gt;&gt;1; return min(Quary_Min(l,mid,root*2,x,y),Quary_Min(mid+1,r,root*2+1,x,y));&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;a[i].l,&amp;a[i].r); sort(a+1,a+1+n,cmp); build(1,1,n); int ans=0; node tmp; tmp.r=0; int l,r; for(int i=1;i&lt;=n;i++) &#123; tmp.l=a[i].l; l=lower_bound(a+1,a+1+n,tmp)-a; //找到a[j].l&gt;=a[i].l的第一个j tmp.l=a[i].r; r=upper_bound(a+1,a+1+n,tmp)-a-1; //找到a[j].l&lt;=a[i].r的最后一个j if(l&gt;r)continue; //这样就找到左端点在线段i范围内的所有线段 ans=max(ans,Quary_Max(1,n,1,l,r)-a[i].r-a[i].l); ans=max(ans,a[i].r-a[i].l-Quary_Min(1,n,1,l,r)); &#125; printf("%d\n",ans); return 0;&#125;/*31 104 115 683 10 100 1 50 50 10099*/]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计颜色]]></title>
    <url>%2F2019%2F10%2F15%2F%E7%BB%9F%E8%AE%A1%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题意：n个桶按顺序排列，我们用1~n给桶标号。有两种操作：1 l r c 区间[l,r]中的每个桶中都放入一个颜色为c的球 (1≤l,r ≤n,l≤r,0≤c≤60)2 l r 查询区间[l,r]的桶中有多少种不同颜色的球 (1≤l,r ≤n,l≤r) 用long long的不同位来表示不同颜色。区间合并用’|’(或)即可，update区间时就用 1&lt;&lt;c 的值来update. 传送门1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;ll tree[MAX_N&lt;&lt;2];ll tag[MAX_N&lt;&lt;2];ll N,M;ll lc(ll x) &#123;return x&lt;&lt;1;&#125;ll rc(ll x) &#123;return x&lt;&lt;1|1;&#125;int getans(ll x)&#123; int ans=0; while(x) &#123; ans+=x&amp;1; x&gt;&gt;=1; &#125; return ans;&#125;void push_up(ll p)&#123; tree[p]=tree[lc(p)]|tree[rc(p)];&#125;void fun(ll p,ll l,ll r,ll k)&#123; tag[p]=tag[p]|k; tree[p]=tree[p]|k;&#125;void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; fun(lc(p),l,mid,tag[p]); fun(rc(p),mid+1,r,tag[p]); tag[p]=0;&#125;ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) return tree[p]; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)res=res|query(nl,nr,lc(p),l,mid); if(nr&gt;mid) res=res|query(nl,nr,rc(p),mid+1,r); return res;&#125;void update(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tag[p]=tag[p]|k; tree[p]=tree[p]|k; return; &#125; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k); if(nr&gt;mid)update(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;int main() &#123; while(scanf("%lld%lld",&amp;N,&amp;M)!=EOF) &#123; memset(tree,0,sizeof(tree)); memset(tag,0,sizeof(tag)); while(M--) &#123; ll b; scanf("%lld",&amp;b); if(b==1) &#123; ll x,y,z; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); ll temp=pow(2,z); update(x,y,1,1,N,temp); &#125; else &#123; ll x,y; scanf("%lld%lld",&amp;x,&amp;y); printf("%d\n",getans(query(x,y,1,1,N))); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sum]]></title>
    <url>%2F2019%2F10%2F15%2FSum%2F</url>
    <content type="text"><![CDATA[题意：考虑维护一个这样的问题：（1） 给出一个数组A，标号为1~n（2） 修改数组中的一个位置。（3） 询问区间[l,r]中所有子集的位运算and之和mod($10^9$+7)。传送门题解：按位建立线段树,每一颗线段树维护每一位从1到n的区间和。第p位的值为a,则贡献为：$2^p$*($2^a$-1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;const int MAX_N=1e5+5;int a[MAX_N];int tree[MAX_N&lt;&lt;2][32];int cnt[32];ll mod_pow(ll x,ll n)&#123; ll res=1; while(n) &#123; if(n&amp;1) res=res*x%MOD; x=x*x%MOD; n&gt;&gt;=1; &#125; return res%MOD;&#125;int lc(int x)&#123;return x&lt;&lt;1;&#125;int rc(int x)&#123;return x&lt;&lt;1|1;&#125;void push_up(int p,int t)&#123; tree[p][t]=(tree[lc(p)][t]+tree[rc(p)][t])%MOD;&#125;void build(int p,int l,int r)&#123; if(l==r) &#123; for(int i=0;i&lt;32;i++) &#123; tree[p][i]=(a[l]&gt;&gt;i)&amp;1; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); build(rc(p),mid+1,r); for(int i=0;i&lt;32;i++) push_up(p,i);&#125;void query(int nl,int nr,int p,int l ,int r)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; for(int i=0;i&lt;32;i++) &#123; cnt[i]=(cnt[i]+tree[p][i])%MOD; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) query(nl,nr,lc(p),l,mid); if(mid&lt;nr) query(nl,nr,rc(p),mid+1,r);&#125;void update(int nl,int nr,int p,int l ,int r,int k )&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; a[l]=k; for(int i=0;i&lt;32;i++) &#123; tree[p][i]=(a[l]&gt;&gt;i)&amp;1; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) update(nl,nr,lc(p),l,mid,k); if(mid&lt;nr) update(nl,nr,rc(p),mid+1,r,k); for(int i=0;i&lt;32;i++) push_up(p,i);&#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); build(1,1,n); int m; scanf("%d",&amp;m); while(m--) &#123; int b; scanf("%d",&amp;b); if(b==1)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); update(x,x,1,1,n,y); &#125; else&#123; memset(cnt,0,sizeof(cnt)); int l,r; scanf("%d%d",&amp;l,&amp;r); query(l,r,1,1,n); ll ans=0; for(int i=0;i&lt;32;i++) &#123; ans=(ans+(((mod_pow(2,cnt[i])-1)%MOD)*(mod_pow(2,i)%MOD))%MOD)%MOD; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JLOI2011不等式组]]></title>
    <url>%2F2019%2F10%2F15%2FJLOI2011-%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题意：1操作插入不等式，2操作删除第i条不等式，3操作查询当x=k时，求满足条件的不等式数量.传送门 题解：按a的正负划分情况。1.a&gt;0, x&gt;向上取整的(c-b)/a,并且x满足${[-10^6 , 10^6]}$2.a=0,若b&gt;c则恒成立3.a]]></content>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树模板线段树是处理符合结合律的高效数据结构；线段树专门处理区间问题的；线段树的每个节点都表示一个区间，当l==r的时候，意味着区间长度为1，也就是表元素；线段是是一颗完全二叉树，即每个节点要么是叶子节点要么就有两个孩子节点。线段树模板题 递归建树：12345678910111213141516171819202122ll lc(ll x) &#123;return x&lt;&lt;1;&#125; //左孩子ll rc(ll x) &#123;return x&lt;&lt;1|1;&#125; //右孩子void push_up(ll p)&#123; tree[p]=tree[lc(p)]+tree[rc(p)]; //这是维护区间和的线段树，维护区间最大最小值的类似； //tree[p]=min(tree[lc(p)],tree[rc(p)]); //维护区间最小值&#125;void build(ll p,ll l,ll r) &#123; tag[p]=0; //tag标记，先不管，下面讲 if(l==r)&#123; tree[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); //递归左子树 build(rc(p),mid+1,r); //递归右子树 push_up(p); //回溯时，维护父节点&#125; 区间修改单点修改是区间修改的子问题，也就是修改区间长度为1的区间。放在一起谈。对于区间修改，我们需要引用一个tag标记；原因：当修改区间的一个元素时，它就需要push_up来更新它的父节点，时间复杂度O(nlogn)，这很低效，当我们引入tag标记时，则可以使区间更新接近O(logn); tag标记当某个区间被修改时，就给这个区间打上标记,当用到这个区间的子区间的时候，我们才从父节点往子节点下传更新值.来看一下代码:123456789101112131415161718192021222324252627void fun(ll p,ll l,ll r,ll k) // p表示该节点，[l,r]表示该节点表示的区间，k表示增量&#123; tag[p]=tag[p]+k; //记录增量 tree[p]=tree[p]+(r-l+1)*k; //更新当前节点的值，因为符合结合律，所以直接可以计算得&#125;void push_down(ll p,ll l,ll r) //下传tag标记&#123; ll mid=(l+r)&gt;&gt;1; fun(lc(p),l,mid,tag[p]); //下传给左孩子 fun(rc(p),mid+1,r,tag[p]); //下传给右孩子 tag[p]=0; //下传完，恢复标记&#125;void update(ll nl,ll nr,ll p,ll l,ll r,ll k) //区间修改，[nl,nr]表示修改的区间，p表示该区间的节点，[l,r]表示该节点表示的区间，k表示增量&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) //当需要修改的区间完全覆盖当前区间，我们就给该区间打上tag标记，并且更新一下该节点的值 &#123; tag[p]+=k; tree[p]+=(r-l+1)*k; return; &#125; if(tag[p]!=0) push_down(p,l,r); //没有完全覆盖则需要继续找，如果当前节点有tag标记，说明它的孩子节点没有被更新，我们要先下放tag标记 ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k); //更新左子树 if(nr&gt;mid)update(nl,nr,rc(p),mid+1,r,k); //更新右子树 push_up(p); //回溯时，维护父节点&#125; 区间查询12345678910ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) return tree[p]; //当查询的区间已经完全包括该区间时，直接return if(tag[p]!=0) push_down(p,l,r); //如果标记不为0,则说明该区间有修改，需要push_down传递给子节点，且需要在递归子节点前！！！ ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)res+=query(nl,nr,lc(p),l,mid); //递归左孩子 if(nr&gt;mid) res+=query(nl,nr,rc(p),mid+1,r); //递归右孩子 return res;&#125; 完整代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e6+5;ll tree[MAX_N&lt;&lt;2]; //线段树的节点，因为从树顶往下建树，所以需要4N的大小；ll a[MAX_N]; //存原数组ll tag[MAX_N&lt;&lt;2]; //标记ll N,M;ll lc(ll x) &#123;return x&lt;&lt;1;&#125; ll rc(ll x) &#123;return x&lt;&lt;1|1;&#125; void push_up(ll p)&#123; tree[p]=tree[lc(p)]+tree[rc(p)]; &#125;void fun(ll p,ll l,ll r,ll k)&#123; tag[p]=tag[p]+k; tree[p]=tree[p]+(r-l+1)*k;&#125;void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; fun(lc(p),l,mid,tag[p]); fun(rc(p),mid+1,r,tag[p]); tag[p]=0;&#125;void build(ll p,ll l,ll r) //递归建树&#123; tag[p]=0; if(l==r)&#123; tree[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); build(rc(p),mid+1,r); push_up(p);&#125;ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) return tree[p]; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)res+=query(nl,nr,lc(p),l,mid); if(nr&gt;mid) res+=query(nl,nr,rc(p),mid+1,r); return res;&#125;void update(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tag[p]+=k; tree[p]+=(r-l+1)*k; return; &#125; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k); if(nr&gt;mid)update(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;int main() &#123; scanf("%lld%lld",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) scanf("%lld",&amp;a[i]); build(1,1,N); while(M--) &#123; ll b; scanf("%lld",&amp;b); if(b==1) &#123; ll x,y,z; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); update(x,y,1,1,N,z); &#125; else &#123; ll x,y; scanf("%lld%lld",&amp;x,&amp;y); printf("%lld\n",query(x,y,1,1,N)); &#125; &#125; return 0;&#125; 线段树模板2:如题，已知一个数列，你需要进行下面三种操作： 1.将某区间每一个数乘上x 2.将某区间每一个数加上x 3.求出某区间每一个数的和传送门设置两个lazytag，一个存加法，一个存乘法 push_down操作的时候，人为的给这两个lazytag规定先后顺序 乘法优先：tree[lc(p)]=(tree[lc(p)]mul[p]+add[p](mid-l+1));tree[rc(p)]=(tree[rc(p)]mul[p]+add[p](r-mid)); 123456789101112131415void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; tree[lc(p)]=(tree[lc(p)]*mul[p]+add[p]*(mid-l+1))%PP; tree[rc(p)]=(tree[rc(p)]*mul[p]+add[p]*(r-mid))%PP; mul[lc(p)]=(mul[lc(p)]*mul[p])%PP; mul[rc(p)]=(mul[rc(p)]*mul[p])%PP; add[lc(p)]=(add[lc(p)]*mul[p]+add[p])%PP; add[rc(p)]=(add[rc(p)]*mul[p]+add[p])%PP; add[p]=0; mul[p]=1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;ll N,M,PP;ll tree[MAX_N&lt;&lt;2];ll add[MAX_N&lt;&lt;2];ll mul[MAX_N&lt;&lt;2];ll a[MAX_N];ll lc(ll x)&#123;return x&lt;&lt;1;&#125;ll rc(ll x)&#123;return x&lt;&lt;1|1;&#125;void push_up(ll p)&#123; tree[p]=(tree[lc(p)]+tree[rc(p)])%PP;&#125;void build(ll p,ll l,ll r)&#123; add[p]=0; mul[p]=1; if(l==r) &#123; tree[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); build(rc(p),mid+1,r); push_up(p);&#125;void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; tree[lc(p)]=(tree[lc(p)]*mul[p]+add[p]*(mid-l+1))%PP; tree[rc(p)]=(tree[rc(p)]*mul[p]+add[p]*(r-mid))%PP; mul[lc(p)]=(mul[lc(p)]*mul[p])%PP; mul[rc(p)]=(mul[rc(p)]*mul[p])%PP; add[lc(p)]=(add[lc(p)]*mul[p]+add[p])%PP; add[rc(p)]=(add[rc(p)]*mul[p]+add[p])%PP; add[p]=0; mul[p]=1;&#125;void update1(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tree[p]=(tree[p]*k)%PP; add[p]=(add[p]*k)%PP; mul[p]=(mul[p]*k)%PP; return; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) update1(nl,nr,lc(p),l,mid,k); if(mid&lt;nr) update1(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;void update2(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tree[p]=(tree[p]+k*(r-l+1))%PP; add[p]=(add[p]+k)%PP; return; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) update2(nl,nr,lc(p),l,mid,k); if(mid&lt;nr) update2(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; return tree[p]; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) res=(res+query(nl,nr,lc(p),l,mid))%PP; if(mid&lt;nr) res=(res+query(nl,nr,rc(p),mid+1,r))%PP; return res%PP;&#125;int main() &#123; //scanf("%d%d%d",&amp;N,&amp;M,&amp;P); cin&gt;&gt;N&gt;&gt;M&gt;&gt;PP; for(ll i=1;i&lt;=N;i++) cin&gt;&gt;a[i];//scanf("%d",&amp;a[i]); build(1,1,N); while(M--) &#123; ll op,l,r,k; cin&gt;&gt;op&gt;&gt;l&gt;&gt;r; //scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1) &#123; cin&gt;&gt;k; //scanf("%d",&amp;k); update1(l,r,1,1,N,k); &#125; else if(op==2) &#123; cin&gt;&gt;k; //scanf("%d",&amp;k); update2(l,r,1,1,N,k); &#125; else &#123; ll ans=query(l,r,1,1,N); ans%=PP; // printf("%d\n",ans); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆序数]]></title>
    <url>%2F2019%2F10%2F08%2F%E9%80%86%E5%BA%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目链接：https://www.luogu.org/problem/P1908题目链接：https://ac.nowcoder.com/acm/problem/15163题意：给n个数，求这n个数的逆序对。（$a_i$&lt;$a_j$&amp;&amp;i&gt;j） 归并排序做法：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=5e5+5;int n;int a[MAX_N];int b[MAX_N];ll ans=0;void mergesort(int s,int t)&#123; if(s&gt;=t) return; int mid=(s+t)&gt;&gt;1; mergesort(s,mid); mergesort(mid+1,t); int i=s;int j=mid+1;int k=s; while(i&lt;=mid&amp;&amp;j&lt;=t)&#123; //合并两个区间 if(a[i]&lt;=a[j]) b[k++]=a[i++]; //满足顺序，直接用b数组存储 else &#123;b[k++]=a[j++]; ans+=mid+1-i;&#125; //当第一个区间的数比第二区间的数大，则它的逆序数为mid+1-i,i为这个数在第一个区间的位置. /*例如:合并左区间4,5,6 和 右区间1,2,3； 对于1来讲它的逆序对就有4,5,6,； 对于2来讲它的逆序对就有5,6; 对于3来讲它的逆序对就有6;*/ &#125; while(i&lt;=mid) b[k++]=a[i++]; while(j&lt;=t) b[k++]=a[j++]; for(int l=s;l&lt;=t;l++) a[l]=b[l];&#125;int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); mergesort(1,n); printf("%lld\n",ans); return 0;&#125; 树状数组做法：1.首先我们要知道树状数组是可以用来维护前缀和; 2.我们利用桶排的思想来求逆序对数,即遍历数组a,然后用b数组存储a[i]出现的次数(b[a[i]]++)。对于每个a[i]来说，它的逆序数为i-(1~$b_i$)的前缀和；如果直接遍历b的话太慢，所以我们用树状数组来维护前缀和。 3.当n很大的时候，我们不足以开这么大的b数组来存储，于是我们可以对a数组进行离散化，先将a数组排序，然后用1~n来表示a数组的相对大小。 4.要注意出现相同的数的时候，我们要将出现在后面的数排在后面。不然$a_i$=$a_j$ &amp;&amp; i &lt; j的时候，排序可能会让$a_j$排在$a_i$前面，导致处理$a_i$时会将$a_j$误判为逆序对. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=5e5+5;int n;int a[MAX_N];int b[MAX_N];int tree[MAX_N];struct Node&#123; int index; int val; &#125;node[MAX_N]; //用结构体来存储原来的值和位置inline int lowbit(int x) &#123; return x&amp;(-x);&#125;inline bool cmp(Node x,Node y) //排序法则&#123; if(x.val==y.val)return x.index&lt;y.index; else return x.val&lt;y.val;&#125; void add(int i,int x) //给第i位数加x&#123; while(i&lt;=n) &#123; tree[i]+=x; i+=lowbit(i); &#125;&#125; int sum(int i) //求1~i的前缀和&#123; int s=0; while(i&gt;0) &#123; s+=tree[i]; i-=lowbit(i); &#125; return s;&#125;int main() &#123; scanf("%d",&amp;n); ll ans=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;node[i].val); node[i].index=i; &#125; sort(node+1,node+1+n,cmp); //排序 for(int i=1;i&lt;=n;i++) b[node[i].index]=i; //离散化 for(int i=1;i&lt;=n;i++) &#123; add(b[i],1); ans+=i-sum(b[i]); &#125; printf("%lld\n",ans); return 0;&#125; 后记因为树状数组要排序，复杂度已经O(nlogn)了，还要进行维护树状数组操作，在数比较大的时候会比归并慢。但如果n比较小的情况下，用树状数组做会比较快，不用离散化的情况下。]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离散化</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物链]]></title>
    <url>%2F2019%2F10%2F05%2F%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/16884 题意：有N只动物，这些动物属于A、B、C的其中一种；已知A吃B、B吃C、C吃A。接着有K条信息，第一种：x和y是同类；第二种：x吃y。 问有多少条信息是假的？ 思路：对于每只动物i创建3个元素i-A,i-B,i-C，并用3*N个元素建立并查集。维护并查集：第一种：x和y同类： unite(x-A,y-A),unite(x-B,y-B),unite(x-c,y-c);第二种：x吃y： unite(x-A,y-B),unite(x-B,y-C),unite(x-C,y-A);如果出现第i条信息发生冲突 则说明是假话，ans++; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=3e5+5;int par[MAXN];int height[MAXN];int N,K;void init(int n)&#123; for(int i=1;i&lt;=n;i++) &#123; par[i]=i; height[i]=1; &#125;&#125;int Find(int x)&#123; if(par[x]==x) return x; else return par[x]=Find(par[x]);&#125;void unite(int x,int y)&#123; x=Find(x); y=Find(y); if(x==y) return; if(height[x]&lt;height[y]) &#123; par[x]=y; &#125; else &#123; par[y]=x; if(height[x]==height[y]) height[x]++; &#125;&#125;bool same(int x,int y)&#123; return Find(x)==Find(y);&#125;void solve()&#123; init(3*N); int ans=0; int t,x,y; for(int i=1;i&lt;=K;i++) &#123; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x&lt;=0||N&lt;x||y&lt;=0||N&lt;y) &#123;ans++;continue;&#125; if(t==1) &#123; if(same(x,y+N)||same(x,y+2*N)) ans++; else &#123; unite(x,y); unite(x+N,y+N); unite(x+2*N,y+2*N); &#125; &#125; else &#123; if(same(x,y)||same(x,y+2*N)) ans++; else &#123; unite(x,y+N); unite(x+N,y+2*N); unite(x+2*N,y); &#125; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2010]游戏]]></title>
    <url>%2F2019%2F10%2F05%2FSCOI2010-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/20566?&amp;headNav=acm题意：给n个装备，每个装备有两个属性，并且最多只能使用一次。求由这些点的属性能最大匹配到的值。思路：把每个属性看成点，每个装备看成边。然后连接成k个连通块，如果该连通块为树状，则答案只能是k-1；如果连通块为环状，则答案为k。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e6+5;const int MOD=1e8+7;int vis[MAXN]; //记录是否能达到int fa[MAXN]; //记录父节点int n; int fun(int x)&#123; return fa[x]==x ? x : fa[x]=fun(fa[x]);&#125;void unite(int x,int y)&#123; int a=fun(x); int b=fun(y); if(a==b) &#123; vis[a]=1; return ; &#125; if(a&gt;b) swap(a,b); //看见有大佬的交换写法有：x^=y^=x^=y; 将a为小，b为大 vis[a]=1; fa[a]=b; //将小点的父节点为大点&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=1000000;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); unite(a,b); &#125; for(int i=1;i&lt;=n;i++) &#123; if(!vis[i]) &#123; printf("%d\n",i-1); break; &#125; if(i==n&amp;&amp;vis[i]) &#123; printf("%d\n",i); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valentine's Day]]></title>
    <url>%2F2019%2F09%2F29%2FValentine-s-Day%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6693 题意：给n个礼物让女朋友开心的概率，女朋友只能开心一次。求送多少件礼物让女朋友开心的概率最大？ 思路：贪心去概率大的礼物，对于第i件物品，该物品开心的概率为P[i],能让女朋友开心的概率为win（1-P[i]）+loseP[i];然后就遍历所有礼物，当win变小的时候可以提前退出。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;const int MOD=100003;int T;int n;double P[10000+5];bool cmp(double a,double b) &#123;return a&gt;b;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf",&amp;P[i]); &#125; sort(P+1,P+1+n,cmp); double win=P[1]; double lose=1-P[1]; for(int i=2;i&lt;=n;i++) &#123; double temp=P[i]*lose+(1-P[i])*win; if(temp&lt;=win) break; else &#123; win=temp; lose*=1-P[i]; &#125; &#125; printf("%.12lf\n",win); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block Breaker]]></title>
    <url>%2F2019%2F09%2F29%2FBlock-Breaker%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6699 题意：给n*m矩阵，外围包着层墙，q次操作，每次操作击落(x,y)的方块，一个方块掉落可能会影响到附近的方块掉落，如果方块的上下或者左右夹不住该方块，则该方块掉落。DFS就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;const int MOD=100003;int T;int n,m,q;int x,y;bool vis[2005][2005];int dx[4]=&#123;1,0,-1,0&#125;;int dy[4]=&#123;0,1,0,-1&#125;;int dfs(int x,int y,int z)&#123; int temp=0; if(z==0) &#123; if(!vis[x][y])temp++; vis[x][y]=1; for(int i=0;i&lt;4;i++) &#123; int nx=x+dx[i]; int ny=y+dy[i]; if(nx&gt;0&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny]) &#123; temp+=dfs(nx,ny,1); &#125; &#125; &#125; else&#123; if((!vis[x-1][y]&amp;&amp;!vis[x+1][y])||(!vis[x][y+1]&amp;&amp;!vis[x][y-1])&amp;&amp;z==1) &#123; return 0; &#125; else &#123; if(!vis[x][y]) temp++; vis[x][y]=1; for(int i=0;i&lt;4;i++) &#123; int nx=x+dx[i]; int ny=y+dy[i]; if(nx&gt;0&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny]) &#123; temp+=dfs(nx,ny,1); &#125; &#125; &#125; &#125; return temp;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); memset(vis,0,sizeof(vis)); while(q--) &#123; scanf("%d%d",&amp;x,&amp;y); int temp=0; if(!vis[x][y]) &#123;vis[x][y]=1;temp++;&#125; printf("%d\n",dfs(x,y,0)+temp); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haybale Feast]]></title>
    <url>%2F2019%2F09%2F27%2FHaybale-Feast%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/625/C来源：牛客网 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int INF=0x3f3f3f3f;typedef long long ll;int n;ll m;int f[maxn];int s[maxn];int p[maxn];int head=1,tail=0;int ind=1;int main()&#123; //freopen("data.in","r",stdin); scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;f[i],&amp;s[i]); ll sum=0; ll ans=INF; for(int i=1;i&lt;=n;i++) &#123; sum+=f[i]; while(ind&lt;=i&amp;&amp;sum-f[ind]&gt;=m)&#123; sum-=f[ind]; ind++; //找到满足条件的ind位置 &#125; while(head&lt;=tail&amp;&amp;p[head]&lt;ind) head++; //当队首的位置小于ind位置，队首出队 while(head&lt;=tail&amp;&amp;s[p[tail]]&lt;=s[i]) tail--; //当 当前元素大于队尾，出队 p[++tail]=i; //入队 if(sum&gt;=m) ans=min(ans,(ll)s[p[head]]); //当满足条件时，求最优解 &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>牛客网</tag>
        <tag>单调队列</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2009]生日礼物]]></title>
    <url>%2F2019%2F09%2F26%2FSCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/problem/20565?&amp;headNav=acm 思路：先排序，然后该种类没入队的入队，如果全部种类没满且前面出现过这个种类，就更新该种类的坐标；如果全部种类满了就求解当前长度。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;const int INF=0x3f3f3f3f;typedef long long ll;int n,k;struct light&#123; int x; int type;&#125;;light a[maxn];int vis[100];int tt[maxn];bool cmp(light y,light z)&#123; return y.x&lt;z.x;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int num=0; int xx; int cnt=0; for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;num); for(int j=1;j&lt;=num;j++) &#123; scanf("%d",&amp;xx); a[++cnt].x=xx; a[cnt].type=i; &#125; &#125; sort(a+1,a+1+n,cmp); int sum=0; int ans=INF; int head=1,tail=1; while(tail&lt;=n) &#123; if(vis[a[tail].type]==0) sum++; vis[a[tail].type]=a[tail].x; while(head&lt;=tail&amp;&amp;a[head].x!=vis[a[head].type]) head++; if(sum==k) ans=min(ans,a[tail].x-a[head].x); tail++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neat Tree]]></title>
    <url>%2F2019%2F09%2F24%2FNeat%20Tree%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/problem/15815?&amp;headNav=acm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e6+5;const int mod=100003;int n;int a[MAX_N];stack&lt;int&gt; sta;int l[MAX_N];int r[MAX_N];int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",a+i); &#125; for(int i=1;i&lt;=n;i++) &#123; while(sta.size()&amp;&amp;a[sta.top()]&gt;a[i]) sta.pop(); //注意这里的"&gt;"号不是&gt;= l[i]=sta.empty()?1:sta.top()+1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=n;i&gt;=1;i--) &#123; while(sta.size()&amp;&amp;a[sta.top()]&gt;=a[i]) sta.pop(); //这里是"&gt;="，避免前后两个区间重合。 r[i]=sta.empty()?n:sta.top()-1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=1;i&lt;=n;i++) &#123; ans-=(ll)a[i]*((ll)(r[i]-i+1)*(ll)(i-l[i]+1)-1); //一个[a,b]区间里的集合为b-a+1,1是指为空的时候。 &#125; for(int i=1;i&lt;=n;i++) &#123; while(sta.size()&amp;&amp;a[sta.top()]&lt;a[i]) sta.pop(); l[i]=sta.empty()?1:sta.top()+1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=n;i&gt;=1;i--) &#123; while(sta.size()&amp;&amp;a[sta.top()]&lt;=a[i]) sta.pop(); r[i]=sta.empty()?n:sta.top()-1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=1;i&lt;=n;i++) &#123; ans+=(ll)a[i]*((ll)(r[i]-i+1)*(ll)(i-l[i]+1)-1); &#125; printf("%lld\n",ans); &#125; return 0;&#125; 其实可以两次循环就做完了，一次循环就能求出L和R。进栈的时候可以求出L[i]，出栈的时候可以求出sta.top的R;]]></content>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie树]]></title>
    <url>%2F2019%2F09%2F20%2FTrie%E6%A0%91%2F</url>
    <content type="text"><![CDATA[字典树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e4+5;int tri[MAX_N][30];int color[MAX_N];int k=1;void Insert(char * a)&#123; int alen=strlen(a); int p=0; for(int i=0;i&lt;alen;i++) &#123; int temp=a[i]-'a'; if(!tri[p][temp]) &#123; tri[p][temp]=k; k++; &#125; p=tri[p][temp]; &#125; color[p]=1;&#125;int Query(char *a)&#123; int alen=strlen(a); int p=0; for(int i=0;i&lt;alen;i++) &#123; int temp=a[i]-'a'; if(!tri[p][temp]) &#123; return 0; &#125; p=tri[p][temp]; &#125; return color[p]==1;&#125;int main()&#123; int t,q; char s[20]; scanf("%d%d",&amp;t,&amp;q); while(t--) &#123; scanf("%s",s); Insert(s); &#125; while(q--) &#123; scanf("%s",s); if(Query(s)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>前缀树</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%AB%98%E7%B2%BE%2F</url>
    <content type="text"><![CDATA[高精度模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e3+5;const int N = 4e4+5;# define FOR(i, a, b) for(int i = a; i &lt;= b; i++)# define _FOR(i, a, b) for(int i = a; i &gt;= b; i--)struct BigInt&#123; static const int M = 20500; int num[M + 10], len; BigInt() &#123; clean(); &#125; void clean()&#123; memset(num, 0, sizeof(num)); len = 1; &#125; void read()&#123; char str[M + 10]; scanf("%s", str); len = strlen(str); FOR(i, 1, len) num[i] = str[len - i] - '0'; &#125; void write()&#123; _FOR(i, len, 1) printf("%d", num[i]); puts(""); &#125; void itoBig(int x)&#123; clean(); while(x != 0)&#123; num[len++] = x % 10; x /= 10; &#125; if(len != 1) len--; &#125; bool operator &lt; (const BigInt &amp;cmp) const &#123; if(len != cmp.len) return len &lt; cmp.len; _FOR(i, len, 1) if(num[i] != cmp.num[i]) return num[i] &lt; cmp.num[i]; return false; &#125; bool operator &gt; (const BigInt &amp;cmp) const &#123; return cmp &lt; *this; &#125; bool operator &lt;= (const BigInt &amp;cmp) const &#123; return !(cmp &lt; *this); &#125; bool operator != (const BigInt &amp;cmp) const &#123; return cmp &lt; *this || *this &lt; cmp; &#125; bool operator == (const BigInt &amp;cmp) const &#123; return !(cmp &lt; *this || *this &lt; cmp); &#125; BigInt operator + (const BigInt &amp;A) const &#123; BigInt S; S.len = max(len, A.len); FOR(i, 1, S.len)&#123; S.num[i] += num[i] + A.num[i]; if(S.num[i] &gt;= 10)&#123; S.num[i] -= 10; S.num[i + 1]++; &#125; &#125; while(S.num[S.len + 1]) S.len++; return S; &#125; BigInt operator - (const BigInt &amp;A) const &#123; BigInt S; S.len = max(len, A.len); FOR(i, 1, S.len)&#123; S.num[i] += num[i] - A.num[i]; if(S.num[i] &lt; 0)&#123; S.num[i] += 10; S.num[i + 1]--; &#125; &#125; while(!S.num[S.len] &amp;&amp; S.len &gt; 1) S.len--; return S; &#125; BigInt operator * (const BigInt &amp;A) const &#123; BigInt S; if((A.len == 1 &amp;&amp; A.num[1] == 0) || (len == 1 &amp;&amp; num[1] == 0)) return S; S.len = A.len + len - 1; FOR(i, 1, len) FOR(j, 1, A.len)&#123; S.num[i + j - 1] += num[i] * A.num[j]; S.num[i + j] += S.num[i + j - 1] / 10; S.num[i + j - 1] %= 10; &#125; while(S.num[S.len + 1]) S.len++; return S; &#125; BigInt operator / (const BigInt &amp;A) const &#123; BigInt S; if((A.len == 1 &amp;&amp; A.num[1] == 0) || (len == 1 &amp;&amp; num[1] == 0)) return S; BigInt R, N; S.len = 0; _FOR(i, len, 1)&#123; N.itoBig(10); R = R * N; N.itoBig(num[i]); R = R + N; int flag = -1; FOR(j, 1, 10)&#123; N.itoBig(j); if(N * A &gt; R)&#123; flag = j - 1; break; &#125; &#125; S.num[++S.len] = flag; N.itoBig(flag); R = R - N * A; &#125; FOR(i, 1, S.len / 2) swap(S.num[i], S.num[len - i + 1]); while(!S.num[S.len] &amp;&amp; S.len &gt; 1) S.len--; return S; &#125; BigInt operator % (const BigInt &amp;A) const &#123; BigInt S; BigInt P = *this / A; S = *this - P * A; return S; &#125;&#125;;]]></content>
      <tags>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序 12345678910111213141516171819202122232425void QuickSort(int arr[],int left,int right)&#123; if(right&lt;=left) return; int i=left; int j=right; int key=arr[(i+j)/2]; while(i&lt;=j)&#123; while(arr[i]&lt;key)&#123; i++; if(i==right)&#123; break; &#125; &#125; while(arr[j]&gt;key)&#123; j--; if(j==left)&#123; break; &#125; &#125; if(i&lt;=j)&#123; swap(arr[i],arr[j]); i++;j--; &#125; &#125; QuickSort(arr,left,j); QuickSort(arr,i,right);&#125; 归并排序1234567891011121314void mergesort(int arr[],int s,int t,int temp[])&#123; if(s&gt;=t) return; int mid=(s+t)&gt;&gt;1; mergesort(arr,s,mid,temp); mergesort(arr,mid+1,t,temp); int i=s; int j=mid+1; int k=s; while(i&lt;=mid&amp;&amp;j&lt;=t)&#123; if(arr[i]&lt;=arr[j]) temp[k++]=arr[i++]; else temp[k++]=arr[j++]; &#125; while(i&lt;=mid) temp[k++]=arr[i]++; while(j&lt;=t) temp[k++]=arr[j++]; for(int l=s;l&lt;=t;l++) arr[l]=temp[l];&#125;]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Applese涂颜色]]></title>
    <url>%2F2019%2F04%2F29%2FApplese%E6%B6%82%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/contest/330/E 费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}≡1(mod p)$。 在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: $a^{φ(n)}≡1(mod n)$φ(n)为欧拉函数，定义为不超过n的整数中与n互素的个数。欧拉降幂公式： $a^b≡a^{bmodφ(n)+φ(n)}mod n$ 题意：求出$2^n$。思路：快速幂求$2^n$，问题是n太大了。肯定用数组存，然后利用费马小定理：$2^nmod m=2^{n mod (m-1）}modm$ （这个怎么推我还不知道） 我写的AC代码：12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;//快速幂ll mod_pow(ll x,ll n)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;int main()&#123; string n,m; ll a; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; a=0; for(ll i=0;i&lt;n.size();i++)&#123; a=(a*10+n[i]-'0')%(mod-1); &#125; printf("%lld\n",mod_pow(2,a)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM模板]]></title>
    <url>%2F2019%2F04%2F28%2FACM%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一些比赛用的模板 数论快速幂 O(logn)123456789101112131415161718// 写法1：ll mod_pow(ll x,ll n, ll mod)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;//写法2:ll mod_pow(ll x,ll n, ll mod)&#123; if(n==0) return 1; ll res=mod_pow(x*x%mod,n/2,mod); if(n&amp;1) res=res*x%mod; return res;&#125; 矩阵快速幂12345678910111213141516171819202122232425262728typedef long long ll;typedef vector&lt;int&gt; vec;typedef vector&lt;vec&gt; mat;const int M=1e8+7; //模的大小//vector&lt;int&gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1mat mul(mat &amp;A,mat &amp;B)&#123; mat C(A.size(),vec(B[0].size())); for(int i=0;i&lt;A.size();i++)&#123; for(int k=0;k&lt;B.size();k++)&#123; for(int j=0;j&lt;B[0].size();j++)&#123; C[i][j]=(C[i][j]+A[i][k]*B[k][j])%M; &#125; &#125; &#125; return C;&#125;mat pow(mat A,ll n)&#123; mat B(A.size(),vec(A.size())); // 输出矩阵 for(int i=0;i&lt;A.size();i++)&#123; B[i][i]=1; &#125; while(n&gt;0)&#123; if(n&amp;1) B=mul(B,A); A=mul(A,A); n&gt;&gt;=1; &#125; return B;&#125; GCD 欧几里得算法 O（log max(a,b)）123456789101112131415161718192021int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;F(x)是斐波那契数列GCD(F[n],F[m])=F[gcd(n,m)//扩展欧几里得算法 ax+by=gcd(a,b); int extgcd(int a,int b,int&amp; x,int&amp; y)&#123; int d=a; if(b!=0)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125; else&#123; x=1; y=0; &#125; return d; &#125; 素数筛表时间复杂度接近O(n)123456789101112131415int vis[MAXN];int prime[MAXN];void Prime()&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!vis[i]) prime[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++) &#123; vis[i*prime[j]]=i; if(i%prime[j]==0) break; &#125; &#125;&#125; 二次探测定理：奇素数p（即除2外的素数）$xmodp^2=1$的解只有x=1和x=p-1 素数定理：随着x的增长,$π(x)/(x/ln(x))=1$，(π(x)为小于x的素数的个数) 递推式转矩阵 费马小定理和欧拉公式 费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}≡1(mod p)$。费马小定理：$2^nmodm=2^{nmod(m-1）}mod~~m$ （这个怎么推我还不知道） 在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: $a^{φ(n)}≡1(mod n)$φ(n)为欧拉函数，定义为不超过n的整数中与n互素的个数。欧拉降幂公式： $a^b≡a^{bmodφ(n)+φ(n)}mod n$123456789101112// 求欧拉函数值.int euler_phi(int n)&#123; int res=n; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; res=res/i*(i-1); for(;n%i==0;n/=i); &#125; &#125; if(n!=1) res=res/n*(n-1); return res;&#125; 卢卡斯定理Lucas定理是用来求 c(n,m) mod p，p为素数的值。表达式：C(n,m)%p=C(n/p,m/p)*C(n%p,m%p)%pLucas定理：我们令n=sp+q , m=tp+r .（q ，r ≤p）那么:&lt;/div&gt; 12 BBP公式12345678910111213141516171819202122#include &lt;iostream&gt;#define MAX_C 56000int a = 10000, b, c = MAX_C, d, e, f[MAX_C + 1], g, n, ans, cnt;using namespace std;/** BBP公式 参照CCDN的姬小野博客 本人还不会....*/int main() &#123; while(~scanf("%d", &amp;n))&#123; for (; b - c; ) f[b++] = a / 5; for (; d = 0, g = c * 2; c -= 14, ans = e + d / a, e = d % a, cnt++) &#123; if (cnt * 4 &gt; n) break; for (b = c; d += f[b]*a, f[b] = d % --g, d /= g--, --b; d *= b); &#125; if (n % 4 == 0) cout &lt;&lt; (ans / 1000); else if (n % 4 == 1) cout &lt;&lt; ((ans / 100) % 10); else if (n % 4 == 2) cout &lt;&lt; ((ans / 10) % 10); else if (n % 4 == 3) cout &lt;&lt; (ans % 10); printf("\n");&#125; return 0;&#125; 图论最短路问题任意两点间的最短路问题(Floyd算法)1234567891011int d[MAX_v][MAX_V] //无法到达时，权值为INF，主对角线为0int V // 顶点数void Floyd()&#123; for(int k=0;k&lt;V;k++)&#123; for(int i=0;i&lt;V;i++)&#123; for(int j=0;j&lt;V;j++)&#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125; &#125;&#125; 单源最短路问题(Dijkstra算法)12345678910111213141516171819202122232425262728293031323334int cost[MAX_V][MAX_V]; //图的临接矩阵int d[MAX_V]; //顶点s（起点）到各点的最短距离bool used[MAX_V]; //是否已经访问过int V; //顶点数int prev[MAX_V]; //前趋顶点 （路径还原）void Dijkstra(int s)&#123; fill(d,d+v,INF); fill(used,used+V,false); fill(prev,prev+V,-1); d[s]=0; while(true)&#123; int v=-1; for(int u=0;u&lt;V;u++)&#123; if(!used[u]&amp;&amp;(v==-1||d[u]&lt;d[v])) v=u; &#125; if(v==-1) break; used[v]=true; for(int u=0;u&lt;V;u++)&#123; if(d[u]&gt;d[v]+cost[v][u])&#123; d[u]=d[v]+cost[v][u]; prev[u]=v; &#125; &#125; &#125;&#125;//到顶点t的最短路vector&lt;int&gt; get_path(int t)&#123; vector&lt;int&gt; path; for(;t!=-1;t=prev[t]) path.push_back(t); reverse(path.begin(),path.end()); return path;&#125; 最小生成树Prim算法1234567891011121314151617181920212223242526int cost[MAX_V][MAX_V]; //临接矩阵表示边int mincost[MAX_V]; //从集合X出发的边到每个顶点的最小权值bool used[MAX_V]; //顶点i是否包含在集合X中int V; //顶点数int prim()&#123; for(int i=0;i&lt;V;i++)&#123; mincost[i]=INF; used[i]=false; &#125; mincost[0]=0; int res=0; while(true)&#123; int v=-1; for(int u=0;u&lt;V;u++)&#123; if(!used[u]&amp;&amp;(v==-1||mincost[u]&lt;mincost[v])) v=u; &#125; if(v==-1) break; used[v]=true; //把顶点v加入X res+=mincost[v]; //把边的长度加到结果里 for(int u=0;u&lt;V;u++)&#123; mincost[u]=min(mincost[u],cost[v][u]); &#125; &#125; return res;&#125; Kruskal算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct edge&#123; int u,v,cost;&#125;;bool comp(const edge&amp; e1,const edge&amp; e2)&#123; return e1.cost &lt; e2.cost;&#125;int par[MAX_N] //父亲int rank[MAX_N] //数的高度void init_union_find(int n)&#123; for(int i=0;i&lt;n;i++)&#123; par[i]=i; rank[i]=0; &#125;&#125;int find(int x)&#123; if(par[x]==x)&#123; return x; &#125;else&#123; return par[x]=find(par[x]); &#125;&#125;void unite(int x,int y)&#123; x=find(x); y=find(y); if(x==y) return; if(rank[x]&lt;rank[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(rank[x]==rank[y])rank[x]++; &#125;&#125;edge es[MAX_E];int V,E; //顶点数和边数int kruskal()&#123; sort(es,es+E,comp); //将边排序 init_union_find(V); //并查集初始化 int res=0; for(int i=0;i&lt;E;i++)&#123; edge e=es[i]; if(!same(e.u,e.v))&#123; unite(e.u,e.v); res+=e.cost; &#125; &#125; return res;&#125; 最大流最小割问题摘自：https://blog.csdn.net/yo_bc/article/details/72825629 FORD-FULKERSON(FF)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 205;struct node&#123; int v, w, next;&#125;edge[maxn*maxn];int no, n, m;int head[maxn], pre[maxn], rec[maxn], flow[maxn];stack&lt;int&gt; stk;void init()&#123; no = 0; memset(head, -1, sizeof head);&#125;//静态邻接表存边 void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;int dfs(int S, int T)&#123; memset(pre, -1, sizeof pre); while(!stk.empty()) stk.pop(); pre[S] = S; flow[S] = inf; stk.push(S); while(!stk.empty()) //用栈迭代替代dfs深搜 &#123; int top = stk.top(); stk.pop(); int k = head[top]; while(k != -1) &#123; if(pre[edge[k].v] == -1 &amp;&amp; edge[k].w &gt; 0) &#123; flow[edge[k].v] = min(flow[top], edge[k].w); pre[edge[k].v] = top; rec[edge[k].v] = k; stk.push(edge[k].v); &#125; k = edge[k].next; &#125; if(pre[T] != -1) return flow[T]; &#125; return -1;&#125;int FF(int s, int t)&#123; int ans = 0, add; while((add = dfs(s, t)) != -1) //直到找不到增广路 &#123; ans += add; int k = t; while(k != s) &#123; edge[rec[k]].w -= add; edge[rec[k]^1].w += add; k = pre[k]; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; init(); for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; FF(1, n) &lt;&lt; endl; &#125; return 0;&#125; Edmonds-Karp(EK)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 205;struct node&#123; int v, w, next;&#125;edge[maxn*maxn];int no, n, m;int head[maxn], pre[maxn], rec[maxn], flow[maxn];queue&lt;int&gt; q;void init()&#123; no = 0; memset(head, -1, sizeof head);&#125;//静态邻接表存边 void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;int dfs(int S, int T)&#123; memset(pre, -1, sizeof pre); while(!q.empty()) q.pop(); pre[S] = S; flow[S] = inf; q.push(S); while(!q.empty()) &#123; int top = q.front(); q.pop(); int k = head[top]; while(k != -1) &#123; if(pre[edge[k].v] == -1 &amp;&amp; edge[k].w &gt; 0) &#123; flow[edge[k].v] = min(flow[top], edge[k].w); pre[edge[k].v] = top; rec[edge[k].v] = k; q.push(edge[k].v); &#125; k = edge[k].next; &#125; if(pre[T] != -1) return flow[T]; &#125; return -1;&#125;int EK(int s, int t)&#123; int ans = 0, add; while((add = dfs(s, t)) != -1) //直到找不到增广路 &#123; ans += add; int k = t; while(k != s) &#123; edge[rec[k]].w -= add; edge[rec[k]^1].w += add; k = pre[k]; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; init(); for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; EK(1, n) &lt;&lt; endl; &#125; return 0;&#125; Dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 205;struct node&#123; int v, w, next;&#125;edge[maxn*maxn];int dis[maxn], pre[maxn], rec[maxn], head[maxn], block[maxn];int n, m, no;queue&lt;int&gt; q;//静态邻接表存边 inline void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;inline void pre_init()&#123; no = 0; memset(head, -1, sizeof head);&#125;void init(int S, int T)&#123; //初始化一定要注意把所涉及的都覆盖到 for(int i = 0; i &lt;= n; ++i) &#123; dis[i] = inf; block[i] = 0; //标记阻塞点 &#125; while(!q.empty()) q.pop(); dis[S] = 0; q.push(S); while(!q.empty()) //生成层次图 &#123; int tp = q.front(); q.pop(); int k = head[tp]; while(k != -1) &#123; if(dis[edge[k].v] == inf &amp;&amp; edge[k].w) &#123; dis[edge[k].v] = dis[tp] + 1; q.push(edge[k].v); &#125; k = edge[k].next; &#125; &#125;&#125;int dinic(int S, int T)&#123; int top = S, ans = 0, flow = inf; pre[S] = S; init(S, T); while(dis[T] != inf) //当S无法到达T，不能再增广了 &#123; int k = head[top]; while(k != -1) &#123; if(edge[k].w &amp;&amp; dis[edge[k].v] == dis[top]+1 &amp;&amp; !block[edge[k].v]) break; k = edge[k].next; &#125; if(k != -1) //找到下一节点 &#123; int v = edge[k].v; flow = min(flow, edge[k].w); pre[v] = top; rec[v] = k; top = v; if(top == T) &#123; ans += flow; v = -1; k = T; while(k != S) &#123; edge[rec[k]].w -= flow; edge[rec[k]^1].w += flow; if(!edge[rec[k]].w) v = k; //寻找距S最近的一个"瓶颈"边 k = pre[k]; &#125; flow = inf; //此处flow必须在外面，大佬的板子可能没注意到，我认为是必须的 if(v != -1) //找到"瓶颈"边 &#123; top = pre[v]; k = top; while(k != S) &#123; flow = min(edge[rec[k]].w, flow); k = pre[k]; &#125; &#125; &#125; &#125; else &#123; block[top] = 1; //找不到下一节点成为阻塞点 top = pre[top]; //回溯 if(block[S]) init(S, T);//如果S被阻塞，重新计算层次图 //阻塞点的产生也造成了flow的最小值可能是后面的值，虽然进行一次 //增广并没什么问题，但上述寻找瓶颈边的判断则是必须的了。 &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; pre_init(); for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; dinic(1, n) &lt;&lt; endl; &#125; return 0;&#125; /**********************比赛版本***********************/ #include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 205;const int maxm = maxn*maxn;struct node&#123;int w; int v, next;&#125; edge[maxm];int pre[maxn], rec[maxn], head[maxn], block[maxn];int dis[maxn];int n, m, no;int S, T;queue&lt;int&gt; q;inline void init()&#123; no = 0; memset(head, -1, sizeof head);&#125;inline void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;void reset(int S, int T)&#123; memset(dis, 0x3f, sizeof dis); memset(block, 0, sizeof block); q.push(S); dis[S] = 0; while(!q.empty()) &#123; int top = q.front(); q.pop(); for(int k = head[top]; k != -1; k = edge[k].next) if(dis[edge[k].v] == inf &amp;&amp; edge[k].w) dis[edge[k].v] = dis[top]+1, q.push(edge[k].v); &#125;&#125;int dinic(int S, int T)&#123; int ans = 0, flow = inf; int top = S; reset(S, T); pre[S] = S; while(dis[T] != inf) &#123; int k, tmp; for(k = head[top]; k != -1; k = edge[k].next) &#123; if(edge[k].w &amp;&amp; dis[edge[k].v]==dis[top]+1 &amp;&amp; !block[edge[k].v]) break; &#125; if(k != -1) &#123; tmp = edge[k].v; flow = min(flow, edge[k].w); pre[tmp] = top, rec[tmp] = k; top = tmp; if(top == T) &#123; ans += flow; tmp = -1; for(; top != S; top = pre[top]) &#123; edge[rec[top]].w -= flow; edge[rec[top]^1].w += flow; if(!edge[rec[top]].w) tmp = top; &#125; flow = inf; if(tmp != -1) &#123; top = pre[tmp]; for(; top != S; top = pre[top]) flow = min(flow, edge[rec[top]].w); top = pre[tmp]; &#125; &#125; &#125; else &#123; block[top] = 1; top = pre[top]; if(block[S]) reset(S, T); &#125; &#125; return ans;&#125;void mapping()&#123; int u, v, w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;int main()&#123; while(~scanf("%d %d", &amp;m, &amp;n)) &#123; S = 1, T = n; init(); mapping(); printf("%d\n", dinic(S, T)); &#125; return 0;&#125; Shortest Augmenting Paths(SAP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int inf = 0x7fffffff; const int maxn = 205; const int maxm = maxn*maxn; //一定要好好计算边的数量 struct node &#123; int v, w, next; &#125;edge[maxm]; int dis[maxn], pre[maxn], rec[maxn], head[maxn], gap[maxn], now[maxn]; int n, m, no, up; //up指逆层次图可能还有增广路时dis的上界 queue&lt;int&gt; q; //静态邻接表存边 inline void add(int u, int v, int w) &#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++; &#125; inline void pre_init() &#123; no = 0; up = n; memset(head, -1, sizeof head); &#125; void init(int S, int T) &#123; for(int i = 0; i &lt;= up; ++i) &#123; now[i] = head[i]; //now用作当前弧的优化 //注意这里now数组要把所有用到的标号都存过来 gap[i] = 0, dis[i] = inf; //初始化一定要注意把所涉及的都覆盖到 &#125; while(!q.empty()) q.pop(); dis[T] = 0; q.push(T); while(!q.empty()) //生成逆层次图 &#123; int tp = q.front(); q.pop(); ++gap[dis[tp]]; int k = head[tp]; while(k != -1) &#123; if(dis[edge[k].v] == inf &amp;&amp; edge[k^1].w) &#123; dis[edge[k].v] = dis[tp]+1; q.push(edge[k].v); &#125; k = edge[k].next; &#125; &#125; &#125; int SAP(int S, int T) &#123; int ans = 0, flow = inf, top = S; pre[S] = S; init(S, T); while(dis[S] &lt; up) //当S到T的距离大于等于点的个数时肯定就不能再增广了 &#123; //切记此处与节点数比较，因为通过方向变会造成距离可能达到节点数 if(top == T) &#123; ans += flow; while(top != S) //修改残留网络，并置top为S &#123; edge[rec[top]].w -= flow; edge[rec[top]^1].w += flow; top = pre[top]; &#125; flow = inf; &#125; int k = now[top]; while(k != -1) &#123; int v = edge[k].v; if(edge[k].w &amp;&amp; dis[top] == dis[v]+1) &#123; flow = min(flow, edge[k].w); pre[v] = top; rec[v] = k; now[top] = k;//当前弧的优化 top = v; break; &#125; k = edge[k].next; &#125; if(k == -1) &#123; int mind = n; if(--gap[dis[top]] == 0) break;//出现断层，间隙优化 int k = now[top] = head[top];//改变当前点的距离标号，也要清除之前的当前弧优化的影响 while(k != -1) &#123; if(edge[k].w &amp;&amp; mind&gt;dis[edge[k].v]) mind = dis[edge[k].v]; k = edge[k].next; &#125; ++gap[dis[top] = mind+1]; top = pre[top];//回溯到上一个点 &#125; &#125; return ans; &#125;int main() &#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; pre_init(); for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; SAP(1, n) &lt;&lt; endl; &#125; return 0; &#125; /**********************比赛版本***********************/ #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int inf = 0x3f3f3f3f; const int maxn = 205; const int maxm = maxn*maxn;struct node&#123;int w; int v, next;&#125; edge[maxm]; int pre[maxn], rec[maxn], head[maxn], gap[maxn], now[maxn]; int dis[maxn];int n, m, no, up; int S, T; queue&lt;int&gt; q;inline void add(int u, int v, int w) &#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++; &#125; inline void pre_init() &#123; no = 0; memset(head, -1, sizeof head); &#125; void init(int S, int T) &#123; memset(gap, 0, sizeof gap); memset(dis, 0x3f, sizeof dis); for(int i = 0; i &lt;= up; ++i) now[i] = head[i]; while(!q.empty()) q.pop(); dis[T] = 0; q.push(T); while(!q.empty()) &#123; int tp = q.front(); q.pop(); ++gap[dis[tp]]; int k = head[tp]; while(k != -1) &#123; if(dis[edge[k].v] == inf &amp;&amp; edge[k^1].w) &#123; dis[edge[k].v] = dis[tp]+1; q.push(edge[k].v); &#125; k = edge[k].next; &#125; &#125; &#125; int SAP(int S, int T) &#123; int ans = 0, flow = inf; int top = S; pre[S] = S; init(S, T); while(dis[S] &lt; up) &#123; if(top == T) &#123; ans += flow; while(top != S) &#123; edge[rec[top]].w -= flow; edge[rec[top]^1].w += flow; top = pre[top]; &#125; flow = inf; &#125; int k = now[top]; while(k != -1) &#123; int v = edge[k].v; if(edge[k].w &amp;&amp; dis[top] == dis[v]+1) &#123; flow = min(flow, edge[k].w); pre[v] = top; rec[v] = k; now[top] = k; top = v; break; &#125; k = edge[k].next; &#125; if(k == -1) &#123; int mind = up; if(--gap[dis[top]] == 0) break; int k = now[top] = head[top]; while(k != -1) &#123; if(edge[k].w &amp;&amp; mind&gt;dis[edge[k].v]) mind = dis[edge[k].v]; k = edge[k].next; &#125; ++gap[dis[top] = mind+1]; top = pre[top]; &#125; &#125; return ans; &#125; void mapping()&#123; int u, v, w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;int main() &#123; while(~scanf("%d %d", &amp;m, &amp;n)) &#123; up = n, S = 1, T = n; pre_init(); mapping(); printf("%d\n", SAP(S, T)); &#125; return 0; &#125; 二分图匈牙利算法123456789101112131415161718192021222324252627bool CP[MAX][MAX]; //cp[i][j]=1 表示i能和j组cpbool used[MAX]; //记录是否已经被访问int linked[MAX]; //linked[i]=j 表示i和j组cpbool fun(int x)&#123; int i for (i=1;i&lt;=N;i++)&#123; if (CP[x][i]==true &amp;&amp; used[i]==false) &#123; used[i]=1; if (linked[i]==0 || fun(linked[i])) &#123; linked[j]=x; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int ans=0; memset(linked,0,sizeof(linked)); for(int i=1;i&lt;=M;i++)&#123; memset(used,0,sizeof(used)); if(fun(i)) ans++; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 转载： https://blog.csdn.net/qq_32265245/article/details/53046750/* |求解最大匹配问题| |dfs实现|*/int v1, v2; bool Map[501][501]; bool visit[501]; int link[501]; int result; bool dfs(int x) &#123; for (int y = 1; y &lt;= v2; ++y) &#123; if (Map[x][y] &amp;&amp; !visit[y]) &#123; visit[y] = true; if (link[y] == 0 || dfs(link[y])) &#123; link[y] = x; return true; &#125; &#125; &#125; return false; &#125; void Search() &#123; for (int x = 1; x &lt;= v1; x++) &#123; memset(visit,false,sizeof(visit)); if (dfs(x)) result++; &#125;&#125; 博弈巴仕博弈（Bash Game）描述：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(n%(m+1)) cout&lt;&lt;"first"&lt;&lt;endl; else cout&lt;&lt;"second"&lt;&lt;endl; &#125; return 0;&#125; 威佐夫博弈（Wythoff Game）描述：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜1，我们用（a[k]，b[k]）（a[k] ≤ b[k] ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势。 2，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。 3，奇异局（举例） 首先列举人们已经发现的前几个奇异局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10） （8，13）、（9，15）、（11，18）、（12，20）。 通过观察发现：a[0]=b[0]=0,a[k]是未在前面出现过的最小自然数,而 b[k]= a[k] + k。 4，奇异局势有如下三条性质： 1）任何自然数都包含且仅包含在一个奇异局势中。 2）任意操作都可以使奇异局势变为非奇异局势。 3）必有一种操作可以使非奇异局势变为奇异局势。 5，奇异局势公式： a[k]=[k*(1+√5)/2]，b[k]=a[k]+k。 (k=0,1,2……，[ ]表示取整）123456789101112131415161718//威佐夫博弈模板#include&lt;bits/stdc++.h&gt;using namespace std;const double Gsr=(1+sqrt(5.0))/2;int main()&#123; int a,b; while(~scanf("%d%d",&amp;a,&amp;b)) &#123; if(a&gt;b) swap(a,b); if(a == (int)(Gsr*(b-a))) //奇异局势，先拿者输 puts("First Lose"); else puts("First Win"); &#125; return 0;&#125; Nim博弈描述：有n堆石子，每堆各有$a_i$课石子。Alice和Bob轮流从非空的石子堆中取走至少一颗石子。Alice先取，取光所有石子的一方获胜。当双方都采取最优策略时，谁会获胜？ 结论：计算所有$a_i$的异或值，如果非零则先手胜，为零则后手胜。1234567891011121314151617//Nim模板#include&lt;bits/stdc++.h&gt;using namespace std;const double Gsr=(1+sqrt(5.0))/2;int N，A[MAX_N];int main()&#123; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) cin&gt;&gt;A[i]; int x=0; for(int i=0;i&lt;N;i++) x^=A[i]; if(x!=0) puts("Alice"); else puts("Bob"); return 0;&#125; SG函数描述：Alice和Bob在玩这样一个游戏。给定k个数字$a_1,a_2,···,a_k$。一开始，有n堆硬币，每堆各有$x_i$枚硬币。Alice和Bob轮流选出一堆硬币，从中取出一些硬币。每次所取硬币的枚数一定要在$a_1,a_2,···,a_k$当中。Alice先取，取光硬币的一方获胜。当双方都采取最优策略时，谁会获胜？123456789101112131415161718192021222324//SG函数模板int N,K,X[MAX_N]，A[MAX_K];//利用动态规划计算grundy值的数组int grundy[MAX_X+1];void solve()&#123; //轮到自己时为0则必败 grundy[0]=0; //计算grundy值 int max_x=*max_element(X,X+N); for(int j=1;j&lt;=max_x;j++)&#123; set&lt;int&gt; s; for(int i=0;i&lt;K;i++)&#123; if(A[i]&lt;=j) s.insert(grundy[j-A[i]]); &#125; int g=0; while(s.count(g)!=0)g++; grundy[j]=g; &#125; //判断胜负 int x=0; for(int i=0;i&lt;N;i++) x^=grundy[X[i]]; if(x!=0) puts("Alice"); else puts("Bob");&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NB群友]]></title>
    <url>%2F2019%2F04%2F27%2FNB%E7%BE%A4%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[一道出题人出的签到题，结果大部分人没签到。于我而言，是看到数据量很大就慌了，觉得会超时，题面较长也没看下来。题目链接：https://ac.nowcoder.com/acm/contest/625/A 题意：找出满足$L&lt;=数位积&lt;=R$的数的个数. 思路：问题转换成求$数位积&lt;=R的个数-数位积&lt;=(L-1)的个数$，题解给的是dfs枚举2∼9每个数字出现的次数，然后再组合数统计一下答案，剪剪枝。题解链接： https://fshp971.com/2019-scut-contest-easy/题解给的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define mem(a,b) memset(a,b,sizeof(a))#define REP(i,a,b) for(int i=a; i&lt;=b; ++i)#define PER(i,a,b) for(int i=a; i&gt;=b; --i)#define MP make_pair#define PB push_back#define fi first#define se secondtypedef long long LL;typedef double DB;const int maxT = 50;const int P = 1e9+7;const LL MaxInt = (1LL&lt;&lt;32) - 1;LL Fac[100], InvFac[100];LL C[100][100];int cnt[20];LL lim;LL dfs(LL now, int pt) &#123; if(pt&lt;=1) &#123; int s = 0; LL ret = 1; REP(i,2,9) &#123; s += cnt[i]; ret = ret * C[s][cnt[i]] % P; &#125; if(s==0) return 0LL; return ret; &#125; LL ret = 0; cnt[pt] = 0; while(now &lt;= lim) &#123; ret = (ret + dfs(now, pt-1)) % P; now *= pt, ++cnt[pt]; &#125; return ret;&#125;int main() &#123; C[0][0] = 1; for(int i = 1; i &lt;= 50; ++i) &#123; C[i][0] = C[i][i] = 1; for(int k = 1; k &lt; i; ++k) C[i][k] = (C[i-1][k] + C[i-1][k-1]) % P; &#125; int _; scanf("%d", &amp;_); while(_--) &#123; LL a,b; scanf("%lld%lld", &amp;a, &amp;b); lim = b; LL sb = dfs(1,9); lim = a-1; LL sa = dfs(1,9); LL ans = (sb - sa + P) % P; printf("%lld\n", ans); &#125; return 0;&#125; 看到另一篇题解说的是搜索过程枚举每一位数，然后记录一下状态值，剪枝链接： https://www.cnblogs.com/ymzjj/p/10713187.html AC的代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll M=1e9+7;int T;map &lt; ll, ll&gt; mp;ll L,R;ll res;ll dfs(ll x)&#123; if(mp.count(x))&#123; return mp[x]; &#125; ll temp=0; for(int i=2;i&lt;=9;i++)&#123; if(x&gt;=i)&#123; temp+=dfs(x/i)+1; //枚举每一位数 &#125; &#125; return mp[x]=temp;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;L,&amp;R); res=(dfs(R)-dfs(L-1))%M; printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>牛客网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word-Search Wonder]]></title>
    <url>%2F2019%2F04%2F27%2FWord-Search-Wonder%2F</url>
    <content type="text"><![CDATA[题目链接: http://poj.org/problem?id=1501 题意：给一个字符矩阵，再给“单词”，在矩阵中找到单词，输出单词首元素的坐标和末元素的坐标。 思路：是一道深搜，需要注意的是深搜的方向由始至终只能往一个方向，水平，垂直还有斜线，而其他只需要理解好题目套模板即可做出，还有就是本题不需要标记数组，因为深搜方向只有一个，途中不会碰到已访问的点。 下面是AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n;char mat[105][105];char a[105];bool flag;int first_x,first_y,last_x,last_y;void dfs(int x,int y,int i,int dx,int dy)&#123; if(a[i]=='\0')&#123; flag=true; last_x=dx; last_y=dy; return; &#125; int nx=2*dx-x,ny=2*dy-y; if(0&lt;nx&amp;&amp;nx&lt;=n&amp;&amp;0&lt;ny&amp;&amp;ny&lt;=n&amp;&amp;mat[nx][ny]==a[i])&#123; dfs(dx,dy,i+1,nx,ny); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf(" %c",&amp;mat[i][j]); &#125; &#125; while(scanf("%s",a)!=EOF)&#123; if(a[0]=='0') break; flag=false; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(a[0]==mat[i][j]&amp;&amp;!flag)&#123; //dfs(i,j,1); first_x=i;first_y=j; for(int dx=-1;dx&lt;=1;dx++)&#123; for(int dy=-1;dy&lt;=1;dy++)&#123; int nx=i+dx,ny=j+dy; if(a[1]=='\0')&#123; flag=true;break; &#125; if(mat[nx][ny]==a[1]&amp;&amp;!flag)&#123; dfs(i,j,2,nx,ny); &#125; &#125; &#125; &#125; &#125; &#125; if(flag)&#123; printf("%d,%d %d,%d\n",first_x,first_y,last_x,last_y); &#125; else&#123; printf("Not found\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[动态规划入门题…题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1231题意： 给一个整数序列，求出这个序列的最大连续子序列，并输出它的开头元素和末尾元素，如果最大连续子序列小于0，则默认最大连续子序列为0，并输出序列首尾元素。想法有很多，分享一下动态规划做法。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX_N=1e5+5;int k;int a[MAX_N];int dp[MAX_N];void solve()&#123; int first=0,last=0; int temp=0; int res; for(int i=0;i&lt;k;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=a[i]; &#125; res=dp[0]; for(int i=1;i&lt;k;i++)&#123; //dp[i]=max(dp[i-1]+a[i],a[i]); //res=max(dp[i],res); if(dp[i-1]+a[i]&lt;a[i])&#123; dp[i]=a[i]; temp=i; &#125; else&#123; dp[i]=dp[i-1]+a[i]; &#125; if(res&lt;dp[i])&#123; res=dp[i]; first=temp; last=i; &#125; &#125; if(res&lt;0)&#123; first=0; last=k-1; res=0; &#125; printf("%d %d %d\n",res,a[first],a[last]);&#125;int main()&#123; while(scanf("%d",&amp;k)!=EOF&amp;&amp;k)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找出直系亲属]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%89%BE%E5%87%BA%E7%9B%B4%E7%B3%BB%E4%BA%B2%E5%B1%9E%2F</url>
    <content type="text"><![CDATA[一道水题…数据量较小，很多方法都能做。我用的是并查集。题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=3786题意：给n个关系你，然后询问m个问题，问题就是问你两个人是否为直系亲属，是就输出关系，不是就输出-。题意明了思路：用并查集来表示这个亲属图，以孩子作为根。两个人是否有关系就是一个点在找根的路径上是否会遇见另一个点，相遇就有，不相遇就是没有关系。以下是AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int N,M;int par[30];char a[4],b[3];int one,two;void init()&#123; for(int i=0;i&lt;30;i++)&#123; par[i]=i; &#125;&#125;int find(int x,int y)&#123; int res=0; while(x!=y&amp;&amp;x!=par[x])&#123; res++; x=par[x]; &#125; if(x==y) return res; else return 0;&#125;void solve()&#123; init(); for(int i=0;i&lt;N;i++)&#123; scanf("%s",a); for(int j=1;j&lt;3;j++)&#123; if(a[j]!='-')&#123; par[(int)a[j]-'A']=(int)a[0]-'A'; &#125; &#125; &#125; while(M--)&#123; scanf("%s",b); int res=find((int)b[0]-'A',(int)b[1]-'A'); if(res)&#123; switch(res)&#123; case 1: printf("parent\n");break; case 2: printf("grandparent\n"); break; default: for(int i=0;i&lt;res-2;i++)&#123; printf("great-"); &#125; printf("grandparent\n"); break; &#125; &#125; else&#123; res=find((int)b[1]-'A',(int)b[0]-'A'); switch(res)&#123; case 0: printf("-\n");break; case 1: printf("child\n");break; case 2: printf("grandchild\n"); break; default: for(int i=0;i&lt;res-2;i++)&#123; printf("great-"); &#125; printf("grandchild\n"); break; &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;N,&amp;M)!=EOF&amp;&amp;(M||N))&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URLs]]></title>
    <url>%2F2019%2F04%2F25%2FURLs%2F</url>
    <content type="text"><![CDATA[题目链接: http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=243题意: 给一个URL 找出URL的protocol、host、port、path，port和path可能不给出(即输出)。一道水题，但是一开始想法没有AC，后来改了改AC了…浪费了挺多时间 AC的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n;int cnt;void solve()&#123; string s; cin&gt;&gt;s; string protocal,host,port="&lt;default&gt;",path="&lt;default&gt;"; int i; i=s.find("://"); protocal=s.substr(0,i); s.erase(0,i+3); i=s.find("/"); if(i!=string::npos)&#123; host=s.substr(0,i); path=s.substr(i+1,s.size()); s.erase(i,s.size()); &#125; else&#123; host=s.substr(0,s.size()); &#125; i=s.find(":"); if(i!=string::npos)&#123; host=s.substr(0,i); s.erase(0,i+1); port=s; &#125; cout&lt;&lt;"URL #"&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;"Protocol = "&lt;&lt;protocal&lt;&lt;endl; cout&lt;&lt;"Host = "&lt;&lt;host&lt;&lt;endl; cout&lt;&lt;"Port = "&lt;&lt;port&lt;&lt;endl; cout&lt;&lt;"Path = "&lt;&lt;path&lt;&lt;endl;&#125;int main()&#123; scanf("%d",&amp;n); cnt=0; while(n--)&#123; cnt++; solve(); cout&lt;&lt;endl; &#125; return 0;&#125; WA的代码，具体原因我也不知道，感觉自己思路是对的…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;int n;int cnt;void solve()&#123; string s; cin&gt;&gt;s; string protocal,host,port="&lt;default&gt;",path="&lt;default&gt;"; int i; i=s.find("://"); protocal=s.substr(0,i); s.erase(0,i+3); i=s.find(":"); if(i!=string::npos)&#123; host=s.substr(0,i); s.erase(0,i+1); i=s.find("/"); if(i!=string::npos)&#123; port=s.substr(0,i); s.erase(0,i+1); path=s.substr(0,s.size()); &#125; else&#123; port=s.substr(0,s.size()); &#125; &#125; else&#123; i=s.find("/"); if(i!=string::npos)&#123; host=s.substr(0,i); s.erase(0,i+1); path=s.substr(0,s.size()); &#125; else&#123; host=s.substr(0,s.size()); &#125; &#125; cout&lt;&lt;"URL #"&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;"Protocol = "&lt;&lt;protocal&lt;&lt;endl; cout&lt;&lt;"Host = "&lt;&lt;host&lt;&lt;endl; cout&lt;&lt;"Port = "&lt;&lt;port&lt;&lt;endl; cout&lt;&lt;"Path = "&lt;&lt;path&lt;&lt;endl;&#125;int main()&#123; scanf("%d",&amp;n); cnt=0; while(n--)&#123; cnt++; solve(); cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匈牙利算法]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天分享的是匈牙利算法…匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。我觉得这个博主讲的挺生动形象的….https://blog.csdn.net/dark_scope/article/details/8880547 过山车题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=2063匈牙利算法经典入门题 题意： 尽可能地组成最多的CP。具体想法可以看上文分享的那位博主的博客。（图文并茂）下面是AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int K,M,N;bool CP[1000+5][1000+5]; //记录女生u是否愿意跟男生v组成CPint boy[1000+5]; //记录男生的对象是哪位女生bool used[1000+5]; //记录是否被访问过bool fun(int x)&#123; for(int i=1;i&lt;=N;i++)&#123; if(CP[x][i]==true&amp;&amp;used[i]==false)&#123; //可以组成CP且 该男生没有被访问过 used[i]=1; if(boy[i]==0||fun(boy[i]))&#123; //该男生还没组成CP，或者让原先跟这位男生组CP的女生去找其他男生组CP boy[i]=x; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int u,v; while(scanf("%d",&amp;K)!=EOF)&#123; int ans=0; if(K==0) break; scanf("%d%d",&amp;M,&amp;N); memset(CP,0,sizeof(CP)); memset(boy,0,sizeof(boy)); for(int i=0;i&lt;K;i++)&#123; scanf("%d%d",&amp;u,&amp;v); CP[u][v]=1; &#125; for(int i=1;i&lt;=M;i++)&#123; memset(used,0,sizeof(used)); //每次都是尝试让当前的女生去和男生组CP，所以需要重置used数组 if(fun(i)) ans++; &#125; printf("%d\n",ans); &#125; return 0;&#125; 匈牙利算法模板：123456789101112131415161718192021222324252627bool CP[MAX][MAX];bool used[MAX];int linked[MAX];bool fun(int x)&#123; int i for (i=1;i&lt;=N;i++)&#123; if (CP[x][i]==true &amp;&amp; used[i]==false) &#123; used[i]=1; if (linked[i]==0 || fun(linked[i])) &#123; linked[j]=x; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int ans=0; memset(linked,0,sizeof(linked)); for(int i=1;i&lt;=M;i++)&#123; memset(used,0,sizeof(used)); if(fun(i)) ans++; &#125;&#125; 关于匈牙利算法，不能一见到二分图匹配，上来就匈牙利，不然很容易TLE的，毕竟如果是最坏情况的话，该算法是的复杂度高达$O（M*N^2）$]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小数化分数]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%B0%8F%E6%95%B0%E5%8C%96%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[今天回顾了一下以前的题，小数化分数。题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1717思路：首先要知道无限循环小数分数形式的构造方法：分子为最小循环节，分母为分子对应位数的每个数都化成 9， 如已知无限循环小数：0.4747……以 47为循环节，那么这个小数的分数形式就是 47/99，题中，我们将小数的有限部分和无限循环部分分开处理，得到两个分数，再相加化简，所得即为所求。以下是AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;string s;ll s1,s2,n,m;ll gcd(ll a,ll b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;void solve()&#123; cin&gt;&gt;s; s1=s2=n=m=0; int i=2; while(s[i]!='('&amp;&amp;i&lt;s.length())&#123; s1=s1*10+s[i]-48; n++; i++; &#125; i++; while(s[i]!=')'&amp;&amp;i&lt;s.length())&#123; s2=s2*10+s[i]-48; i++; m++; &#125; if(m)&#123; s2=s2+(pow(10.0,m/1.0)-1)*s1; s1=pow(10.0,n/1.0)*(pow(10,m/1.0)-1); ll k=gcd(s2,s1); cout&lt;&lt;s2/k&lt;&lt;"/"&lt;&lt;s1/k&lt;&lt;endl; &#125; else&#123; s2=pow(10.0,n/1.0); ll k=gcd(s1,s2); cout&lt;&lt;s1/k&lt;&lt;"/"&lt;&lt;s2/k&lt;&lt;endl; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;N; while(N--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coloring Game]]></title>
    <url>%2F2019%2F04%2F20%2FColoring-Game%2F</url>
    <content type="text"><![CDATA[一道签到题…卡在快速幂取模，最后改对了，花费时间太长了，记录一下… 题目链接: https://nanti.jisuanke.com/t/38227 David has a white board with 2 \times N2×N grids.He decides to paint some grids black with his brush.He always starts at the top left corner and ends at the bottom right corner, where grids should be black ultimately.Each time he can move his brush up(↑), down(↓), left(←), right(→), left up(↖), left down(↙), right up(↗), right down (↘) to the next grid.For a grid visited before,the color is still black. Otherwise it changes from white to black.David wants you to compute the number of different color schemes for a given board. Two color schemes are considered different if and only if the color of at least one corresponding position is different. InputOne line including an integer n (0< n ≤ 10^9) OutputOne line including an integer, which represent the answer mod 1000000007样例输入12样例输出14样例输入13样例输出112 题意：从左上角到后下角的路径数，没经过一个格子，黑的不变，白的变黑思路: 从输入样例可以看出，对于每一列来讲除了第一列和最后一列，每一列都有三种情况，第一列和最后一列只有两种情况，所以路径数为3^{n-2}*2*2 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull n;ull poww(ull a, ull b) &#123; ull ans = 1, base = a; while (b != 0) &#123; if (b &amp; 1 != 0) &#123; ans =ans* base%1000000007; &#125; base = base*base%1000000007; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; while(scanf("%lld", &amp;n)!=EOF)&#123; if(n==1)&#123; printf("1\n"); &#125; else&#123; ull ans = poww(3, n - 2); printf("%lld\n", ans*4%1000000007); &#125; &#125; return 0;&#125; 总结：快速幂且取模1234567891011121314151617181920// 位运算typedef long long ll;ll mod_pow(ll x,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;// 递归typedef long long ll;ll mod_pow(ll x,ll n,ll mod)&#123; if(n==0) return 1; ll res=mod_pow(x*x%mod,n/2,mod); if(n&amp;1) res=res*x%mod; return res;&#125;]]></content>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Triangle]]></title>
    <url>%2F2019%2F04%2F20%2FTriangle%2F</url>
    <content type="text"><![CDATA[2019中山大学程序设计竞赛（重现赛）虽然是签到题，但是自己没有AC… TriangleTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionAfter Xiaoteng took a math class, he learned a lot of different shapes, but Xiaoteng’s favorite triangle is because he likes stable shapes, just like his style.After the Xiaoxun knew it, he wanted to give a triangle as a gift to Xiaoteng. He originally planned to do one, but he was too tired. So he decided to bring some wooden sticks to Xiaoteng and let Xiaoteng make a triangle himself.One day, Xiaoxun brought n sticks to Xiaoteng. Xiaoteng wanted to try to use three of them to form a triangle, but the number is too much, Xiaoteng stunned, so he can only ask for your help. InputThere are mutiple test cases.Each case starts with a line containing a integer $(1≤n≤5×10^6)$ which represent the number of sticks and this is followed by n positive intergers(smaller than $2^{31}−1$)separated by spaces.. OutputYES or NO for each case mean Xiaoteng can or can’t use three of sticks to form a triangle. Sample Input41 2 3 4 Sample OutputYES 题意： 给你n个数，问是否能从给的n个数从中组成一个三角形。题解：如果给的数成斐波那契数列，则不能构成三角形，且因为给的数是在$2^{32}-1$范围内，第50项斐波那契数为12586269025已经超过这个范围，即如果给了超过50个数，则必然能构成三角形。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int n;int vec[5000000+5];bool fun(int a,int b,int c)&#123; if(a&lt;c+b) return true; return false;&#125;bool compare(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int a; bool flag; while(scanf("%d",&amp;n)!=EOF)&#123; flag=0; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;vec[i]); &#125; if(n&lt;100)&#123; sort(vec,vec+n,compare); for(int i=0;i&lt;n-2;i++)&#123; flag=fun(vec[i],vec[i+1],vec[i+2]); if(flag) break; &#125; &#125; else flag=1; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 当时做并没有想到斐波那契数列….毕竟菜…如果不通过斐波那契数列来进行大判断会超时，然后我想换堆排序进行操作，用优先队列储存(实现了堆排序),结果卡内存…]]></content>
      <tags>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈STL]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%B5%85%E8%B0%88STL%2F</url>
    <content type="text"><![CDATA[今天浅谈一下下STL。STL是指C++的标准模板库(Standard Template Library)。一个既好用又复杂的library。 不定长数组：vector 需要添加头文件 #include vector是一个模板类，需要用vectora或者vectorb这样的方式来声明一个vector。 我个人觉得vector就像一个数组，但却比数组方便。 vector的基本操作12345678910111213141516数组有的基本操作，vector都有... vector&lt;int&gt; a; a.back();//返回a的最后一个元素 a.front();//返回a的第一个元素 a.clear();//清空a中的元素 a.empty();//判断a是否为空，空则返回ture,不空则返回false a.pop_back();//删除a向量的最后一个元素 a.erase(index)//删除下标index的元素 a.erase(a.begin()+1,a.begin()+3); //删除区间 [a.begin()+1,a.begin()+3) 的数，STL里面大多数都是采用左闭右开的形式. a.push_back(n);//在a的最后一个向量后插入一个元素，其值为n vector也有insert函数，跟string差不多在此不再赘述了，详情请翻看[Some tips for String](https://ihopezero.github.io/2019/04/17/Some-tips-for-String/). a.size();//返回a中元素的个数 a.capacity();//返回a的空间大小 a.resize();//重新设置a的大小 a.find(n);//返回n出现的下标，类似string的find() 集合：set需要添加头文件 “set “,set中的元素已从小到大排好序了，set是用二叉搜索树维护的集合容器，效率很高O（log(n)） set的基本操作123456789101112131415161718192021222324//声明set&lt;int&gt; s;//插入元素s.insert(1);s.insert(3);s.insert(5);//查找元素set&lt;int&gt;::iterator ite;//iterator的意思是迭代器，是STL中的重要概念，类似指针.ite=s.find(1);if(ite==s.end())puts("not found");else puts("found"); //输出 found//其他的查找元素方法//删除元素s.erase(3);if(s.count(3)!=0)puts("found");else puts("not found"); //输出not found//判断集合是否为空s.empty();//清空集合的元素s.clear();//遍历所有元素for(ite=s.begin();ite!=s.end();ite++)&#123; cout&lt;&lt;*ite;&#125; 映射：map需要添加头文件 “map”，map也是用二叉搜索树维护的集合容器，效率很高O（log(n)）map就是从key到value的映射，因为重载了[ ]运算符,map像是数组的”高级版”1234567891011121314151617181920//声明（int为key，const char*为value）map&lt;int,const char*&gt;m;//插入元素m.insert(make_pair(1,"ONE"));m.insert(make_pair(10,"TEN"));m[100]="HUNDRED";//查找元素map&lt;int,const char*&gt;::iterator ite;ite=m.find(1);puts(ite-&gt;second); //(输出)ONEite=m.find(2);if(ite==m.end())puts("not found");else puts(ite-&gt;second);puts(m[10]);//删除元素m.erase(10);//遍历一遍所有元素for(ite=m.begin();ite!=m.end();ite++)&#123; printf("%d: %s\n",ite-&gt;first,ite-&gt;second);&#125; 栈需要添加头文件 “stack”, 一种“后进先出”的数据结构12345678910111213141516//声明stack&lt;int&gt; S;//入栈S.push(1);S.push(3);S.push(5);cout &lt;&lt; S.size() &lt;&lt;endl;//输出栈元素的数量cout &lt;&lt; S.top() &lt;&lt; endl;//输出栈顶元素（不删除）S.pop();//删除栈顶元素cout &lt;&lt; S.top() &lt;&lt;endl;S.pop();cout &lt;&lt; S.top() &lt;&lt;endl;S.push(5);cout &lt;&lt; S.top() &lt;&lt; endl;S.pop();cout &lt;&lt; S.top() &lt;&lt; endl; 队列需要添加头文件 “queue”, 一种“先进先出”的数据结构12345678910111213141516//声明 queue&lt;int&gt; Q; //入队 Q.push(1); Q.push(3); Q.push(5); cout &lt;&lt; Q.size() &lt;&lt;endl;//输出队列元素的数量 cout &lt;&lt; Q.front() &lt;&lt; endl;//输出对首元素（不删除） Q.pop();//删除队首元素 cout &lt;&lt; Q.front() &lt;&lt;endl; Q.pop(); cout &lt;&lt; Q.front() &lt;&lt;endl; Q.push(5); cout &lt;&lt; Q.front() &lt;&lt; endl; Q.pop(); cout &lt;&lt; Q.front() &lt;&lt; endl; 优先队列STL的优先队列也在“queue”头文件里，是一个“越小的整数优先级越低的优先队列”出队的方法由front()变为top()，且出队元素不是最先进队的元素优先队列是可以理解为实现了堆的数据结构，O（logn）12 //声明priority_queue&lt;int&gt; pq; STL也提供了“越小的整数优先级越大的优先队列”12345678910111213 //声明 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; pq.push(3); pq.push(5); pq.push(1); while(!pq.empty())&#123; printf("%d\n",pq.top()); pq.pop(); &#125; //输出135 二分查找在“algorithm”里头文件1234//lower_bound返回值一般是&gt;= 给定value的iteratorint a[MAX];int t=lower_bound(a.begin(),a.end(),x)-a//返回的是x的下标，如果没有找到就返回比x小的最大的数的下标，这里查找的范围为[a.begin(),a.end()），又是左闭右开的区间....//upper_bound返回值则是 &gt; 给定value的iterator，语法跟lower_bound类似 sort排序sort可以对任意对象排序，即使是自己定义的struct，不过要加判断方法,在“algorithm”头文件里时间复杂度是O（logn）123456789101112131415161718192021222324int a[MAX];sort(a,a+n);//对前n个元素进行升序排序sort（start，end，排序方法)#include&lt;bits/stdc++.h&gt;using namespace std;bool complare(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int a[10]=&#123;9,6,3,8,5,2,7,4,1,0&#125;; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; sort(a,a+10,complare);//在这里就不需要对complare函数传入参数了。这是规则 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125;//输出9 6 3 8 5 2 7 4 1 09 8 7 6 5 4 3 2 1 0 unique函数一个可以删除有序数组中的重复元素,在“algorithm”头文件里unique的作用是“去掉”容器中相邻元素的重复元素（不一定要求数组有序），它会把重复的元素添加到容器末尾（所以数组大小并没有改变），而返回值是去重之后的尾地址，12345678910111213141516171819202122232425262728293031323334iterator unique(iterator it_1,iterator it_2);iterator unique(iterator it_1,iterator it_2,bool MyFunc);//第三个参数是指自定义两个元素相等的规则，类似sort函数如果想真实删除重复元素可以在调用完unique函数之后，调用erase(it_2,a.end());进行删除#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; a.push_back(1); a.push_back(1); a.push_back(13); a.push_back(13); a.push_back(5); a.push_back(6); vector&lt;int&gt;::iterator it_1 = a.begin(); vector&lt;int&gt;::iterator it_2 = a.end(); vector&lt;int&gt;::iterator new_end; sort(it_1,it_2); for(int i = 0 ; i &lt; a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;" "; new_end = unique(it_1,it_2); //注意unique的返回值 cout&lt;&lt;endl; cout&lt;&lt;"调用unique()的 a : "; for(int i = 0 ; i &lt; a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;" "; a.erase(new_end,it_2); cout&lt;&lt;endl; cout&lt;&lt;"删除重复元素后的 a : "; for(int i = 0 ; i &lt; a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl;&#125; reverse逆转元素12reverse(start,end)reverse_copy(start,end,b)//将逆转后的元素存入b数组中]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sudoku]]></title>
    <url>%2F2019%2F04%2F18%2FSudoku%2F</url>
    <content type="text"><![CDATA[POJ中有四道数独题，链接如下。难度大致为：2676=2918&lt;3074&lt;3076 http://poj.org/problem?id=2676http://poj.org/problem?id=2918http://poj.org/problem?id=3074http://poj.org/problem?id=3076 首先我们先来讲讲2676和2918这两道最简单的吧。想法1：因为是数独题，所以每行每列以及每个小方块的数字是不能重复的。因此我们可以用DFS尝试填数字上去。然后再加一些适当的剪枝就能AC 2676和2918题了。 以下给出2918的AC代码。 2918和2676只是输出格式不一样。改一下就能AC了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int T;int tri[9][9];bool row[9][9];bool col[9][9];bool little_tri[9][9];int cnt=1;int No(int i,int j)&#123; //判断当前格子是属于哪个小方格的 return (i/3)*3+j/3;&#125;bool dfs(int i,int j)&#123; if(i==9)&#123; //出口 return true; &#125; int no=No(i,j); int temp=tri[i][j]; bool flag; if(temp)&#123; //如果该格子有数字就直接dfs下一个格子 if(j==8)&#123; flag= dfs(i+1,0); &#125; else&#123; flag= dfs(i,j+1); &#125; if(flag) return true; else return false; &#125; else&#123; for(int k=1;k&lt;=9;k++)&#123; //尝试1~9的数字 if(!row[i][k-1]&amp;&amp;!col[j][k-1]&amp;&amp;!little_tri[no][k-1])&#123; //前提是该格子允许填入k这个数字 tri[i][j]=k; row[i][k-1]=1; col[j][k-1]=1; little_tri[no][k-1]=1; if(j==8)&#123; flag= dfs(i+1,0); &#125; else&#123; flag= dfs(i,j+1); &#125; if(flag) return true; else &#123; //如果失败了，则回溯！ tri[i][j]=0; row[i][k-1]=0; col[j][k-1]=0; little_tri[no][k-1]=0; &#125; &#125; &#125; &#125; return false;&#125;void solve()&#123; string a; memset(tri,0,sizeof(tri)); memset(row,0,sizeof(row)); memset(col,0,sizeof(col)); memset(little_tri,0,sizeof(little_tri)); int tep; int no; for(int i=0;i&lt;9;i++)&#123; cin&gt;&gt;a; for(int j=0;j&lt;9;j++)&#123; tri[i][j]=a[j]-'0'; tep=tri[i][j]; no=No(i,j); if(tep)&#123; row[i][tep-1]=1; col[j][tep-1]=1; little_tri[no][tep-1]=1; &#125; &#125; &#125; dfs(0,0); printf("Scenario #%d:\n",cnt++); for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; cout&lt;&lt;tri[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; //freopen("data.in","r",stdin); //freopen("data.out","w",stdout); scanf("%d",&amp;T); while(T--)&#123; solve(); if(T!=0)cout&lt;&lt;endl; &#125; return 0;&#125; 但这个算法是无法通过POJ3074的，因为3074题的空白格子比较多，该方法行不通，需要进一步优化。 现在讲一下POJ3074的思路想法2：考虑处理某一行时，对于某个还没有用过的数字，如果该行只有一个可行的空白格子，则将该数字填入该格子。对于列和方块也一样。反之，如果某个格子可填的数字只有一个，也只能将该数字填入该格子。 POJ3076的思路想法3：假设有一个只有两个候选数字的格子，如果选择其中一个产生了矛盾，那么就可以确定选择另一个。而对于有五个候选数字的格子，即使其中一个出现了矛盾，依然还有四个候选数字需要尝试。换句话说，选数字少的格子填数字比从左上角开始DFS更加高效.。 由于今晚比较晚了，下次有空补上 3074 和3076的代码。]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some tips for String]]></title>
    <url>%2F2019%2F04%2F17%2FSome-tips-for-String%2F</url>
    <content type="text"><![CDATA[Some tips for String笔者因为在做题时老是遇到String的坑，为此特意补一篇blog来尽量解决string 的坑…. 构造函数(Constructors)语法：12345678910111213141516string();string( size_type length, char ch );//构造length个ch string str1(10,'a');//构造十个astring( const char *str );string str2("hello wrold");//构造一个"hello wrold"的字符串string( const char *str, size_type length );//以index为索引开始的子串string str3(str2,6);//构造一个"wrold"的字符串string( string &amp;str, size_type index, size_type length );//以index为索引开始的子串，长度为lengthstring str4(str2,6,9);//构造一个"wrol"的字符串string( input_iterator start, input_iterator end );string str5(str2.begin(),str2.end());//构造一个"hello wrold"的子串 操作符(Operators)12345678910&gt;&lt;&gt;=&lt;=!=// 上面五个都是比较字符串用的+= === //判断两个字符串是否相等[index] //获取索引为index的字符,类似数组 函数at12//作用类似[]操作符at()函数返回一个引用，指向在index位置的字符. 如果index不在字符串范围内, at() 将报告"out of range"错误，并抛出out_of_range异常。 begin 和 end12begin()函数返回一个迭代器,指向字符串的第一个元素.end()函数返回一个迭代器,指向字符串的最后一个元素. c_str123c_str()函数返回一个指向正规C字符串的指针, 内容与本字符串相同.string str("hello wrold");printf("%s",str.c_str());//我理解为string 转换为char []; 比较(compare)123456789int compare( const basic_string &amp;str );//比较自己和strint compare( const char *str );//比较自己和strint compare( size_type index, size_type length, const basic_string &amp;str );//比较自己的子串和str,自己的子串以index索引开始，长度为lengthint compare( size_type index, size_type length, const basic_string &amp;str, size_type index2,size_type length2 );//比较自己的子串和str的子串，其中index2和length2引用str，index和length引用自己int compare( size_type index, size_type length, const char *str, size_type length2 );//比较自己的子串和str的子串，其中str的子串以索引0开始，长度为length2，自己的子串以index开始，长度为length 拷贝(copy)12size_type copy( char *str, size_type num, size_type index );copy()函数拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数 empty12bool empty();如果字符串为空则empty()返回真(true)，否则返回假(false). 删除(erase)123iterator erase( iterator pos );//删除pos指向的字符, 返回指向下一个字符的迭代器,iterator erase( iterator start, iterator end );//删除从start到end的所有字符, 返回一个迭代器,指向被删除的最后一个字符的下一个位置basic_string &amp;erase( size_type index = 0, size_type num = npos );//删除从index索引开始的num个字符, 返回*this. 查找(find)12345678910111213//返回str在字符串中第一次出现的位置（从index开始查找）。如果没找到则返回string::npossize_type find( const basic_string &amp;str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找）。如果没找到则返回string::npossize_type find( const char *str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找，长度为length）。如果没找到就返回string::npossize_type find( const char *str, size_type index, size_type length );//返回字符ch在字符串中第一次出现的位置（从index开始查找）。如果没找到就返回string::npossize_type find( char ch, size_type index );string::npos 直接输出：4294967295用来表示不存在的意思...例如：string str("hello wrold");cout&lt;&lt;str.find('a'); //就会打印出4294967295 下面提一下其他查找函数： find_first_of12345678//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，如果没找到就返回string::npossize_type find_first_of( const basic_string &amp;str, size_type index = 0 );//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，如果没找到就返回string::npossize_type find_first_of( const char *str, size_type index = 0 );//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，最多搜索num个字符。如果没找到就返回string::npossize_type find_first_of( const char *str, size_type index, size_type num );//查找在字符串中第一个与ch匹配的字符，返回它的位置。搜索从index开始。size_type find_first_of( char ch, size_type index = 0 ); find_first_not_of12345678//在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_first_not_of( const basic_string &amp;str, size_type index = 0 );//在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_first_not_of( const char *str, size_type index = 0 );//在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始，最多查找num个字符。如果没找到就返回string::nopssize_type find_first_not_of( const char *str, size_type index, size_type num );//在字符串中查找第一个与ch不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_first_not_of( char ch, size_type index = 0 ); find_last_of1234567size_type find_last_of( const basic_string &amp;str, size_type index = npos );//在字符串中查找最后一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_of( const char *str, size_type index = npos );//在字符串中查找最后一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，最多搜索num个字符。如果没找到就返回string::nopssize_type find_last_of( const char *str, size_type index, size_type num );//在字符串中查找最后一个与ch匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_of( char ch, size_type index = npos ); find_last_not_of1234567size_type find_last_not_of( const basic_string &amp;str, size_type index = npos );//在字符串中查找最后一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_not_of( const char *str, size_type index = npos);//在字符串中查找最后一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始，最多查找num个字符如果没找到就返回string::nopssize_type find_last_not_of( const char *str, size_type index, size_type num );//在字符串中查找最后一个与ch不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_not_of( char ch, size_type index = npos ); 插入(insert)12345678910111213141516//在迭代器i表示的位置前面插入一个字符chiterator insert( iterator i, const char &amp;ch );//在字符串的位置index插入字符串strbasic_string &amp;insert( size_type index, const basic_string &amp;str );//在字符串的位置index插入字符串strbasic_string &amp;insert( size_type index, const char *str );//在字符串的位置index插入字符串str的子串(从index2开始，长num个字符)basic_string &amp;insert( size_type index1, const basic_string &amp;str, size_type index2, size_type num );//在字符串的位置index插入字符串str的num个字符basic_string &amp;insert( size_type index, const char *str, size_type num );//在字符串的位置index插入num个字符ch的拷贝basic_string &amp;insert( size_type index, size_type num, char ch );//在迭代器i表示的位置前面插入num个字符ch的拷贝,void insert( iterator i, size_type num, const char &amp;ch );//在迭代器i表示的位置前面插入一段字符，从start开始，以end结束.void insert( iterator i, iterator start, iterator end ); 长度(length)12size_type length();length()函数返回字符串的长度,这个函数跟size()函数应该差不多 substr()12345basic_string substr( size_type index, size_type num = npos );substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串string str("hello wrold");string a=str.substr();cout&lt;&lt;a;//输出hello wrold 替换(replace)1234567891011121314151617181920212223//用str中的num个字符替换本字符串中的字符,从index开始basic_string &amp;replace( size_type index, size_type num, const basic_string &amp;str );//用str中的num2个字符（从index2开始）替换本字符串中的字符，从index1开始，最多num1个字符basic_string &amp;replace( size_type index1, size_type num1, const basic_string &amp;str, size_type index2,size_type num2 );//用str中的num个字符（从index开始）替换本字符串中的字符basic_string &amp;replace( size_type index, size_type num, const char *str );//用str中的num2个字符（从index2开始）替换本字符串中的字符，从index1开始，num1个字符basic_string &amp;replace( size_type index, size_type num1, const char *str, size_type num2 );//用num2个ch字符替换本字符串中的字符，从index开始basic_string &amp;replace( size_type index, size_type num1, size_type num2, char ch );//用str中的字符替换本字符串中的字符,迭代器start和end指示范围basic_string &amp;replace( iterator start, iterator end, const basic_string &amp;str );//用str中的字符替换本字符串中的字符,迭代器start和end指示范围basic_string &amp;replace( iterator start, iterator end, const char *str );//用str中的num个字符替换本字符串中的内容,迭代器start和end指示范围basic_string &amp;replace( iterator start, iterator end, const char *str, size_type num );//用num个ch字符替换本字符串中的内容，迭代器start和end指示范围.basic_string &amp;replace( iterator start, iterator end, size_type num, char ch ); string str("hello wrold"); str.replace(6,3,"C++"); cout&lt;&lt;str;//输出hello C++ld 保留空间(reserve)12void reserve( size_type num ）reserve()函数设置本字符串的capacity 以保留num个字符空间。 reverse12345逆转元素 void reverse (BidirectionalIterator first, BidirectionalIterator last) string str("123456789"); reverse(str.begin(),str.end()); cout&lt;&lt;str;//输出987654321 clean12清空str的元素str.clear(); 关于string大概就讲这么多…以后再被坑到再接着补充。如果读者想了解更多的话，可以去查看官方文档。今天的总结就到这里吧…..]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六学家的困惑]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%85%AD%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%9B%B0%E6%83%91%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/625/C来源：牛客网题意：给你两个数串，只能从两个数串的头和尾取数，然后请你输出这两个数串能组成的最大的数串….一道水题，当时并没有做出来，很难受，而且当时思路很模糊，是记录数串下标来输出，结果测试用例对了，但是不能AC，不知道哪里错了，看了别人的代码后，恍然大悟，痛感自己实力不足！！！123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std; int main()&#123; //ios::sync_with_stdio(false); int T,cnt=0; string s[4]; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;s[0]&gt;&gt;s[2]; s[1] = s[0]; s[3] = s[2]; reverse(s[1].begin(),s[1].end()); reverse(s[3].begin(),s[3].end()); int n = s[0].size()+s[2].size(); string ans; while(n--)&#123; int id =0; for(int i=0;i&lt;=3;i++) if(s[i]&gt;s[id]) id = i; ans+=s[id][0]; s[id].erase(s[id].begin()); s[id^1].erase(s[id^1].end()-1); &#125; printf("Case #%d: ",++cnt); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 在字符串上面吃了好多次亏了，不行，我要准备写一篇关于字符串的blog才行，不能再在这上面吃亏了！！！]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some tips for input]]></title>
    <url>%2F2019%2F04%2F15%2FSome-tips-for-input%2F</url>
    <content type="text"><![CDATA[Some tips for input 使用scanf和printf函数在C++程序中使用scanf 和printf需要“cstdio”头文件.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//case 1 输入输出整数#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; scanf("%d",&amp;T); printf("%d",T); return 0;&#125;// case 2 输入输出浮点数#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double T; scanf("%lf",&amp;T); printf("%lf",T); //默认输出小数点后六位 //printf（"%.n",T）; 输出小数点后n位 return 0;&#125;// case 3 按格式输入输出#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int year; int month; int day; printf("请输入需要转换的日期："); scanf("%d/%d/%d", &amp;year, &amp;month, &amp;day); // %d中间的/是定义好的分隔符，用户输入的时候会以-为分隔符将值分别赋值给变量 year、month、day // 注：用户输入数据的时候必须按照这种格式来写，否则会出现意想不到的错误 printf("转换后的日期格式为：%d/%d/%d \n", year, month, day);&#125;//对于scanf函数来说，空格、TAB、回车都是无关紧要的。// case 4 输入输出string类型#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a; a.resize(100);//说明string的长度 scanf("%s",&amp;a[0]); printf("%s",a.c_str());//如果写成printf("%s",a);会乱码&#125;//个人比较建议用cin来输入string类型； 使用cin 和 cout 函数 C++中可以使用流简化输入输出操作。 标准输入输出流在头文件iostream中定义，存在于名称空间std中。如果使用了using namespace std语句，则可以直接使用。 cin可以连续从键盘读取想要的数据，以空格、tab或换行作为分隔符1234567891011// case 1#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;&#125;程序输入"Hello World"，将会在下一行输出"Hello World"；其中输入的"Hello"赋值给a，"World"赋值给b，中间的空格就是分隔符。 虽然使用cin很方便，但是它比scanf慢。在某些题上，可能会因为这个cin而吃亏。 解决方法：12//在main函数里添加ios::sync_with_stdio(false); 此时的cin就会比scanf快，那么请问还有没有更快的呢？ 答案是肯定的！ 在看题解的时候，我看见有大佬是这样写的：12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int main()&#123; int a,b; //cin&gt;&gt;a&gt;&gt;b; a=read(); b=read(); cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;&#125; 输入速度大致：read() &lt; 加了ios::sync_with_stdio(false)的cin &lt; scanf() &lt; cin ; 使用文件输入输出先说个最简单的吧—重定向123//只要在main()函数里加入这两句话就可以了。(用于测试，如果比赛采用标准输入输出，就必须在测试完后删除掉。)freopen("data.in","r",stdin);freopen("data.out","w",stdout); 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; freopen("data.in","r",stdin); freopen("data.out","w",stdout); int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d %d",a,b); return 0;&#125;//文件data.in预先留有数据//运行完之后，data.out就会保存程序输出的数据 如果比赛要求用文件输入输出，但是禁止用重定向的方式————fopen123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; FILE*fin,*fout; fin=fopen("data.in","rb"); fout=fopen("data.out","wb"); int a,b; fscanf(fin,"%d%d",&amp;a,&amp;b); fprintf(fout,"%d %d",a,b); fclose(fin); fclose(fout); return 0;&#125;//如果不能用重定向方式读写数据，应使用fopen和fscanf/fprintf进行输入输出. 重定向的方法写起来简单，但是不能同时读写文件和标准输入输出; fopen写法比较繁琐，但可以改成读写标准输入输出，只需&quot;fin=stdin;fout=stdout;&quot;，不调用fopen和fclose; 计时函数clock()1234#include&lt;time.h&gt;int main()&#123; printf("Time used=%.2f\n",(double)clock()/CLOCKS_PER_SEC);&#125;]]></content>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Average distance]]></title>
    <url>%2F2019%2F04%2F14%2FAverage-distance%2F</url>
    <content type="text"><![CDATA[Average distance Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 1830 Accepted Submission(s): 659Special JudgeProblem DescriptionGiven a tree, calculate the average distance between two vertices in the tree. For example, the average distance between two vertices in the following tree is $(d_{01} + d_{02} + d_{03} + d_{04} + d_{12} +d_{13} +d_{14} +d_{23} +d_{24} +d_{34})/10 = (6+3+7+9+9+13+15+10+12+2)/10 = 8.6$. InputOn the first line an integer t (1 &lt;= t &lt;= 100): the number of test cases. Then for each test case:One line with an integer n (2 &lt;= n &lt;= 10 000): the number of nodes in the tree. The nodes are numbered from 0 to n - 1.n - 1 lines, each with three integers a (0 &lt;= a &lt; n), b (0 &lt;= b &lt; n) and d (1 &lt;= d &lt;= 1 000). There is an edge between the nodes with numbers a and b of length d. The resulting graph will be a tree.OutputFor each testcase:One line with the average distance between two vertices. This value should have either an absolute or a relative error of at most $10^{-6}$Sample Input150 1 60 2 30 3 73 4 2Sample Output8.6 引：如果暴力枚举两点再求距离是显然会超时的。转换一下思路，我们可以对每条边，求所有可能的路径经过此边的次数：设这条边两端的点数分别为A和B，那 么这条边被经过的次数就是AB，它对总的距离和的贡献就是(AB此边长度)。我们把所有边的贡献求总和，再除以总路径数N(N-1)/2，即为最 后所求。下面是AC的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;int T;int n;struct Node&#123; int value; int point;&#125;;double ans[10000+5];double sum[10000+5];vector&lt;Node&gt; node[10000+5];void dfs(int son,int father)&#123; sum[son]=1; for(int i=0;i&lt;node[son].size();i++)&#123; int p=node[son][i].point; int v=node[son][i].value; if(p==father)&#123;continue;&#125; dfs(p,son); sum[son]+=sum[p]; ans[son]+=ans[p]+sum[p]*(n-sum[p])*v; &#125;&#125;void solve()&#123; scanf("%d",&amp;n); int a,b,d; for(int i=0;i&lt;n;i++)&#123; node[i].clear(); &#125; memset(ans,0,sizeof(ans)); memset(sum,0,sizeof(sum)); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;d); Node temp; temp.point=b; temp.value=d; node[a].push_back(temp); temp.point=a; node[b].push_back(temp); &#125; dfs(0,-1); double number=n*(n-1)/2; //cout&lt;&lt;ans[0]/number&lt;&lt;endl; printf("%.7f\n",ans[0]/number);&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
