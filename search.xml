<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Round #590 (Div. 3)]]></title>
    <url>%2F2019%2F11%2F26%2FCodeforces-Round-590-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #590 (Div. 3) A. Equalize Prices Again1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int q;int n;int a[105]; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;n); int sum=0; int ans=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); sum+=a[i]; &#125; if(sum%n==0) ans=sum/n; else ans=sum/n+1; printf("%d\n",ans); &#125; return 0; B1. Social Network (easy version) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int n,k;map&lt;int ,int &gt; mp;int ans[MAX_N];int main()&#123; scanf("%d%d",&amp;n,&amp;k); int id; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;id); if(mp[id]==0)&#123; mp[id]=1; ans[cnt]=id; if(cnt&gt;=k)&#123; mp[ans[cnt-k]]=0; &#125; cnt++; &#125; &#125; if(cnt&lt;=k)&#123; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; printf("%d%c",ans[i],i==0 ? '\n':' '); &#125; &#125; else&#123; printf("%d\n",k); for(int i=cnt-1;i&gt;=cnt-k;i--)&#123; printf("%d%c",ans[i],i==cnt-k ? '\n':' '); &#125; &#125; return 0;&#125; B2. Social Network (hard version) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int n,k;map&lt;int ,int &gt; mp;int ans[MAX_N];int main()&#123; scanf("%d%d",&amp;n,&amp;k); int id; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;id); if(mp[id]==0)&#123; mp[id]=1; ans[cnt]=id; if(cnt&gt;=k)&#123; mp[ans[cnt-k]]=0; &#125; cnt++; &#125; &#125; if(cnt&lt;=k)&#123; printf("%d\n",cnt); for(int i=cnt-1;i&gt;=0;i--)&#123; printf("%d%c",ans[i],i==0 ? '\n':' '); &#125; &#125; else&#123; printf("%d\n",k); for(int i=cnt-1;i&gt;=cnt-k;i--)&#123; printf("%d%c",ans[i],i==cnt-k ? '\n':' '); &#125; &#125; return 0;&#125; C. Pipes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int q;int n;int a[2][MAX_N];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; bool flag=0; scanf("%d",&amp;n); int temp; for(int i=0;i&lt;2;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf("%1d",&amp;temp); if(temp==1||temp==2) a[i][j]=1; else a[i][j]=3; &#125; &#125; int pos=0; int cnt=0; for(int i=1;i&lt;=n;i++)&#123; if(a[pos][i]==1)&#123; cnt++; &#125; else if(a[pos][i]==3&amp;&amp;a[pos^1][i]==3)&#123; cnt++; pos=pos^1; &#125; &#125; if(cnt==n&amp;&amp;pos==1) flag=1; if(flag) puts("YES"); else puts("NO"); &#125; return 0;&#125; D. Distinct Characters Queries1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;const long N = 200000; int q;int n;string s;int tree[MAX_N][30];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int k,int cnt)&#123; while(x&lt;=n)&#123; tree[x][cnt]+=k; x+=lowbit(x); &#125;&#125;int sum(int x,int cnt)&#123; int res=0; while(x&gt;0)&#123; res+=tree[x][cnt]; x-=lowbit(x); &#125; return res;&#125;int main()&#123; string s; cin&gt;&gt;s; n=s.size(); for(int i=0;i&lt;n;i++)&#123; add(i+1,1,s[i]-'a'); &#125; int q; scanf("%d",&amp;q); while(q--)&#123; int op; scanf("%d",&amp;op); if(op==1)&#123; int pos; char c; scanf("%d",&amp;pos); scanf(" %c",&amp;c); add(pos,-1,s[pos-1]-'a'); s[pos-1]=c; add(pos,1,c-'a'); &#125; else&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int ans=0; for(int i=0;i&lt;26;i++)&#123; if((sum(r,i)-sum(l-1,i))&gt;0)&#123; ans++; &#125; &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125; E. Special Permutations 参考：blog 12345678910111213141516171819202122232425262728293031323334353637//差分数组#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int n,m;ll a[MAX_N];ll ans[MAX_N];void up(ll l,ll r,ll v)&#123; ans[l]+=v; ans[r+1]-=v;&#125; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;m;i++)&#123; ll l=a[i],r=a[i+1]; if(l&gt;r) swap(l,r); if(l!=r)&#123; up(1,l-1,r-l); up(l,l,r-1); up(l+1,r-1,r-l-1); up(r,r,l); up(r+1,n,r-l); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i!=n)printf("%lld ",ans[i]+=ans[i-1]); else printf("%lld\n",ans[i]+=ans[i-1]); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//暴力#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;int n,m;int a[MAX_N],p[MAX_N];ll ans;vector&lt;int&gt; pos[MAX_N]; int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) p[i]=i; for(int i=1;i&lt;=m;i++) &#123; scanf("%d",&amp;a[i]); pos[a[i]].push_back(i); &#125; for(int i=1;i&lt;=m-1;i++)&#123; ans+=abs(a[i]-a[i+1]); &#125; printf("%lld ",ans); for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;pos[i].size();j++)&#123; int k=pos[i][j]; if(k&gt;1) ans-=abs(i-p[a[k-1]]); if(k&lt;m) ans-=abs(i-p[a[k+1]]); &#125; for(int j=0;j&lt;pos[i-1].size();j++)&#123; int k=pos[i-1][j]; if(k&gt;1&amp;&amp;a[k-1]!=i) ans-=abs(1-p[a[k-1]]); if(k&lt;m&amp;&amp;a[k+1]!=i) ans-=abs(1-p[a[k+1]]); &#125; p[i]=1; p[i-1]=i; for(int j=0;j&lt;pos[i].size();j++)&#123; int k=pos[i][j]; if(k&gt;1) ans+=abs(1-p[a[k-1]]); if(k&lt;m) ans+=abs(1-p[a[k+1]]); &#125; for(int j=0;j&lt;pos[i-1].size();j++)&#123; int k=pos[i-1][j]; if(k&gt;1&amp;&amp;a[k-1]!=i) ans+=abs(i-p[a[k-1]]); if(k&lt;m&amp;&amp;a[k+1]!=i) ans+=abs(i-p[a[k+1]]); &#125; if(i==n) printf("%lld",ans); else printf("%lld ",ans); &#125; return 0;&#125; F. Yet Another Substring Reverse参考：blog12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const int INF=0x3f3f3f3f;char s[MAX_N];int dp[1&lt;&lt;(20)]; bool vis[20];int main()&#123; scanf("%s",s); int n=strlen(s); for(int i=0;i&lt;n;i++)&#123; //枚举该字符串的所有集合 memset(vis,0,sizeof(vis)); int mask=0,cnt=0; for(int j=i;j&lt;n;j++)&#123; int v=s[j]-'a'; if(vis[v]) break; else vis[v]=1; mask |=(1&lt;&lt;v); cnt++; dp[mask]=cnt; &#125; &#125; for(int i=0;i&lt;(1&lt;&lt;20);i++)&#123; //计算一个集合所有子集的最大值 for(int j=0;j&lt;20;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; dp[i]=max(dp[i],dp[i^(1&lt;&lt;j)]); &#125; &#125; &#125; int ans=0; for(int i=0;i&lt; (1&lt;&lt;20);i++)&#123; //求最优解 ans=max(ans,dp[i]+dp[i^((1&lt;&lt;20)-1)]); &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #598 (Div. 3)]]></title>
    <url>%2F2019%2F11%2F24%2FCodeforces-Round-598-Div-3%2F</url>
    <content type="text"><![CDATA[Codeforces Round #598 (Div. 3) A. Payment Without Change123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;int q;ll a,n,b,s; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;n,&amp;s); bool flag=1; if(a*n+b&lt;s) &#123; flag=0; &#125; else&#123; if(s%n&gt;b)&#123; flag=0; &#125; &#125; if(flag) puts("YES"); else puts("NO"); &#125; return 0;&#125; B. Minimize the Permutation1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e5+5;const long N = 200000; int q;int n; int a[105];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; int pos=0; int last=0; while(last&lt;n)&#123; int min=1000000; for(int i=pos+1;i&lt;=n;i++)&#123; if(min&gt;a[i])&#123; min=a[i]; pos=i; &#125; &#125; for(int i=pos;i&gt;last;i--)&#123; if(a[i-1]&gt;a[i])&#123; swap(a[i-1],a[i]); &#125; &#125; last=pos; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",a[i],i==n ? '\n':' '); &#125; &#125; return 0;&#125; C. Platforms Jumping 参考：blog 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const long N = 200000; int n,m,d;int c[1005];int ans[1005];int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;d); int max_len=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;c[i]); max_len+=c[i]; &#125; if((max_len+d*(m+1)-m)&lt;n+1)&#123; puts("NO"); return 0; &#125; puts("YES"); int pos=0; for(int i=1;i&lt;=m;i++)&#123; if(pos+d+max_len&lt;=n) pos+=d; else pos=n+1-max_len; for(int j=pos;j&lt;=pos+c[i]-1;j++)&#123; ans[j]=i; &#125; pos+=c[i]-1; max_len-=c[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i], i==n ? '\n':' '); &#125; return 0;&#125; D. Binary String Minimizing12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;const long N = 200000; int q;ll n,k;int a[MAX_N];int main()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%lld%lld",&amp;n,&amp;k); char c; int len=0; for(int i=1;i&lt;=n;i++)&#123; scanf(" %c",&amp;c); if(c=='0')&#123; a[++len]=i; &#125; &#125; for(int i=1;i&lt;=len&amp;&amp;k;i++)&#123; if(k&gt;=(a[i]-i))&#123; k=k-(a[i]-i); a[i]=i; &#125; else&#123; a[i]=a[i]-k; k=0; break; &#125; &#125; int cnt=1; for(int i=1;i&lt;=n;i++)&#123; if(i==a[cnt]&amp;&amp;cnt&lt;=len) &#123; printf("0"); cnt++; &#125; else printf("1"); &#125; printf("\n"); &#125; return 0;&#125; E. Yet Another Division Into Teams 参考:blog123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const int INF=0x3f3f3f3f;pair&lt;int,int &gt; a[MAX_N];int dp[MAX_N],p[MAX_N];int ans[MAX_N];int root,cnt;int n;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].first); a[i].second=i; &#125; sort(a+1,a+1+n); memset(dp,INF,sizeof(dp)); dp[1]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=2;j&lt;=4&amp;&amp;i+j&lt;=n;j++)&#123; int temp=a[i+j].first-a[i].first; if(dp[i+j+1]&gt;dp[i]+temp)&#123; dp[i+j+1]=dp[i]+temp; p[i+j+1]=i; &#125; &#125; &#125; root=n+1; cnt=1; while(root!=1)&#123; for(int i=root-1;i&gt;=p[root];i--)&#123; ans[a[i].second]=cnt; &#125; cnt++; root=p[root]; &#125; printf("%d %d\n",dp[n+1],cnt-1); for(int i=1;i&lt;=n;i++)&#123; printf("%d%c",ans[i],i==n ? '\n' :' '); &#125; return 0;&#125; F. Equalizing Two Strings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;const long N = 200000; int q;int n;char s[MAX_N];int s_vis[30]; char t[MAX_N];int t_vis[30]; int main()&#123; scanf("%d",&amp;q); while(q--)&#123; memset(s_vis,0,sizeof(s_vis)); memset(t_vis,0,sizeof(t_vis)); scanf("%d",&amp;n); scanf("%s",s); scanf("%s",t); bool flag=0; for(int i=0;i&lt;n;i++)&#123; s_vis[s[i]-'a']++; t_vis[t[i]-'a']++; &#125; bool flag1=0; for(int i=0;i&lt;26;i++)&#123; if(s_vis[i]!=t_vis[i]) &#123; flag1=1; break; &#125; &#125; if(flag1) &#123; puts("NO"); continue; &#125; for(int i=0;i&lt;26;i++)&#123; if(s_vis[i]&gt;=2||t_vis[i]&gt;=2)&#123; flag=1; break; &#125; &#125; if(flag)&#123; puts("YES"); continue; &#125; else&#123; int num1=0; int num2=0; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(s[i]&gt;s[j])&#123; num1++; &#125; if(t[i]&gt;t[j])&#123; num2++; &#125; &#125; &#125; if((num1&amp;1)==(num2&amp;1))puts("YES"); else puts("NO"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AC自动机]]></title>
    <url>%2F2019%2F10%2F28%2FAC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Trie+Kmp=AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=1e6+5;struct Trie&#123; int fail; int vis[30]; int tail;&#125;tree[MAX_N];int cnt=0;inline void Build(string s) //用所有子串建立字典树&#123; int l=s.length(); int now=0; for(int i=0;i&lt;l;i++) &#123; if(tree[now].vis[s[i]-'a']==0)&#123; tree[now].vis[s[i]-'a']=++cnt; &#125; now=tree[now].vis[s[i]-'a']; &#125; tree[now].tail+=1;&#125;void Get_fail()&#123; //用BFS求失配指针 queue&lt;int&gt; que; for(int i=0;i&lt;26;i++)&#123; if(tree[0].vis[i]!=0)&#123; tree[tree[0].vis[i]].fail=0; que.push(tree[0].vis[i]); &#125; &#125; while(que.size())&#123; int u=que.front(); que.pop(); for(int i=0;i&lt;26;i++)&#123; if(tree[u].vis[i]!=0)&#123; tree[tree[u].vis[i]].fail=tree[tree[u].fail].vis[i]; que.push(tree[u].vis[i]); &#125; else&#123; tree[u].vis[i]=tree[tree[u].fail].vis[i]; &#125; &#125; &#125;&#125;int query(string s)&#123; //查询 int l=s.length(); int now=0,ans=0; for(int i=0;i&lt;l;i++)&#123; now=tree[now].vis[s[i]-'a']; for(int t=now;t&amp;&amp;tree[t].tail!=-1;t=tree[t].fail)&#123; ans+=tree[t].tail; tree[t].tail=-1; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int n; string s; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;s; Build(s); &#125; tree[0].fail=0; Get_fail(); cin&gt;&gt;s; cout&lt;&lt;query(s)&lt;&lt;endl; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆元]]></title>
    <url>%2F2019%2F10%2F24%2F%E9%80%86%E5%85%83%2F</url>
    <content type="text"><![CDATA[逆元素是指一个可以取消另一给定元素运算的元素，在数学里，逆元素广义化了加法中的加法逆元和乘法中的倒数传送门 若$a*x \equiv1 \pmod {b}$，且a与b互质，那么我们就能定义: x 为 a 的逆元，记为$a^{-1}$ 有三种方法可以求逆元： 扩展GCD1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=2e5+5;int a,p;void Exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (!b) x = 1, y = 0; else Exgcd(b, a % b, y, x), y -= a / b * x;&#125;int main()&#123; ll x, y; scanf("%d%d",&amp;a,&amp;p); Exgcd (a, p, x, y); x = (x % p + p) % p; printf ("%d\n", x); //x是a在mod p下的逆元 return 0;&#125; 费马小定理12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p,n;ll mod_pow(ll x,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;p); for(int i=1;i&lt;=n;i++) &#123; if(i==1) printf("1\n"); else printf("%d\n",mod_pow(i,p-2,p)); &#125; return 0;&#125; 线性递推123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAX_N=3e6+5;ll p;ll n;int a[MAX_N];int main()&#123; scanf("%lld%lld",&amp;n,&amp;p); a[1]=1; for(int i=1;i&lt;=n;i++) &#123; if(i!=1)a[i]=(p-p/i)*a[p%i]%p; printf("%d\n",a[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lucas定理]]></title>
    <url>%2F2019%2F10%2F24%2FLucas%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[Lucas定理一句话说就是Lucas(m,n,p) = C$\tbinom{m/p}{n/p}$ * Lucas(m%p,n%p,p) 传送门 就是一道Lucas模板题 $C^m_n$ =${n!1/m!1/(n-m)!}$,而$1/m!$的逆元就是$m!$. 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll p;ll a[100000+5];int T;ll mod_pow(ll x,ll n,ll mod)&#123; //快速幂 ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;ll C(ll n,ll m)&#123; //逆元求组合数 if(m&gt;n) return 0; return (a[n]*mod_pow(a[m],p-2,p))%p*mod_pow(a[n-m],p-2,p)%p;&#125;ll Lucas(ll n,ll m) //Lucas定理&#123; if(!m) return 1; else return C(n%p,m%p)*Lucas(n/p,m/p)%p;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; ll n,m; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;p); a[0]=1; for(int i=1;i&lt;=p;i++) a[i]=(a[i-1]*i)%p; //求i的阶乘. printf("%lld\n",Lucas(n+m,m)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[践踏]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%B7%B5%E8%B8%8F%2F</url>
    <content type="text"><![CDATA[题意：1操作 加一条线段2操作 删一条线段3查询 有多少条线段满足x+kt（t是整数）传送门 考虑在模k意义下，每条线段都是1到2个区间，如果这条线段的长度大于k的话，那么区间[0，k-1]就满足题意。树状数组维护区间和，单点查询即可。当k=0的时候，则判断有多少个线段经过某个点，离散化，树状数组维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+5;const int MOD=1e9+7;typedef long long ll;int tree[MAXN],up;vector&lt;int&gt; vec;pair&lt;pair&lt;int,int&gt;,int&gt; a[MAXN];int T;void add(int x,int a)&#123; while(x&lt;=up) tree[x]+=a,x+=x&amp;(-x);&#125;int sum(int x)&#123; int res=0; while(x) res+=tree[x],x-=x&amp;(-x); return res;&#125;int main()&#123; int n,k,op,l,r; scanf("%d%d",&amp;n,&amp;k); if(n==0) &#123; printf("fafa\n"); return 0; &#125; if(k) &#123; up=k; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;op); if(op==1) &#123; scanf("%d%d",&amp;l,&amp;r); if(r-l+1&gt;=k) &#123; add(1,1); //[1,k-1] add(k+1,-1); continue; &#125; l=(l%k)+1; r=(r%k)+1; if(l&lt;=r) &#123;add(l,1); add(r+1,-1);&#125; //一条线段[l,r] else &#123; add(1,1); //两条线段[1,r]和[l,k+1] add(r+1,-1); add(l,1); add(k+1,-1); &#125; &#125; else if(op==2) //删除线段则是添加的逆操作 &#123; scanf("%d%d",&amp;l,&amp;r); if(r-l+1&gt;=k) &#123; add(1,-1); add(k+1,1); continue; &#125; l=(l%k)+1; r=(r%k)+1; if(l&lt;=r)&#123; add(l,-1); add(r+1,1); &#125; else &#123; add(1,-1); add(r+1,1); add(l,-1); add(k+1,1); &#125; &#125; else &#123; scanf("%d",&amp;l); printf("%d\n",sum(l%k+1)); &#125; &#125; &#125; else&#123; up=2*n; for(int i=1;i&lt;=n;i++) &#123; scanf("%d%d",&amp;a[i].second,&amp;a[i].first.first); vec.push_back(a[i].first.first); if(a[i].second&lt;=2) &#123; scanf("%d",&amp;a[i].first.second); vec.push_back(a[i].first.second); &#125; &#125; sort(vec.begin(),vec.end()); vec.erase(unique(vec.begin(),vec.end()),vec.end()); //离散化 for(int i=1;i&lt;=n;i++) &#123; if(a[i].second==1) //离散化后，二分查询所需l,r &#123; l=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+1; r=lower_bound(vec.begin(),vec.end(),a[i].first.second)-vec.begin()+1; add(l,1); add(r+1,-1); &#125; else if(a[i].second==2) &#123; l=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+1; r=lower_bound(vec.begin(),vec.end(),a[i].first.second)-vec.begin()+1; add(l,-1); add(r+1,1); &#125; else&#123; int x=lower_bound(vec.begin(),vec.end(),a[i].first.first)-vec.begin()+1; printf("%d\n",sum(x)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VVQ与线段]]></title>
    <url>%2F2019%2F10%2F15%2FVVQ%E4%B8%8E%E7%BA%BF%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[题意：求任意两条线段的异或最大值。定义线段的异或值为它们并的长度减他们交的长度 传送门题解：有两种情况1：线段a内部包含线段b 贡献：(a.r-a.l)-(b.r-b.l);2.线段a与线段b相交 贡献：(a.r+b.l-b.l-b.r);先根据l进行排序，然后计算贡献即可. 线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn= 200005;const int INF=0x3fffffff;int Max[maxn&lt;&lt;2],Min[maxn&lt;&lt;2];struct node&#123; int l,r; friend bool operator &lt;(const node &amp;a,const node &amp;b) &#123; return a.l&lt;b.l; &#125; &#125;a[maxn];bool cmp(node a,node b)&#123; return a.l&lt;b.l;&#125; void build(int p,int l,int r)&#123; if(l==r) &#123; Max[p]=a[l].l+a[l].r; Min[p]=a[l].r-a[l].l; return ; &#125; int mid=(l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r); Max[p]=max(Max[p*2],Max[p*2+1]); Min[p]=min(Min[p*2],Min[p*2+1]); &#125;int Quary_Max(int l,int r,int p,int x,int y)&#123; if(l&gt;y||r&lt;x)return 0; if(l&gt;=x&amp;&amp;r&lt;=y)return Max[p]; int mid=(l+r)&gt;&gt;1; return max(Quary_Max(l,mid,p*2,x,y),Quary_Max(mid+1,r,p*2+1,x,y));&#125; int Quary_Min(int l,int r,int root,int x,int y)&#123; if(l&gt;y||r&lt;x)return INF; if(l&gt;=x&amp;&amp;r&lt;=y)return Min[root]; int mid=(l+r)&gt;&gt;1; return min(Quary_Min(l,mid,root*2,x,y),Quary_Min(mid+1,r,root*2+1,x,y));&#125;int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;a[i].l,&amp;a[i].r); sort(a+1,a+1+n,cmp); build(1,1,n); int ans=0; node tmp; tmp.r=0; int l,r; for(int i=1;i&lt;=n;i++) &#123; tmp.l=a[i].l; l=lower_bound(a+1,a+1+n,tmp)-a; //找到a[j].l&gt;=a[i].l的第一个j tmp.l=a[i].r; r=upper_bound(a+1,a+1+n,tmp)-a-1; //找到a[j].l&lt;=a[i].r的最后一个j if(l&gt;r)continue; //这样就找到左端点在线段i范围内的所有线段 ans=max(ans,Quary_Max(1,n,1,l,r)-a[i].r-a[i].l); ans=max(ans,a[i].r-a[i].l-Quary_Min(1,n,1,l,r)); &#125; printf("%d\n",ans); return 0;&#125;/*31 104 115 683 10 100 1 50 50 10099*/]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计颜色]]></title>
    <url>%2F2019%2F10%2F15%2F%E7%BB%9F%E8%AE%A1%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题意：n个桶按顺序排列，我们用1~n给桶标号。有两种操作：1 l r c 区间[l,r]中的每个桶中都放入一个颜色为c的球 (1≤l,r ≤n,l≤r,0≤c≤60)2 l r 查询区间[l,r]的桶中有多少种不同颜色的球 (1≤l,r ≤n,l≤r) 用long long的不同位来表示不同颜色。区间合并用’|’(或)即可，update区间时就用 1&lt;&lt;c 的值来update. 传送门1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;ll tree[MAX_N&lt;&lt;2];ll tag[MAX_N&lt;&lt;2];ll N,M;ll lc(ll x) &#123;return x&lt;&lt;1;&#125;ll rc(ll x) &#123;return x&lt;&lt;1|1;&#125;int getans(ll x)&#123; int ans=0; while(x) &#123; ans+=x&amp;1; x&gt;&gt;=1; &#125; return ans;&#125;void push_up(ll p)&#123; tree[p]=tree[lc(p)]|tree[rc(p)];&#125;void fun(ll p,ll l,ll r,ll k)&#123; tag[p]=tag[p]|k; tree[p]=tree[p]|k;&#125;void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; fun(lc(p),l,mid,tag[p]); fun(rc(p),mid+1,r,tag[p]); tag[p]=0;&#125;ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) return tree[p]; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)res=res|query(nl,nr,lc(p),l,mid); if(nr&gt;mid) res=res|query(nl,nr,rc(p),mid+1,r); return res;&#125;void update(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tag[p]=tag[p]|k; tree[p]=tree[p]|k; return; &#125; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k); if(nr&gt;mid)update(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;int main() &#123; while(scanf("%lld%lld",&amp;N,&amp;M)!=EOF) &#123; memset(tree,0,sizeof(tree)); memset(tag,0,sizeof(tag)); while(M--) &#123; ll b; scanf("%lld",&amp;b); if(b==1) &#123; ll x,y,z; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); ll temp=pow(2,z); update(x,y,1,1,N,temp); &#125; else &#123; ll x,y; scanf("%lld%lld",&amp;x,&amp;y); printf("%d\n",getans(query(x,y,1,1,N))); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sum]]></title>
    <url>%2F2019%2F10%2F15%2FSum%2F</url>
    <content type="text"><![CDATA[题意：考虑维护一个这样的问题：（1） 给出一个数组A，标号为1~n（2） 修改数组中的一个位置。（3） 询问区间[l,r]中所有子集的位运算and之和mod($10^9$+7)。传送门题解：按位建立线段树,每一颗线段树维护每一位从1到n的区间和。第p位的值为a,则贡献为：$2^p$*($2^a$-1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD=1e9+7;const int MAX_N=1e5+5;int a[MAX_N];int tree[MAX_N&lt;&lt;2][32];int cnt[32];ll mod_pow(ll x,ll n)&#123; ll res=1; while(n) &#123; if(n&amp;1) res=res*x%MOD; x=x*x%MOD; n&gt;&gt;=1; &#125; return res%MOD;&#125;int lc(int x)&#123;return x&lt;&lt;1;&#125;int rc(int x)&#123;return x&lt;&lt;1|1;&#125;void push_up(int p,int t)&#123; tree[p][t]=(tree[lc(p)][t]+tree[rc(p)][t])%MOD;&#125;void build(int p,int l,int r)&#123; if(l==r) &#123; for(int i=0;i&lt;32;i++) &#123; tree[p][i]=(a[l]&gt;&gt;i)&amp;1; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); build(rc(p),mid+1,r); for(int i=0;i&lt;32;i++) push_up(p,i);&#125;void query(int nl,int nr,int p,int l ,int r)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; for(int i=0;i&lt;32;i++) &#123; cnt[i]=(cnt[i]+tree[p][i])%MOD; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) query(nl,nr,lc(p),l,mid); if(mid&lt;nr) query(nl,nr,rc(p),mid+1,r);&#125;void update(int nl,int nr,int p,int l ,int r,int k )&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; a[l]=k; for(int i=0;i&lt;32;i++) &#123; tree[p][i]=(a[l]&gt;&gt;i)&amp;1; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) update(nl,nr,lc(p),l,mid,k); if(mid&lt;nr) update(nl,nr,rc(p),mid+1,r,k); for(int i=0;i&lt;32;i++) push_up(p,i);&#125;int main()&#123; int n;scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); build(1,1,n); int m; scanf("%d",&amp;m); while(m--) &#123; int b; scanf("%d",&amp;b); if(b==1)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); update(x,x,1,1,n,y); &#125; else&#123; memset(cnt,0,sizeof(cnt)); int l,r; scanf("%d%d",&amp;l,&amp;r); query(l,r,1,1,n); ll ans=0; for(int i=0;i&lt;32;i++) &#123; ans=(ans+(((mod_pow(2,cnt[i])-1)%MOD)*(mod_pow(2,i)%MOD))%MOD)%MOD; &#125; printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JLOI2011不等式组]]></title>
    <url>%2F2019%2F10%2F15%2FJLOI2011-%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题意：1操作插入不等式，2操作删除第i条不等式，3操作查询当x=k时，求满足条件的不等式数量.传送门 题解：按a的正负划分情况。1.a&gt;0, x&gt;向上取整的(c-b)/a,并且x满足${[-10^6 , 10^6]}$2.a=0,若b&gt;c则恒成立3.a]]></content>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树模板线段树是处理符合结合律的高效数据结构；线段树专门处理区间问题的；线段树的每个节点都表示一个区间，当l==r的时候，意味着区间长度为1，也就是表元素；线段是是一颗完全二叉树，即每个节点要么是叶子节点要么就有两个孩子节点。线段树模板题 递归建树：12345678910111213141516171819202122ll lc(ll x) &#123;return x&lt;&lt;1;&#125; //左孩子ll rc(ll x) &#123;return x&lt;&lt;1|1;&#125; //右孩子void push_up(ll p)&#123; tree[p]=tree[lc(p)]+tree[rc(p)]; //这是维护区间和的线段树，维护区间最大最小值的类似； //tree[p]=min(tree[lc(p)],tree[rc(p)]); //维护区间最小值&#125;void build(ll p,ll l,ll r) &#123; tag[p]=0; //tag标记，先不管，下面讲 if(l==r)&#123; tree[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); //递归左子树 build(rc(p),mid+1,r); //递归右子树 push_up(p); //回溯时，维护父节点&#125; 区间修改单点修改是区间修改的子问题，也就是修改区间长度为1的区间。放在一起谈。对于区间修改，我们需要引用一个tag标记；原因：当修改区间的一个元素时，它就需要push_up来更新它的父节点，时间复杂度O(nlogn)，这很低效，当我们引入tag标记时，则可以使区间更新接近O(logn); tag标记当某个区间被修改时，就给这个区间打上标记,当用到这个区间的子区间的时候，我们才从父节点往子节点下传更新值.来看一下代码:123456789101112131415161718192021222324252627void fun(ll p,ll l,ll r,ll k) // p表示该节点，[l,r]表示该节点表示的区间，k表示增量&#123; tag[p]=tag[p]+k; //记录增量 tree[p]=tree[p]+(r-l+1)*k; //更新当前节点的值，因为符合结合律，所以直接可以计算得&#125;void push_down(ll p,ll l,ll r) //下传tag标记&#123; ll mid=(l+r)&gt;&gt;1; fun(lc(p),l,mid,tag[p]); //下传给左孩子 fun(rc(p),mid+1,r,tag[p]); //下传给右孩子 tag[p]=0; //下传完，恢复标记&#125;void update(ll nl,ll nr,ll p,ll l,ll r,ll k) //区间修改，[nl,nr]表示修改的区间，p表示该区间的节点，[l,r]表示该节点表示的区间，k表示增量&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) //当需要修改的区间完全覆盖当前区间，我们就给该区间打上tag标记，并且更新一下该节点的值 &#123; tag[p]+=k; tree[p]+=(r-l+1)*k; return; &#125; if(tag[p]!=0) push_down(p,l,r); //没有完全覆盖则需要继续找，如果当前节点有tag标记，说明它的孩子节点没有被更新，我们要先下放tag标记 ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k); //更新左子树 if(nr&gt;mid)update(nl,nr,rc(p),mid+1,r,k); //更新右子树 push_up(p); //回溯时，维护父节点&#125; 区间查询12345678910ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) return tree[p]; //当查询的区间已经完全包括该区间时，直接return if(tag[p]!=0) push_down(p,l,r); //如果标记不为0,则说明该区间有修改，需要push_down传递给子节点，且需要在递归子节点前！！！ ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)res+=query(nl,nr,lc(p),l,mid); //递归左孩子 if(nr&gt;mid) res+=query(nl,nr,rc(p),mid+1,r); //递归右孩子 return res;&#125; 完整代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e6+5;ll tree[MAX_N&lt;&lt;2]; //线段树的节点，因为从树顶往下建树，所以需要4N的大小；ll a[MAX_N]; //存原数组ll tag[MAX_N&lt;&lt;2]; //标记ll N,M;ll lc(ll x) &#123;return x&lt;&lt;1;&#125; ll rc(ll x) &#123;return x&lt;&lt;1|1;&#125; void push_up(ll p)&#123; tree[p]=tree[lc(p)]+tree[rc(p)]; &#125;void fun(ll p,ll l,ll r,ll k)&#123; tag[p]=tag[p]+k; tree[p]=tree[p]+(r-l+1)*k;&#125;void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; fun(lc(p),l,mid,tag[p]); fun(rc(p),mid+1,r,tag[p]); tag[p]=0;&#125;void build(ll p,ll l,ll r) //递归建树&#123; tag[p]=0; if(l==r)&#123; tree[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); build(rc(p),mid+1,r); push_up(p);&#125;ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) return tree[p]; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)res+=query(nl,nr,lc(p),l,mid); if(nr&gt;mid) res+=query(nl,nr,rc(p),mid+1,r); return res;&#125;void update(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tag[p]+=k; tree[p]+=(r-l+1)*k; return; &#125; if(tag[p]!=0) push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid)update(nl,nr,lc(p),l,mid,k); if(nr&gt;mid)update(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;int main() &#123; scanf("%lld%lld",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++) scanf("%lld",&amp;a[i]); build(1,1,N); while(M--) &#123; ll b; scanf("%lld",&amp;b); if(b==1) &#123; ll x,y,z; scanf("%lld%lld%lld",&amp;x,&amp;y,&amp;z); update(x,y,1,1,N,z); &#125; else &#123; ll x,y; scanf("%lld%lld",&amp;x,&amp;y); printf("%lld\n",query(x,y,1,1,N)); &#125; &#125; return 0;&#125; 线段树模板2:如题，已知一个数列，你需要进行下面三种操作： 1.将某区间每一个数乘上x 2.将某区间每一个数加上x 3.求出某区间每一个数的和传送门设置两个lazytag，一个存加法，一个存乘法 push_down操作的时候，人为的给这两个lazytag规定先后顺序 乘法优先：tree[lc(p)]=(tree[lc(p)]mul[p]+add[p](mid-l+1));tree[rc(p)]=(tree[rc(p)]mul[p]+add[p](r-mid)); 123456789101112131415void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; tree[lc(p)]=(tree[lc(p)]*mul[p]+add[p]*(mid-l+1))%PP; tree[rc(p)]=(tree[rc(p)]*mul[p]+add[p]*(r-mid))%PP; mul[lc(p)]=(mul[lc(p)]*mul[p])%PP; mul[rc(p)]=(mul[rc(p)]*mul[p])%PP; add[lc(p)]=(add[lc(p)]*mul[p]+add[p])%PP; add[rc(p)]=(add[rc(p)]*mul[p]+add[p])%PP; add[p]=0; mul[p]=1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;ll N,M,PP;ll tree[MAX_N&lt;&lt;2];ll add[MAX_N&lt;&lt;2];ll mul[MAX_N&lt;&lt;2];ll a[MAX_N];ll lc(ll x)&#123;return x&lt;&lt;1;&#125;ll rc(ll x)&#123;return x&lt;&lt;1|1;&#125;void push_up(ll p)&#123; tree[p]=(tree[lc(p)]+tree[rc(p)])%PP;&#125;void build(ll p,ll l,ll r)&#123; add[p]=0; mul[p]=1; if(l==r) &#123; tree[p]=a[l]; return; &#125; ll mid=(l+r)&gt;&gt;1; build(lc(p),l,mid); build(rc(p),mid+1,r); push_up(p);&#125;void push_down(ll p,ll l,ll r)&#123; ll mid=(l+r)&gt;&gt;1; tree[lc(p)]=(tree[lc(p)]*mul[p]+add[p]*(mid-l+1))%PP; tree[rc(p)]=(tree[rc(p)]*mul[p]+add[p]*(r-mid))%PP; mul[lc(p)]=(mul[lc(p)]*mul[p])%PP; mul[rc(p)]=(mul[rc(p)]*mul[p])%PP; add[lc(p)]=(add[lc(p)]*mul[p]+add[p])%PP; add[rc(p)]=(add[rc(p)]*mul[p]+add[p])%PP; add[p]=0; mul[p]=1;&#125;void update1(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tree[p]=(tree[p]*k)%PP; add[p]=(add[p]*k)%PP; mul[p]=(mul[p]*k)%PP; return; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) update1(nl,nr,lc(p),l,mid,k); if(mid&lt;nr) update1(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;void update2(ll nl,ll nr,ll p,ll l,ll r,ll k)&#123; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; tree[p]=(tree[p]+k*(r-l+1))%PP; add[p]=(add[p]+k)%PP; return; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) update2(nl,nr,lc(p),l,mid,k); if(mid&lt;nr) update2(nl,nr,rc(p),mid+1,r,k); push_up(p);&#125;ll query(ll nl,ll nr,ll p,ll l,ll r)&#123; ll res=0; if(nl&lt;=l&amp;&amp;r&lt;=nr) &#123; return tree[p]; &#125; push_down(p,l,r); ll mid=(l+r)&gt;&gt;1; if(nl&lt;=mid) res=(res+query(nl,nr,lc(p),l,mid))%PP; if(mid&lt;nr) res=(res+query(nl,nr,rc(p),mid+1,r))%PP; return res%PP;&#125;int main() &#123; //scanf("%d%d%d",&amp;N,&amp;M,&amp;P); cin&gt;&gt;N&gt;&gt;M&gt;&gt;PP; for(ll i=1;i&lt;=N;i++) cin&gt;&gt;a[i];//scanf("%d",&amp;a[i]); build(1,1,N); while(M--) &#123; ll op,l,r,k; cin&gt;&gt;op&gt;&gt;l&gt;&gt;r; //scanf("%d%d%d",&amp;op,&amp;l,&amp;r); if(op==1) &#123; cin&gt;&gt;k; //scanf("%d",&amp;k); update1(l,r,1,1,N,k); &#125; else if(op==2) &#123; cin&gt;&gt;k; //scanf("%d",&amp;k); update2(l,r,1,1,N,k); &#125; else &#123; ll ans=query(l,r,1,1,N); ans%=PP; // printf("%d\n",ans); cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆序数]]></title>
    <url>%2F2019%2F10%2F08%2F%E9%80%86%E5%BA%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目链接：https://www.luogu.org/problem/P1908题目链接：https://ac.nowcoder.com/acm/problem/15163题意：给n个数，求这n个数的逆序对。（$a_i$&lt;$a_j$&amp;&amp;i&gt;j） 归并排序做法：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=5e5+5;int n;int a[MAX_N];int b[MAX_N];ll ans=0;void mergesort(int s,int t)&#123; if(s&gt;=t) return; int mid=(s+t)&gt;&gt;1; mergesort(s,mid); mergesort(mid+1,t); int i=s;int j=mid+1;int k=s; while(i&lt;=mid&amp;&amp;j&lt;=t)&#123; //合并两个区间 if(a[i]&lt;=a[j]) b[k++]=a[i++]; //满足顺序，直接用b数组存储 else &#123;b[k++]=a[j++]; ans+=mid+1-i;&#125; //当第一个区间的数比第二区间的数大，则它的逆序数为mid+1-i,i为这个数在第一个区间的位置. /*例如:合并左区间4,5,6 和 右区间1,2,3； 对于1来讲它的逆序对就有4,5,6,； 对于2来讲它的逆序对就有5,6; 对于3来讲它的逆序对就有6;*/ &#125; while(i&lt;=mid) b[k++]=a[i++]; while(j&lt;=t) b[k++]=a[j++]; for(int l=s;l&lt;=t;l++) a[l]=b[l];&#125;int main() &#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); mergesort(1,n); printf("%lld\n",ans); return 0;&#125; 树状数组做法：1.首先我们要知道树状数组是可以用来维护前缀和; 2.我们利用桶排的思想来求逆序对数,即遍历数组a,然后用b数组存储a[i]出现的次数(b[a[i]]++)。对于每个a[i]来说，它的逆序数为i-(1~$b_i$)的前缀和；如果直接遍历b的话太慢，所以我们用树状数组来维护前缀和。 3.当n很大的时候，我们不足以开这么大的b数组来存储，于是我们可以对a数组进行离散化，先将a数组排序，然后用1~n来表示a数组的相对大小。 4.要注意出现相同的数的时候，我们要将出现在后面的数排在后面。不然$a_i$=$a_j$ &amp;&amp; i &lt; j的时候，排序可能会让$a_j$排在$a_i$前面，导致处理$a_i$时会将$a_j$误判为逆序对. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=5e5+5;int n;int a[MAX_N];int b[MAX_N];int tree[MAX_N];struct Node&#123; int index; int val; &#125;node[MAX_N]; //用结构体来存储原来的值和位置inline int lowbit(int x) &#123; return x&amp;(-x);&#125;inline bool cmp(Node x,Node y) //排序法则&#123; if(x.val==y.val)return x.index&lt;y.index; else return x.val&lt;y.val;&#125; void add(int i,int x) //给第i位数加x&#123; while(i&lt;=n) &#123; tree[i]+=x; i+=lowbit(i); &#125;&#125; int sum(int i) //求1~i的前缀和&#123; int s=0; while(i&gt;0) &#123; s+=tree[i]; i-=lowbit(i); &#125; return s;&#125;int main() &#123; scanf("%d",&amp;n); ll ans=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",&amp;node[i].val); node[i].index=i; &#125; sort(node+1,node+1+n,cmp); //排序 for(int i=1;i&lt;=n;i++) b[node[i].index]=i; //离散化 for(int i=1;i&lt;=n;i++) &#123; add(b[i],1); ans+=i-sum(b[i]); &#125; printf("%lld\n",ans); return 0;&#125; 后记因为树状数组要排序，复杂度已经O(nlogn)了，还要进行维护树状数组操作，在数比较大的时候会比归并慢。但如果n比较小的情况下，用树状数组做会比较快，不用离散化的情况下。]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>离散化</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物链]]></title>
    <url>%2F2019%2F10%2F05%2F%E9%A3%9F%E7%89%A9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/16884 题意：有N只动物，这些动物属于A、B、C的其中一种；已知A吃B、B吃C、C吃A。接着有K条信息，第一种：x和y是同类；第二种：x吃y。 问有多少条信息是假的？ 思路：对于每只动物i创建3个元素i-A,i-B,i-C，并用3*N个元素建立并查集。维护并查集：第一种：x和y同类： unite(x-A,y-A),unite(x-B,y-B),unite(x-c,y-c);第二种：x吃y： unite(x-A,y-B),unite(x-B,y-C),unite(x-C,y-A);如果出现第i条信息发生冲突 则说明是假话，ans++; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=3e5+5;int par[MAXN];int height[MAXN];int N,K;void init(int n)&#123; for(int i=1;i&lt;=n;i++) &#123; par[i]=i; height[i]=1; &#125;&#125;int Find(int x)&#123; if(par[x]==x) return x; else return par[x]=Find(par[x]);&#125;void unite(int x,int y)&#123; x=Find(x); y=Find(y); if(x==y) return; if(height[x]&lt;height[y]) &#123; par[x]=y; &#125; else &#123; par[y]=x; if(height[x]==height[y]) height[x]++; &#125;&#125;bool same(int x,int y)&#123; return Find(x)==Find(y);&#125;void solve()&#123; init(3*N); int ans=0; int t,x,y; for(int i=1;i&lt;=K;i++) &#123; scanf("%d%d%d",&amp;t,&amp;x,&amp;y); if(x&lt;=0||N&lt;x||y&lt;=0||N&lt;y) &#123;ans++;continue;&#125; if(t==1) &#123; if(same(x,y+N)||same(x,y+2*N)) ans++; else &#123; unite(x,y); unite(x+N,y+N); unite(x+2*N,y+2*N); &#125; &#125; else &#123; if(same(x,y)||same(x,y+2*N)) ans++; else &#123; unite(x,y+N); unite(x+N,y+2*N); unite(x+2*N,y); &#125; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;N,&amp;K); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2010]游戏]]></title>
    <url>%2F2019%2F10%2F05%2FSCOI2010-%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目链接：https://ac.nowcoder.com/acm/problem/20566?&amp;headNav=acm题意：给n个装备，每个装备有两个属性，并且最多只能使用一次。求由这些点的属性能最大匹配到的值。思路：把每个属性看成点，每个装备看成边。然后连接成k个连通块，如果该连通块为树状，则答案只能是k-1；如果连通块为环状，则答案为k。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN=1e6+5;const int MOD=1e8+7;int vis[MAXN]; //记录是否能达到int fa[MAXN]; //记录父节点int n; int fun(int x)&#123; return fa[x]==x ? x : fa[x]=fun(fa[x]);&#125;void unite(int x,int y)&#123; int a=fun(x); int b=fun(y); if(a==b) &#123; vis[a]=1; return ; &#125; if(a&gt;b) swap(a,b); //看见有大佬的交换写法有：x^=y^=x^=y; 将a为小，b为大 vis[a]=1; fa[a]=b; //将小点的父节点为大点&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=1000000;i++) fa[i]=i; for(int i=1;i&lt;=n;i++) &#123; int a,b; scanf("%d%d",&amp;a,&amp;b); unite(a,b); &#125; for(int i=1;i&lt;=n;i++) &#123; if(!vis[i]) &#123; printf("%d\n",i-1); break; &#125; if(i==n&amp;&amp;vis[i]) &#123; printf("%d\n",i); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valentine's Day]]></title>
    <url>%2F2019%2F09%2F29%2FValentine-s-Day%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6693 题意：给n个礼物让女朋友开心的概率，女朋友只能开心一次。求送多少件礼物让女朋友开心的概率最大？ 思路：贪心去概率大的礼物，对于第i件物品，该物品开心的概率为P[i],能让女朋友开心的概率为win（1-P[i]）+loseP[i];然后就遍历所有礼物，当win变小的时候可以提前退出。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;const int MOD=100003;int T;int n;double P[10000+5];bool cmp(double a,double b) &#123;return a&gt;b;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf",&amp;P[i]); &#125; sort(P+1,P+1+n,cmp); double win=P[1]; double lose=1-P[1]; for(int i=2;i&lt;=n;i++) &#123; double temp=P[i]*lose+(1-P[i])*win; if(temp&lt;=win) break; else &#123; win=temp; lose*=1-P[i]; &#125; &#125; printf("%.12lf\n",win); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block Breaker]]></title>
    <url>%2F2019%2F09%2F29%2FBlock-Breaker%2F</url>
    <content type="text"><![CDATA[题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=6699 题意：给n*m矩阵，外围包着层墙，q次操作，每次操作击落(x,y)的方块，一个方块掉落可能会影响到附近的方块掉落，如果方块的上下或者左右夹不住该方块，则该方块掉落。DFS就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e5+5;const int MOD=100003;int T;int n,m,q;int x,y;bool vis[2005][2005];int dx[4]=&#123;1,0,-1,0&#125;;int dy[4]=&#123;0,1,0,-1&#125;;int dfs(int x,int y,int z)&#123; int temp=0; if(z==0) &#123; if(!vis[x][y])temp++; vis[x][y]=1; for(int i=0;i&lt;4;i++) &#123; int nx=x+dx[i]; int ny=y+dy[i]; if(nx&gt;0&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny]) &#123; temp+=dfs(nx,ny,1); &#125; &#125; &#125; else&#123; if((!vis[x-1][y]&amp;&amp;!vis[x+1][y])||(!vis[x][y+1]&amp;&amp;!vis[x][y-1])&amp;&amp;z==1) &#123; return 0; &#125; else &#123; if(!vis[x][y]) temp++; vis[x][y]=1; for(int i=0;i&lt;4;i++) &#123; int nx=x+dx[i]; int ny=y+dy[i]; if(nx&gt;0&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=m&amp;&amp;!vis[nx][ny]) &#123; temp+=dfs(nx,ny,1); &#125; &#125; &#125; &#125; return temp;&#125;int main()&#123; scanf("%d",&amp;T); while(T--) &#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); memset(vis,0,sizeof(vis)); while(q--) &#123; scanf("%d%d",&amp;x,&amp;y); int temp=0; if(!vis[x][y]) &#123;vis[x][y]=1;temp++;&#125; printf("%d\n",dfs(x,y,0)+temp); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haybale Feast]]></title>
    <url>%2F2019%2F09%2F27%2FHaybale-Feast%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/625/C来源：牛客网 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+5;const int INF=0x3f3f3f3f;typedef long long ll;int n;ll m;int f[maxn];int s[maxn];int p[maxn];int head=1,tail=0;int ind=1;int main()&#123; //freopen("data.in","r",stdin); scanf("%d%lld",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;f[i],&amp;s[i]); ll sum=0; ll ans=INF; for(int i=1;i&lt;=n;i++) &#123; sum+=f[i]; while(ind&lt;=i&amp;&amp;sum-f[ind]&gt;=m)&#123; sum-=f[ind]; ind++; //找到满足条件的ind位置 &#125; while(head&lt;=tail&amp;&amp;p[head]&lt;ind) head++; //当队首的位置小于ind位置，队首出队 while(head&lt;=tail&amp;&amp;s[p[tail]]&lt;=s[i]) tail--; //当 当前元素大于队尾，出队 p[++tail]=i; //入队 if(sum&gt;=m) ans=min(ans,(ll)s[p[head]]); //当满足条件时，求最优解 &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>牛客网</tag>
        <tag>单调队列</tag>
        <tag>尺取法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2009]生日礼物]]></title>
    <url>%2F2019%2F09%2F26%2FSCOI2009-%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/problem/20565?&amp;headNav=acm 思路：先排序，然后该种类没入队的入队，如果全部种类没满且前面出现过这个种类，就更新该种类的坐标；如果全部种类满了就求解当前长度。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e6+5;const int INF=0x3f3f3f3f;typedef long long ll;int n,k;struct light&#123; int x; int type;&#125;;light a[maxn];int vis[100];int tt[maxn];bool cmp(light y,light z)&#123; return y.x&lt;z.x;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;k); int num=0; int xx; int cnt=0; for(int i=1;i&lt;=k;i++) &#123; scanf("%d",&amp;num); for(int j=1;j&lt;=num;j++) &#123; scanf("%d",&amp;xx); a[++cnt].x=xx; a[cnt].type=i; &#125; &#125; sort(a+1,a+1+n,cmp); int sum=0; int ans=INF; int head=1,tail=1; while(tail&lt;=n) &#123; if(vis[a[tail].type]==0) sum++; vis[a[tail].type]=a[tail].x; while(head&lt;=tail&amp;&amp;a[head].x!=vis[a[head].type]) head++; if(sum==k) ans=min(ans,a[tail].x-a[head].x); tail++; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Neat Tree]]></title>
    <url>%2F2019%2F09%2F24%2FNeat%20Tree%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/problem/15815?&amp;headNav=acm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e6+5;const int mod=100003;int n;int a[MAX_N];stack&lt;int&gt; sta;int l[MAX_N];int r[MAX_N];int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; ll ans=0; for(int i=1;i&lt;=n;i++) &#123; scanf("%d",a+i); &#125; for(int i=1;i&lt;=n;i++) &#123; while(sta.size()&amp;&amp;a[sta.top()]&gt;a[i]) sta.pop(); //注意这里的"&gt;"号不是&gt;= l[i]=sta.empty()?1:sta.top()+1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=n;i&gt;=1;i--) &#123; while(sta.size()&amp;&amp;a[sta.top()]&gt;=a[i]) sta.pop(); //这里是"&gt;="，避免前后两个区间重合。 r[i]=sta.empty()?n:sta.top()-1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=1;i&lt;=n;i++) &#123; ans-=(ll)a[i]*((ll)(r[i]-i+1)*(ll)(i-l[i]+1)-1); //一个[a,b]区间里的集合为b-a+1,1是指为空的时候。 &#125; for(int i=1;i&lt;=n;i++) &#123; while(sta.size()&amp;&amp;a[sta.top()]&lt;a[i]) sta.pop(); l[i]=sta.empty()?1:sta.top()+1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=n;i&gt;=1;i--) &#123; while(sta.size()&amp;&amp;a[sta.top()]&lt;=a[i]) sta.pop(); r[i]=sta.empty()?n:sta.top()-1; sta.push(i); &#125; while(sta.size()) sta.pop(); for(int i=1;i&lt;=n;i++) &#123; ans+=(ll)a[i]*((ll)(r[i]-i+1)*(ll)(i-l[i]+1)-1); &#125; printf("%lld\n",ans); &#125; return 0;&#125; 其实可以两次循环就做完了，一次循环就能求出L和R。进栈的时候可以求出L[i]，出栈的时候可以求出sta.top的R;]]></content>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie树]]></title>
    <url>%2F2019%2F09%2F20%2FTrie%E6%A0%91%2F</url>
    <content type="text"><![CDATA[字典树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e4+5;int tri[MAX_N][30];int color[MAX_N];int k=1;void Insert(char * a)&#123; int alen=strlen(a); int p=0; for(int i=0;i&lt;alen;i++) &#123; int temp=a[i]-'a'; if(!tri[p][temp]) &#123; tri[p][temp]=k; k++; &#125; p=tri[p][temp]; &#125; color[p]=1;&#125;int Query(char *a)&#123; int alen=strlen(a); int p=0; for(int i=0;i&lt;alen;i++) &#123; int temp=a[i]-'a'; if(!tri[p][temp]) &#123; return 0; &#125; p=tri[p][temp]; &#125; return color[p]==1;&#125;int main()&#123; int t,q; char s[20]; scanf("%d%d",&amp;t,&amp;q); while(t--) &#123; scanf("%s",s); Insert(s); &#125; while(q--) &#123; scanf("%s",s); if(Query(s)) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>前缀树</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精]]></title>
    <url>%2F2019%2F09%2F19%2F%E9%AB%98%E7%B2%BE%2F</url>
    <content type="text"><![CDATA[高精度模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF=0x3f3f3f3f;const int MAX_N=1e3+5;const int N = 4e4+5;# define FOR(i, a, b) for(int i = a; i &lt;= b; i++)# define _FOR(i, a, b) for(int i = a; i &gt;= b; i--)struct BigInt&#123; static const int M = 20500; int num[M + 10], len; BigInt() &#123; clean(); &#125; void clean()&#123; memset(num, 0, sizeof(num)); len = 1; &#125; void read()&#123; char str[M + 10]; scanf("%s", str); len = strlen(str); FOR(i, 1, len) num[i] = str[len - i] - '0'; &#125; void write()&#123; _FOR(i, len, 1) printf("%d", num[i]); puts(""); &#125; void itoBig(int x)&#123; clean(); while(x != 0)&#123; num[len++] = x % 10; x /= 10; &#125; if(len != 1) len--; &#125; bool operator &lt; (const BigInt &amp;cmp) const &#123; if(len != cmp.len) return len &lt; cmp.len; _FOR(i, len, 1) if(num[i] != cmp.num[i]) return num[i] &lt; cmp.num[i]; return false; &#125; bool operator &gt; (const BigInt &amp;cmp) const &#123; return cmp &lt; *this; &#125; bool operator &lt;= (const BigInt &amp;cmp) const &#123; return !(cmp &lt; *this); &#125; bool operator != (const BigInt &amp;cmp) const &#123; return cmp &lt; *this || *this &lt; cmp; &#125; bool operator == (const BigInt &amp;cmp) const &#123; return !(cmp &lt; *this || *this &lt; cmp); &#125; BigInt operator + (const BigInt &amp;A) const &#123; BigInt S; S.len = max(len, A.len); FOR(i, 1, S.len)&#123; S.num[i] += num[i] + A.num[i]; if(S.num[i] &gt;= 10)&#123; S.num[i] -= 10; S.num[i + 1]++; &#125; &#125; while(S.num[S.len + 1]) S.len++; return S; &#125; BigInt operator - (const BigInt &amp;A) const &#123; BigInt S; S.len = max(len, A.len); FOR(i, 1, S.len)&#123; S.num[i] += num[i] - A.num[i]; if(S.num[i] &lt; 0)&#123; S.num[i] += 10; S.num[i + 1]--; &#125; &#125; while(!S.num[S.len] &amp;&amp; S.len &gt; 1) S.len--; return S; &#125; BigInt operator * (const BigInt &amp;A) const &#123; BigInt S; if((A.len == 1 &amp;&amp; A.num[1] == 0) || (len == 1 &amp;&amp; num[1] == 0)) return S; S.len = A.len + len - 1; FOR(i, 1, len) FOR(j, 1, A.len)&#123; S.num[i + j - 1] += num[i] * A.num[j]; S.num[i + j] += S.num[i + j - 1] / 10; S.num[i + j - 1] %= 10; &#125; while(S.num[S.len + 1]) S.len++; return S; &#125; BigInt operator / (const BigInt &amp;A) const &#123; BigInt S; if((A.len == 1 &amp;&amp; A.num[1] == 0) || (len == 1 &amp;&amp; num[1] == 0)) return S; BigInt R, N; S.len = 0; _FOR(i, len, 1)&#123; N.itoBig(10); R = R * N; N.itoBig(num[i]); R = R + N; int flag = -1; FOR(j, 1, 10)&#123; N.itoBig(j); if(N * A &gt; R)&#123; flag = j - 1; break; &#125; &#125; S.num[++S.len] = flag; N.itoBig(flag); R = R - N * A; &#125; FOR(i, 1, S.len / 2) swap(S.num[i], S.num[len - i + 1]); while(!S.num[S.len] &amp;&amp; S.len &gt; 1) S.len--; return S; &#125; BigInt operator % (const BigInt &amp;A) const &#123; BigInt S; BigInt P = *this / A; S = *this - P * A; return S; &#125;&#125;;]]></content>
      <tags>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序 12345678910111213141516171819202122232425void QuickSort(int arr[],int left,int right)&#123; if(right&lt;=left) return; int i=left; int j=right; int key=arr[(i+j)/2]; while(i&lt;=j)&#123; while(arr[i]&lt;key)&#123; i++; if(i==right)&#123; break; &#125; &#125; while(arr[j]&gt;key)&#123; j--; if(j==left)&#123; break; &#125; &#125; if(i&lt;=j)&#123; swap(arr[i],arr[j]); i++;j--; &#125; &#125; QuickSort(arr,left,j); QuickSort(arr,i,high);&#125; 归并排序1234567891011121314void mergesort(int arr[],int s,int t,int temp[])&#123; if(s&gt;=t) return; int mid=(s+t)&gt;&gt;1; mergesort(arr,s,mid,temp); mergesort(arr,mid+1,t,temp); int i=s; int j=mid+1; int k=s; while(i&lt;=mid&amp;&amp;j&lt;=t)&#123; if(arr[i]&lt;=arr[j]) temp[k++]=arr[i++]; else temp[k++]=arr[j++]; &#125; while(i&lt;=mid) temp[k++]=arr[i]++; while(j&lt;=t) temp[k++]=arr[j++]; for(int l=s;l&lt;=t;l++) arr[l]=temp[l];&#125;]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Applese涂颜色]]></title>
    <url>%2F2019%2F04%2F29%2FApplese%E6%B6%82%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题目链接： https://ac.nowcoder.com/acm/contest/330/E 费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}≡1(mod p)$。 在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: $a^{φ(n)}≡1(mod n)$φ(n)为欧拉函数，定义为不超过n的整数中与n互素的个数。欧拉降幂公式： $a^b≡a^{bmodφ(n)+φ(n)}mod n$ 题意：求出$2^n$。思路：快速幂求$2^n$，问题是n太大了。肯定用数组存，然后利用费马小定理：$2^nmod m=2^{n mod (m-1）}modm$ （这个怎么推我还不知道） 我写的AC代码：12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;//快速幂ll mod_pow(ll x,ll n)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;int main()&#123; string n,m; ll a; ios::sync_with_stdio(false); while(cin&gt;&gt;n&gt;&gt;m)&#123; a=0; for(ll i=0;i&lt;n.size();i++)&#123; a=(a*10+n[i]-'0')%(mod-1); &#125; printf("%lld\n",mod_pow(2,a)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>费马小定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM模板]]></title>
    <url>%2F2019%2F04%2F28%2FACM%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[一些比赛用的模板 数论快速幂 O(logn)123456789101112131415161718// 写法1：ll mod_pow(ll x,ll n, ll mod)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1)res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;//写法2:ll mod_pow(ll x,ll n, ll mod)&#123; if(n==0) return 1; ll res=mod_pow(x*x%mod,n/2,mod); if(n&amp;1) res=res*x%mod; return res;&#125; 矩阵快速幂12345678910111213141516171819202122232425262728typedef long long ll;typedef vector&lt;int&gt; vec;typedef vector&lt;vec&gt; mat;const int M=1e8+7; //模的大小//vector&lt;int&gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1mat mul(mat &amp;A,mat &amp;B)&#123; mat C(A.size(),vec(B[0].size())); for(int i=0;i&lt;A.size();i++)&#123; for(int k=0;k&lt;B.size();k++)&#123; for(int j=0;j&lt;B[0].size();j++)&#123; C[i][j]=(C[i][j]+A[i][k]*B[k][j])%M; &#125; &#125; &#125; return C;&#125;mat pow(mat A,ll n)&#123; mat B(A.size(),vec(A.size())); // 输出矩阵 for(int i=0;i&lt;A.size();i++)&#123; B[i][i]=1; &#125; while(n&gt;0)&#123; if(n&amp;1) B=mul(B,A); A=mul(A,A); n&gt;&gt;=1; &#125; return B;&#125; GCD 欧几里得算法 O（log max(a,b)）123456789101112131415161718192021int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;F(x)是斐波那契数列GCD(F[n],F[m])=F[gcd(n,m)//扩展欧几里得算法 ax+by=gcd(a,b); int extgcd(int a,int b,int&amp; x,int&amp; y)&#123; int d=a; if(b!=0)&#123; d=extgcd(b,a%b,y,x); y-=(a/b)*x; &#125; else&#123; x=1; y=0; &#125; return d; &#125; 素数筛表时间复杂度接近O(n)123456789101112131415int vis[MAXN];int prime[MAXN];void Prime()&#123; int cnt=0; for(int i=2;i&lt;=n;i++) &#123; if(!vis[i]) prime[cnt++]=i; for(int j=0;j&lt;cnt&amp;&amp;i*prime[j]&lt;=n;j++) &#123; vis[i*prime[j]]=i; if(i%prime[j]==0) break; &#125; &#125;&#125; 二次探测定理：奇素数p（即除2外的素数）$xmodp^2=1$的解只有x=1和x=p-1 素数定理：随着x的增长,$π(x)/(x/ln(x))=1$，(π(x)为小于x的素数的个数) 递推式转矩阵 费马小定理和欧拉公式 费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。如果p是一个质数，而整数a不是p的倍数，则有$a^{p-1}≡1(mod p)$。费马小定理：$2^nmodm=2^{nmod(m-1）}mod~~m$ （这个怎么推我还不知道） 在数论中，欧拉定理,（也称费马-欧拉定理）是一个关于同余的性质。欧拉定理表明，若n,a为正整数，且n,a互质，则: $a^{φ(n)}≡1(mod n)$φ(n)为欧拉函数，定义为不超过n的整数中与n互素的个数。欧拉降幂公式： $a^b≡a^{bmodφ(n)+φ(n)}mod n$123456789101112// 求欧拉函数值.int euler_phi(int n)&#123; int res=n; for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; res=res/i*(i-1); for(;n%i==0;n/=i); &#125; &#125; if(n!=1) res=res/n*(n-1); return res;&#125; 卢卡斯定理Lucas定理是用来求 c(n,m) mod p，p为素数的值。表达式：C(n,m)%p=C(n/p,m/p)*C(n%p,m%p)%pLucas定理：我们令n=sp+q , m=tp+r .（q ，r ≤p）那么:&lt;/div&gt; 12 BBP公式12345678910111213141516171819202122#include &lt;iostream&gt;#define MAX_C 56000int a = 10000, b, c = MAX_C, d, e, f[MAX_C + 1], g, n, ans, cnt;using namespace std;/** BBP公式 参照CCDN的姬小野博客 本人还不会....*/int main() &#123; while(~scanf("%d", &amp;n))&#123; for (; b - c; ) f[b++] = a / 5; for (; d = 0, g = c * 2; c -= 14, ans = e + d / a, e = d % a, cnt++) &#123; if (cnt * 4 &gt; n) break; for (b = c; d += f[b]*a, f[b] = d % --g, d /= g--, --b; d *= b); &#125; if (n % 4 == 0) cout &lt;&lt; (ans / 1000); else if (n % 4 == 1) cout &lt;&lt; ((ans / 100) % 10); else if (n % 4 == 2) cout &lt;&lt; ((ans / 10) % 10); else if (n % 4 == 3) cout &lt;&lt; (ans % 10); printf("\n");&#125; return 0;&#125; 图论最短路问题任意两点间的最短路问题(Floyd算法)1234567891011int d[MAX_v][MAX_V] //无法到达时，权值为INF，主对角线为0int V // 顶点数void Floyd()&#123; for(int k=0;k&lt;V;k++)&#123; for(int i=0;i&lt;V;i++)&#123; for(int j=0;j&lt;V;j++)&#123; d[i][j]=min(d[i][j],d[i][k]+d[k][j]); &#125; &#125; &#125;&#125; 单源最短路问题(Dijkstra算法)12345678910111213141516171819202122232425262728293031323334int cost[MAX_V][MAX_V]; //图的临接矩阵int d[MAX_V]; //顶点s（起点）到各点的最短距离bool used[MAX_V]; //是否已经访问过int V; //顶点数int prev[MAX_V]; //前趋顶点 （路径还原）void Dijkstra(int s)&#123; fill(d,d+v,INF); fill(used,used+V,false); fill(prev,prev+V,-1); d[s]=0; while(true)&#123; int v=-1; for(int u=0;u&lt;V;u++)&#123; if(!used[u]&amp;&amp;(v==-1||d[u]&lt;d[v])) v=u; &#125; if(v==-1) break; used[v]=true; for(int u=0;u&lt;V;u++)&#123; if(d[u]&gt;d[v]+cost[v][u])&#123; d[u]=d[v]+cost[v][u]; prev[u]=v; &#125; &#125; &#125;&#125;//到顶点t的最短路vector&lt;int&gt; get_path(int t)&#123; vector&lt;int&gt; path; for(;t!=-1;t=prev[t]) path.push_back(t); reverse(path.begin(),path.end()); return path;&#125; 最小生成树Prim算法1234567891011121314151617181920212223242526int cost[MAX_V][MAX_V]; //临接矩阵表示边int mincost[MAX_V]; //从集合X出发的边到每个顶点的最小权值bool used[MAX_V]; //顶点i是否包含在集合X中int V; //顶点数int prim()&#123; for(int i=0;i&lt;V;i++)&#123; mincost[i]=INF; used[i]=false; &#125; mincost[0]=0; int res=0; while(true)&#123; int v=-1; for(int u=0;u&lt;V;u++)&#123; if(!used[u]&amp;&amp;(v==-1||mincost[u]&lt;mincost[v])) v=u; &#125; if(v==-1) break; used[v]=true; //把顶点v加入X res+=mincost[v]; //把边的长度加到结果里 for(int u=0;u&lt;V;u++)&#123; mincost[u]=min(mincost[u],cost[v][u]); &#125; &#125; return res;&#125; Kruskal算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct edge&#123; int u,v,cost;&#125;;bool comp(const edge&amp; e1,const edge&amp; e2)&#123; return e1.cost &lt; e2.cost;&#125;int par[MAX_N] //父亲int rank[MAX_N] //数的高度void init_union_find(int n)&#123; for(int i=0;i&lt;n;i++)&#123; par[i]=i; rank[i]=0; &#125;&#125;int find(int x)&#123; if(par[x]==x)&#123; return x; &#125;else&#123; return par[x]=find(par[x]); &#125;&#125;void unite(int x,int y)&#123; x=find(x); y=find(y); if(x==y) return; if(rank[x]&lt;rank[y])&#123; par[x]=y; &#125;else&#123; par[y]=x; if(rank[x]==rank[y])rank[x]++; &#125;&#125;edge es[MAX_E];int V,E; //顶点数和边数int kruskal()&#123; sort(es,es+E,comp); //将边排序 init_union_find(V); //并查集初始化 int res=0; for(int i=0;i&lt;E;i++)&#123; edge e=es[i]; if(!same(e.u,e.v))&#123; unite(e.u,e.v); res+=e.cost; &#125; &#125; return res;&#125; 最大流最小割问题摘自：https://blog.csdn.net/yo_bc/article/details/72825629 FORD-FULKERSON(FF)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 205;struct node&#123; int v, w, next;&#125;edge[maxn*maxn];int no, n, m;int head[maxn], pre[maxn], rec[maxn], flow[maxn];stack&lt;int&gt; stk;void init()&#123; no = 0; memset(head, -1, sizeof head);&#125;//静态邻接表存边 void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;int dfs(int S, int T)&#123; memset(pre, -1, sizeof pre); while(!stk.empty()) stk.pop(); pre[S] = S; flow[S] = inf; stk.push(S); while(!stk.empty()) //用栈迭代替代dfs深搜 &#123; int top = stk.top(); stk.pop(); int k = head[top]; while(k != -1) &#123; if(pre[edge[k].v] == -1 &amp;&amp; edge[k].w &gt; 0) &#123; flow[edge[k].v] = min(flow[top], edge[k].w); pre[edge[k].v] = top; rec[edge[k].v] = k; stk.push(edge[k].v); &#125; k = edge[k].next; &#125; if(pre[T] != -1) return flow[T]; &#125; return -1;&#125;int FF(int s, int t)&#123; int ans = 0, add; while((add = dfs(s, t)) != -1) //直到找不到增广路 &#123; ans += add; int k = t; while(k != s) &#123; edge[rec[k]].w -= add; edge[rec[k]^1].w += add; k = pre[k]; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; init(); for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; FF(1, n) &lt;&lt; endl; &#125; return 0;&#125; Edmonds-Karp(EK)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 205;struct node&#123; int v, w, next;&#125;edge[maxn*maxn];int no, n, m;int head[maxn], pre[maxn], rec[maxn], flow[maxn];queue&lt;int&gt; q;void init()&#123; no = 0; memset(head, -1, sizeof head);&#125;//静态邻接表存边 void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;int dfs(int S, int T)&#123; memset(pre, -1, sizeof pre); while(!q.empty()) q.pop(); pre[S] = S; flow[S] = inf; q.push(S); while(!q.empty()) &#123; int top = q.front(); q.pop(); int k = head[top]; while(k != -1) &#123; if(pre[edge[k].v] == -1 &amp;&amp; edge[k].w &gt; 0) &#123; flow[edge[k].v] = min(flow[top], edge[k].w); pre[edge[k].v] = top; rec[edge[k].v] = k; q.push(edge[k].v); &#125; k = edge[k].next; &#125; if(pre[T] != -1) return flow[T]; &#125; return -1;&#125;int EK(int s, int t)&#123; int ans = 0, add; while((add = dfs(s, t)) != -1) //直到找不到增广路 &#123; ans += add; int k = t; while(k != s) &#123; edge[rec[k]].w -= add; edge[rec[k]^1].w += add; k = pre[k]; &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; init(); for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; EK(1, n) &lt;&lt; endl; &#125; return 0;&#125; Dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 205;struct node&#123; int v, w, next;&#125;edge[maxn*maxn];int dis[maxn], pre[maxn], rec[maxn], head[maxn], block[maxn];int n, m, no;queue&lt;int&gt; q;//静态邻接表存边 inline void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;inline void pre_init()&#123; no = 0; memset(head, -1, sizeof head);&#125;void init(int S, int T)&#123; //初始化一定要注意把所涉及的都覆盖到 for(int i = 0; i &lt;= n; ++i) &#123; dis[i] = inf; block[i] = 0; //标记阻塞点 &#125; while(!q.empty()) q.pop(); dis[S] = 0; q.push(S); while(!q.empty()) //生成层次图 &#123; int tp = q.front(); q.pop(); int k = head[tp]; while(k != -1) &#123; if(dis[edge[k].v] == inf &amp;&amp; edge[k].w) &#123; dis[edge[k].v] = dis[tp] + 1; q.push(edge[k].v); &#125; k = edge[k].next; &#125; &#125;&#125;int dinic(int S, int T)&#123; int top = S, ans = 0, flow = inf; pre[S] = S; init(S, T); while(dis[T] != inf) //当S无法到达T，不能再增广了 &#123; int k = head[top]; while(k != -1) &#123; if(edge[k].w &amp;&amp; dis[edge[k].v] == dis[top]+1 &amp;&amp; !block[edge[k].v]) break; k = edge[k].next; &#125; if(k != -1) //找到下一节点 &#123; int v = edge[k].v; flow = min(flow, edge[k].w); pre[v] = top; rec[v] = k; top = v; if(top == T) &#123; ans += flow; v = -1; k = T; while(k != S) &#123; edge[rec[k]].w -= flow; edge[rec[k]^1].w += flow; if(!edge[rec[k]].w) v = k; //寻找距S最近的一个"瓶颈"边 k = pre[k]; &#125; flow = inf; //此处flow必须在外面，大佬的板子可能没注意到，我认为是必须的 if(v != -1) //找到"瓶颈"边 &#123; top = pre[v]; k = top; while(k != S) &#123; flow = min(edge[rec[k]].w, flow); k = pre[k]; &#125; &#125; &#125; &#125; else &#123; block[top] = 1; //找不到下一节点成为阻塞点 top = pre[top]; //回溯 if(block[S]) init(S, T);//如果S被阻塞，重新计算层次图 //阻塞点的产生也造成了flow的最小值可能是后面的值，虽然进行一次 //增广并没什么问题，但上述寻找瓶颈边的判断则是必须的了。 &#125; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; pre_init(); for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; dinic(1, n) &lt;&lt; endl; &#125; return 0;&#125; /**********************比赛版本***********************/ #include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int inf = 0x3f3f3f3f;const int maxn = 205;const int maxm = maxn*maxn;struct node&#123;int w; int v, next;&#125; edge[maxm];int pre[maxn], rec[maxn], head[maxn], block[maxn];int dis[maxn];int n, m, no;int S, T;queue&lt;int&gt; q;inline void init()&#123; no = 0; memset(head, -1, sizeof head);&#125;inline void add(int u, int v, int w)&#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++;&#125;void reset(int S, int T)&#123; memset(dis, 0x3f, sizeof dis); memset(block, 0, sizeof block); q.push(S); dis[S] = 0; while(!q.empty()) &#123; int top = q.front(); q.pop(); for(int k = head[top]; k != -1; k = edge[k].next) if(dis[edge[k].v] == inf &amp;&amp; edge[k].w) dis[edge[k].v] = dis[top]+1, q.push(edge[k].v); &#125;&#125;int dinic(int S, int T)&#123; int ans = 0, flow = inf; int top = S; reset(S, T); pre[S] = S; while(dis[T] != inf) &#123; int k, tmp; for(k = head[top]; k != -1; k = edge[k].next) &#123; if(edge[k].w &amp;&amp; dis[edge[k].v]==dis[top]+1 &amp;&amp; !block[edge[k].v]) break; &#125; if(k != -1) &#123; tmp = edge[k].v; flow = min(flow, edge[k].w); pre[tmp] = top, rec[tmp] = k; top = tmp; if(top == T) &#123; ans += flow; tmp = -1; for(; top != S; top = pre[top]) &#123; edge[rec[top]].w -= flow; edge[rec[top]^1].w += flow; if(!edge[rec[top]].w) tmp = top; &#125; flow = inf; if(tmp != -1) &#123; top = pre[tmp]; for(; top != S; top = pre[top]) flow = min(flow, edge[rec[top]].w); top = pre[tmp]; &#125; &#125; &#125; else &#123; block[top] = 1; top = pre[top]; if(block[S]) reset(S, T); &#125; &#125; return ans;&#125;void mapping()&#123; int u, v, w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;int main()&#123; while(~scanf("%d %d", &amp;m, &amp;n)) &#123; S = 1, T = n; init(); mapping(); printf("%d\n", dinic(S, T)); &#125; return 0;&#125; Shortest Augmenting Paths(SAP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241#include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int inf = 0x7fffffff; const int maxn = 205; const int maxm = maxn*maxn; //一定要好好计算边的数量 struct node &#123; int v, w, next; &#125;edge[maxm]; int dis[maxn], pre[maxn], rec[maxn], head[maxn], gap[maxn], now[maxn]; int n, m, no, up; //up指逆层次图可能还有增广路时dis的上界 queue&lt;int&gt; q; //静态邻接表存边 inline void add(int u, int v, int w) &#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++; &#125; inline void pre_init() &#123; no = 0; up = n; memset(head, -1, sizeof head); &#125; void init(int S, int T) &#123; for(int i = 0; i &lt;= up; ++i) &#123; now[i] = head[i]; //now用作当前弧的优化 //注意这里now数组要把所有用到的标号都存过来 gap[i] = 0, dis[i] = inf; //初始化一定要注意把所涉及的都覆盖到 &#125; while(!q.empty()) q.pop(); dis[T] = 0; q.push(T); while(!q.empty()) //生成逆层次图 &#123; int tp = q.front(); q.pop(); ++gap[dis[tp]]; int k = head[tp]; while(k != -1) &#123; if(dis[edge[k].v] == inf &amp;&amp; edge[k^1].w) &#123; dis[edge[k].v] = dis[tp]+1; q.push(edge[k].v); &#125; k = edge[k].next; &#125; &#125; &#125; int SAP(int S, int T) &#123; int ans = 0, flow = inf, top = S; pre[S] = S; init(S, T); while(dis[S] &lt; up) //当S到T的距离大于等于点的个数时肯定就不能再增广了 &#123; //切记此处与节点数比较，因为通过方向变会造成距离可能达到节点数 if(top == T) &#123; ans += flow; while(top != S) //修改残留网络，并置top为S &#123; edge[rec[top]].w -= flow; edge[rec[top]^1].w += flow; top = pre[top]; &#125; flow = inf; &#125; int k = now[top]; while(k != -1) &#123; int v = edge[k].v; if(edge[k].w &amp;&amp; dis[top] == dis[v]+1) &#123; flow = min(flow, edge[k].w); pre[v] = top; rec[v] = k; now[top] = k;//当前弧的优化 top = v; break; &#125; k = edge[k].next; &#125; if(k == -1) &#123; int mind = n; if(--gap[dis[top]] == 0) break;//出现断层，间隙优化 int k = now[top] = head[top];//改变当前点的距离标号，也要清除之前的当前弧优化的影响 while(k != -1) &#123; if(edge[k].w &amp;&amp; mind&gt;dis[edge[k].v]) mind = dis[edge[k].v]; k = edge[k].next; &#125; ++gap[dis[top] = mind+1]; top = pre[top];//回溯到上一个点 &#125; &#125; return ans; &#125;int main() &#123; ios::sync_with_stdio(0); int u, v, w; while(cin &gt;&gt; m &gt;&gt; n) &#123; pre_init(); for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); &#125; cout &lt;&lt; SAP(1, n) &lt;&lt; endl; &#125; return 0; &#125; /**********************比赛版本***********************/ #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std; const int inf = 0x3f3f3f3f; const int maxn = 205; const int maxm = maxn*maxn;struct node&#123;int w; int v, next;&#125; edge[maxm]; int pre[maxn], rec[maxn], head[maxn], gap[maxn], now[maxn]; int dis[maxn];int n, m, no, up; int S, T; queue&lt;int&gt; q;inline void add(int u, int v, int w) &#123; edge[no].v = v; edge[no].w = w; edge[no].next = head[u]; head[u] = no++; edge[no].v = u; edge[no].w = 0; edge[no].next = head[v]; head[v] = no++; &#125; inline void pre_init() &#123; no = 0; memset(head, -1, sizeof head); &#125; void init(int S, int T) &#123; memset(gap, 0, sizeof gap); memset(dis, 0x3f, sizeof dis); for(int i = 0; i &lt;= up; ++i) now[i] = head[i]; while(!q.empty()) q.pop(); dis[T] = 0; q.push(T); while(!q.empty()) &#123; int tp = q.front(); q.pop(); ++gap[dis[tp]]; int k = head[tp]; while(k != -1) &#123; if(dis[edge[k].v] == inf &amp;&amp; edge[k^1].w) &#123; dis[edge[k].v] = dis[tp]+1; q.push(edge[k].v); &#125; k = edge[k].next; &#125; &#125; &#125; int SAP(int S, int T) &#123; int ans = 0, flow = inf; int top = S; pre[S] = S; init(S, T); while(dis[S] &lt; up) &#123; if(top == T) &#123; ans += flow; while(top != S) &#123; edge[rec[top]].w -= flow; edge[rec[top]^1].w += flow; top = pre[top]; &#125; flow = inf; &#125; int k = now[top]; while(k != -1) &#123; int v = edge[k].v; if(edge[k].w &amp;&amp; dis[top] == dis[v]+1) &#123; flow = min(flow, edge[k].w); pre[v] = top; rec[v] = k; now[top] = k; top = v; break; &#125; k = edge[k].next; &#125; if(k == -1) &#123; int mind = up; if(--gap[dis[top]] == 0) break; int k = now[top] = head[top]; while(k != -1) &#123; if(edge[k].w &amp;&amp; mind&gt;dis[edge[k].v]) mind = dis[edge[k].v]; k = edge[k].next; &#125; ++gap[dis[top] = mind+1]; top = pre[top]; &#125; &#125; return ans; &#125; void mapping()&#123; int u, v, w; for(int i = 1; i &lt;= m; ++i) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); add(u, v, w); &#125;&#125;int main() &#123; while(~scanf("%d %d", &amp;m, &amp;n)) &#123; up = n, S = 1, T = n; pre_init(); mapping(); printf("%d\n", SAP(S, T)); &#125; return 0; &#125; 二分图匈牙利算法123456789101112131415161718192021222324252627bool CP[MAX][MAX]; //cp[i][j]=1 表示i能和j组cpbool used[MAX]; //记录是否已经被访问int linked[MAX]; //linked[i]=j 表示i和j组cpbool fun(int x)&#123; int i for (i=1;i&lt;=N;i++)&#123; if (CP[x][i]==true &amp;&amp; used[i]==false) &#123; used[i]=1; if (linked[i]==0 || fun(linked[i])) &#123; linked[j]=x; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int ans=0; memset(linked,0,sizeof(linked)); for(int i=1;i&lt;=M;i++)&#123; memset(used,0,sizeof(used)); if(fun(i)) ans++; &#125;&#125; 12345678910111213141516171819202122232425262728293031// 转载： https://blog.csdn.net/qq_32265245/article/details/53046750/* |求解最大匹配问题| |dfs实现|*/int v1, v2; bool Map[501][501]; bool visit[501]; int link[501]; int result; bool dfs(int x) &#123; for (int y = 1; y &lt;= v2; ++y) &#123; if (Map[x][y] &amp;&amp; !visit[y]) &#123; visit[y] = true; if (link[y] == 0 || dfs(link[y])) &#123; link[y] = x; return true; &#125; &#125; &#125; return false; &#125; void Search() &#123; for (int x = 1; x &lt;= v1; x++) &#123; memset(visit,false,sizeof(visit)); if (dfs(x)) result++; &#125;&#125; 博弈巴仕博弈（Bash Game）描述：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; if(n%(m+1)) cout&lt;&lt;"first"&lt;&lt;endl; else cout&lt;&lt;"second"&lt;&lt;endl; &#125; return 0;&#125; 威佐夫博弈（Wythoff Game）描述：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜1，我们用（a[k]，b[k]）（a[k] ≤ b[k] ,k=0，1，2，…,n)表示两堆物品的数量并称其为局势。 2，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。 3，奇异局（举例） 首先列举人们已经发现的前几个奇异局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10） （8，13）、（9，15）、（11，18）、（12，20）。 通过观察发现：a[0]=b[0]=0,a[k]是未在前面出现过的最小自然数,而 b[k]= a[k] + k。 4，奇异局势有如下三条性质： 1）任何自然数都包含且仅包含在一个奇异局势中。 2）任意操作都可以使奇异局势变为非奇异局势。 3）必有一种操作可以使非奇异局势变为奇异局势。 5，奇异局势公式： a[k]=[k*(1+√5)/2]，b[k]=a[k]+k。 (k=0,1,2……，[ ]表示取整）123456789101112131415161718//威佐夫博弈模板#include&lt;bits/stdc++.h&gt;using namespace std;const double Gsr=(1+sqrt(5.0))/2;int main()&#123; int a,b; while(~scanf("%d%d",&amp;a,&amp;b)) &#123; if(a&gt;b) swap(a,b); if(a == (int)(Gsr*(b-a))) //奇异局势，先拿者输 puts("First Lose"); else puts("First Win"); &#125; return 0;&#125; Nim博弈描述：有n堆石子，每堆各有$a_i$课石子。Alice和Bob轮流从非空的石子堆中取走至少一颗石子。Alice先取，取光所有石子的一方获胜。当双方都采取最优策略时，谁会获胜？ 结论：计算所有$a_i$的异或值，如果非零则先手胜，为零则后手胜。1234567891011121314151617//Nim模板#include&lt;bits/stdc++.h&gt;using namespace std;const double Gsr=(1+sqrt(5.0))/2;int N，A[MAX_N];int main()&#123; cin&gt;&gt;N; for(int i=0;i&lt;N;i++) cin&gt;&gt;A[i]; int x=0; for(int i=0;i&lt;N;i++) x^=A[i]; if(x!=0) puts("Alice"); else puts("Bob"); return 0;&#125; SG函数描述：Alice和Bob在玩这样一个游戏。给定k个数字$a_1,a_2,···,a_k$。一开始，有n堆硬币，每堆各有$x_i$枚硬币。Alice和Bob轮流选出一堆硬币，从中取出一些硬币。每次所取硬币的枚数一定要在$a_1,a_2,···,a_k$当中。Alice先取，取光硬币的一方获胜。当双方都采取最优策略时，谁会获胜？123456789101112131415161718192021222324//SG函数模板int N,K,X[MAX_N]，A[MAX_K];//利用动态规划计算grundy值的数组int grundy[MAX_X+1];void solve()&#123; //轮到自己时为0则必败 grundy[0]=0; //计算grundy值 int max_x=*max_element(X,X+N); for(int j=1;j&lt;=max_x;j++)&#123; set&lt;int&gt; s; for(int i=0;i&lt;K;i++)&#123; if(A[i]&lt;=j) s.insert(grundy[j-A[i]]); &#125; int g=0; while(s.count(g)!=0)g++; grundy[j]=g; &#125; //判断胜负 int x=0; for(int i=0;i&lt;N;i++) x^=grundy[X[i]]; if(x!=0) puts("Alice"); else puts("Bob");&#125;]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NB群友]]></title>
    <url>%2F2019%2F04%2F27%2FNB%E7%BE%A4%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[一道出题人出的签到题，结果大部分人没签到。于我而言，是看到数据量很大就慌了，觉得会超时，题面较长也没看下来。题目链接：https://ac.nowcoder.com/acm/contest/625/A 题意：找出满足$L&lt;=数位积&lt;=R$的数的个数. 思路：问题转换成求$数位积&lt;=R的个数-数位积&lt;=(L-1)的个数$，题解给的是dfs枚举2∼9每个数字出现的次数，然后再组合数统计一下答案，剪剪枝。题解链接： https://fshp971.com/2019-scut-contest-easy/题解给的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define mem(a,b) memset(a,b,sizeof(a))#define REP(i,a,b) for(int i=a; i&lt;=b; ++i)#define PER(i,a,b) for(int i=a; i&gt;=b; --i)#define MP make_pair#define PB push_back#define fi first#define se secondtypedef long long LL;typedef double DB;const int maxT = 50;const int P = 1e9+7;const LL MaxInt = (1LL&lt;&lt;32) - 1;LL Fac[100], InvFac[100];LL C[100][100];int cnt[20];LL lim;LL dfs(LL now, int pt) &#123; if(pt&lt;=1) &#123; int s = 0; LL ret = 1; REP(i,2,9) &#123; s += cnt[i]; ret = ret * C[s][cnt[i]] % P; &#125; if(s==0) return 0LL; return ret; &#125; LL ret = 0; cnt[pt] = 0; while(now &lt;= lim) &#123; ret = (ret + dfs(now, pt-1)) % P; now *= pt, ++cnt[pt]; &#125; return ret;&#125;int main() &#123; C[0][0] = 1; for(int i = 1; i &lt;= 50; ++i) &#123; C[i][0] = C[i][i] = 1; for(int k = 1; k &lt; i; ++k) C[i][k] = (C[i-1][k] + C[i-1][k-1]) % P; &#125; int _; scanf("%d", &amp;_); while(_--) &#123; LL a,b; scanf("%lld%lld", &amp;a, &amp;b); lim = b; LL sb = dfs(1,9); lim = a-1; LL sa = dfs(1,9); LL ans = (sb - sa + P) % P; printf("%lld\n", ans); &#125; return 0;&#125; 看到另一篇题解说的是搜索过程枚举每一位数，然后记录一下状态值，剪枝链接： https://www.cnblogs.com/ymzjj/p/10713187.html AC的代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll M=1e9+7;int T;map &lt; ll, ll&gt; mp;ll L,R;ll res;ll dfs(ll x)&#123; if(mp.count(x))&#123; return mp[x]; &#125; ll temp=0; for(int i=2;i&lt;=9;i++)&#123; if(x&gt;=i)&#123; temp+=dfs(x/i)+1; //枚举每一位数 &#125; &#125; return mp[x]=temp;&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;L,&amp;R); res=(dfs(R)-dfs(L-1))%M; printf("%d\n",res); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>牛客网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word-Search Wonder]]></title>
    <url>%2F2019%2F04%2F27%2FWord-Search-Wonder%2F</url>
    <content type="text"><![CDATA[题目链接: http://poj.org/problem?id=1501 题意：给一个字符矩阵，再给“单词”，在矩阵中找到单词，输出单词首元素的坐标和末元素的坐标。 思路：是一道深搜，需要注意的是深搜的方向由始至终只能往一个方向，水平，垂直还有斜线，而其他只需要理解好题目套模板即可做出，还有就是本题不需要标记数组，因为深搜方向只有一个，途中不会碰到已访问的点。 下面是AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n;char mat[105][105];char a[105];bool flag;int first_x,first_y,last_x,last_y;void dfs(int x,int y,int i,int dx,int dy)&#123; if(a[i]=='\0')&#123; flag=true; last_x=dx; last_y=dy; return; &#125; int nx=2*dx-x,ny=2*dy-y; if(0&lt;nx&amp;&amp;nx&lt;=n&amp;&amp;0&lt;ny&amp;&amp;ny&lt;=n&amp;&amp;mat[nx][ny]==a[i])&#123; dfs(dx,dy,i+1,nx,ny); &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; scanf(" %c",&amp;mat[i][j]); &#125; &#125; while(scanf("%s",a)!=EOF)&#123; if(a[0]=='0') break; flag=false; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(a[0]==mat[i][j]&amp;&amp;!flag)&#123; //dfs(i,j,1); first_x=i;first_y=j; for(int dx=-1;dx&lt;=1;dx++)&#123; for(int dy=-1;dy&lt;=1;dy++)&#123; int nx=i+dx,ny=j+dy; if(a[1]=='\0')&#123; flag=true;break; &#125; if(mat[nx][ny]==a[1]&amp;&amp;!flag)&#123; dfs(i,j,2,nx,ny); &#125; &#125; &#125; &#125; &#125; &#125; if(flag)&#123; printf("%d,%d %d,%d\n",first_x,first_y,last_x,last_y); &#125; else&#123; printf("Not found\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续子序列]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[动态规划入门题…题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1231题意： 给一个整数序列，求出这个序列的最大连续子序列，并输出它的开头元素和末尾元素，如果最大连续子序列小于0，则默认最大连续子序列为0，并输出序列首尾元素。想法有很多，分享一下动态规划做法。AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX_N=1e5+5;int k;int a[MAX_N];int dp[MAX_N];void solve()&#123; int first=0,last=0; int temp=0; int res; for(int i=0;i&lt;k;i++)&#123; scanf("%d",&amp;a[i]); dp[i]=a[i]; &#125; res=dp[0]; for(int i=1;i&lt;k;i++)&#123; //dp[i]=max(dp[i-1]+a[i],a[i]); //res=max(dp[i],res); if(dp[i-1]+a[i]&lt;a[i])&#123; dp[i]=a[i]; temp=i; &#125; else&#123; dp[i]=dp[i-1]+a[i]; &#125; if(res&lt;dp[i])&#123; res=dp[i]; first=temp; last=i; &#125; &#125; if(res&lt;0)&#123; first=0; last=k-1; res=0; &#125; printf("%d %d %d\n",res,a[first],a[last]);&#125;int main()&#123; while(scanf("%d",&amp;k)!=EOF&amp;&amp;k)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找出直系亲属]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%89%BE%E5%87%BA%E7%9B%B4%E7%B3%BB%E4%BA%B2%E5%B1%9E%2F</url>
    <content type="text"><![CDATA[一道水题…数据量较小，很多方法都能做。我用的是并查集。题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=3786题意：给n个关系你，然后询问m个问题，问题就是问你两个人是否为直系亲属，是就输出关系，不是就输出-。题意明了思路：用并查集来表示这个亲属图，以孩子作为根。两个人是否有关系就是一个点在找根的路径上是否会遇见另一个点，相遇就有，不相遇就是没有关系。以下是AC代码:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;int N,M;int par[30];char a[4],b[3];int one,two;void init()&#123; for(int i=0;i&lt;30;i++)&#123; par[i]=i; &#125;&#125;int find(int x,int y)&#123; int res=0; while(x!=y&amp;&amp;x!=par[x])&#123; res++; x=par[x]; &#125; if(x==y) return res; else return 0;&#125;void solve()&#123; init(); for(int i=0;i&lt;N;i++)&#123; scanf("%s",a); for(int j=1;j&lt;3;j++)&#123; if(a[j]!='-')&#123; par[(int)a[j]-'A']=(int)a[0]-'A'; &#125; &#125; &#125; while(M--)&#123; scanf("%s",b); int res=find((int)b[0]-'A',(int)b[1]-'A'); if(res)&#123; switch(res)&#123; case 1: printf("parent\n");break; case 2: printf("grandparent\n"); break; default: for(int i=0;i&lt;res-2;i++)&#123; printf("great-"); &#125; printf("grandparent\n"); break; &#125; &#125; else&#123; res=find((int)b[1]-'A',(int)b[0]-'A'); switch(res)&#123; case 0: printf("-\n");break; case 1: printf("child\n");break; case 2: printf("grandchild\n"); break; default: for(int i=0;i&lt;res-2;i++)&#123; printf("great-"); &#125; printf("grandchild\n"); break; &#125; &#125; &#125;&#125;int main()&#123; while(scanf("%d%d",&amp;N,&amp;M)!=EOF&amp;&amp;(M||N))&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URLs]]></title>
    <url>%2F2019%2F04%2F25%2FURLs%2F</url>
    <content type="text"><![CDATA[题目链接: http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=243题意: 给一个URL 找出URL的protocol、host、port、path，port和path可能不给出(即输出)。一道水题，但是一开始想法没有AC，后来改了改AC了…浪费了挺多时间 AC的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int n;int cnt;void solve()&#123; string s; cin&gt;&gt;s; string protocal,host,port="&lt;default&gt;",path="&lt;default&gt;"; int i; i=s.find("://"); protocal=s.substr(0,i); s.erase(0,i+3); i=s.find("/"); if(i!=string::npos)&#123; host=s.substr(0,i); path=s.substr(i+1,s.size()); s.erase(i,s.size()); &#125; else&#123; host=s.substr(0,s.size()); &#125; i=s.find(":"); if(i!=string::npos)&#123; host=s.substr(0,i); s.erase(0,i+1); port=s; &#125; cout&lt;&lt;"URL #"&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;"Protocol = "&lt;&lt;protocal&lt;&lt;endl; cout&lt;&lt;"Host = "&lt;&lt;host&lt;&lt;endl; cout&lt;&lt;"Port = "&lt;&lt;port&lt;&lt;endl; cout&lt;&lt;"Path = "&lt;&lt;path&lt;&lt;endl;&#125;int main()&#123; scanf("%d",&amp;n); cnt=0; while(n--)&#123; cnt++; solve(); cout&lt;&lt;endl; &#125; return 0;&#125; WA的代码，具体原因我也不知道，感觉自己思路是对的…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;int n;int cnt;void solve()&#123; string s; cin&gt;&gt;s; string protocal,host,port="&lt;default&gt;",path="&lt;default&gt;"; int i; i=s.find("://"); protocal=s.substr(0,i); s.erase(0,i+3); i=s.find(":"); if(i!=string::npos)&#123; host=s.substr(0,i); s.erase(0,i+1); i=s.find("/"); if(i!=string::npos)&#123; port=s.substr(0,i); s.erase(0,i+1); path=s.substr(0,s.size()); &#125; else&#123; port=s.substr(0,s.size()); &#125; &#125; else&#123; i=s.find("/"); if(i!=string::npos)&#123; host=s.substr(0,i); s.erase(0,i+1); path=s.substr(0,s.size()); &#125; else&#123; host=s.substr(0,s.size()); &#125; &#125; cout&lt;&lt;"URL #"&lt;&lt;cnt&lt;&lt;endl; cout&lt;&lt;"Protocol = "&lt;&lt;protocal&lt;&lt;endl; cout&lt;&lt;"Host = "&lt;&lt;host&lt;&lt;endl; cout&lt;&lt;"Port = "&lt;&lt;port&lt;&lt;endl; cout&lt;&lt;"Path = "&lt;&lt;path&lt;&lt;endl;&#125;int main()&#123; scanf("%d",&amp;n); cnt=0; while(n--)&#123; cnt++; solve(); cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匈牙利算法]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天分享的是匈牙利算法…匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。我觉得这个博主讲的挺生动形象的….https://blog.csdn.net/dark_scope/article/details/8880547 过山车题目链接: http://acm.hdu.edu.cn/showproblem.php?pid=2063匈牙利算法经典入门题 题意： 尽可能地组成最多的CP。具体想法可以看上文分享的那位博主的博客。（图文并茂）下面是AC代码:123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int K,M,N;bool CP[1000+5][1000+5]; //记录女生u是否愿意跟男生v组成CPint boy[1000+5]; //记录男生的对象是哪位女生bool used[1000+5]; //记录是否被访问过bool fun(int x)&#123; for(int i=1;i&lt;=N;i++)&#123; if(CP[x][i]==true&amp;&amp;used[i]==false)&#123; //可以组成CP且 该男生没有被访问过 used[i]=1; if(boy[i]==0||fun(boy[i]))&#123; //该男生还没组成CP，或者让原先跟这位男生组CP的女生去找其他男生组CP boy[i]=x; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int u,v; while(scanf("%d",&amp;K)!=EOF)&#123; int ans=0; if(K==0) break; scanf("%d%d",&amp;M,&amp;N); memset(CP,0,sizeof(CP)); memset(boy,0,sizeof(boy)); for(int i=0;i&lt;K;i++)&#123; scanf("%d%d",&amp;u,&amp;v); CP[u][v]=1; &#125; for(int i=1;i&lt;=M;i++)&#123; memset(used,0,sizeof(used)); //每次都是尝试让当前的女生去和男生组CP，所以需要重置used数组 if(fun(i)) ans++; &#125; printf("%d\n",ans); &#125; return 0;&#125; 匈牙利算法模板：123456789101112131415161718192021222324252627bool CP[MAX][MAX];bool used[MAX];int linked[MAX];bool fun(int x)&#123; int i for (i=1;i&lt;=N;i++)&#123; if (CP[x][i]==true &amp;&amp; used[i]==false) &#123; used[i]=1; if (linked[i]==0 || fun(linked[i])) &#123; linked[j]=x; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int ans=0; memset(linked,0,sizeof(linked)); for(int i=1;i&lt;=M;i++)&#123; memset(used,0,sizeof(used)); if(fun(i)) ans++; &#125;&#125; 关于匈牙利算法，不能一见到二分图匹配，上来就匈牙利，不然很容易TLE的，毕竟如果是最坏情况的话，该算法是的复杂度高达$O（M*N^2）$]]></content>
      <tags>
        <tag>二分图</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小数化分数]]></title>
    <url>%2F2019%2F04%2F21%2F%E5%B0%8F%E6%95%B0%E5%8C%96%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[今天回顾了一下以前的题，小数化分数。题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1717思路：首先要知道无限循环小数分数形式的构造方法：分子为最小循环节，分母为分子对应位数的每个数都化成 9， 如已知无限循环小数：0.4747……以 47为循环节，那么这个小数的分数形式就是 47/99，题中，我们将小数的有限部分和无限循环部分分开处理，得到两个分数，再相加化简，所得即为所求。以下是AC代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int N;string s;ll s1,s2,n,m;ll gcd(ll a,ll b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;void solve()&#123; cin&gt;&gt;s; s1=s2=n=m=0; int i=2; while(s[i]!='('&amp;&amp;i&lt;s.length())&#123; s1=s1*10+s[i]-48; n++; i++; &#125; i++; while(s[i]!=')'&amp;&amp;i&lt;s.length())&#123; s2=s2*10+s[i]-48; i++; m++; &#125; if(m)&#123; s2=s2+(pow(10.0,m/1.0)-1)*s1; s1=pow(10.0,n/1.0)*(pow(10,m/1.0)-1); ll k=gcd(s2,s1); cout&lt;&lt;s2/k&lt;&lt;"/"&lt;&lt;s1/k&lt;&lt;endl; &#125; else&#123; s2=pow(10.0,n/1.0); ll k=gcd(s1,s2); cout&lt;&lt;s1/k&lt;&lt;"/"&lt;&lt;s2/k&lt;&lt;endl; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;N; while(N--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coloring Game]]></title>
    <url>%2F2019%2F04%2F20%2FColoring-Game%2F</url>
    <content type="text"><![CDATA[一道签到题…卡在快速幂取模，最后改对了，花费时间太长了，记录一下… 题目链接: https://nanti.jisuanke.com/t/38227 David has a white board with 2 \times N2×N grids.He decides to paint some grids black with his brush.He always starts at the top left corner and ends at the bottom right corner, where grids should be black ultimately.Each time he can move his brush up(↑), down(↓), left(←), right(→), left up(↖), left down(↙), right up(↗), right down (↘) to the next grid.For a grid visited before,the color is still black. Otherwise it changes from white to black.David wants you to compute the number of different color schemes for a given board. Two color schemes are considered different if and only if the color of at least one corresponding position is different. InputOne line including an integer n (0< n ≤ 10^9) OutputOne line including an integer, which represent the answer mod 1000000007样例输入12样例输出14样例输入13样例输出112 题意：从左上角到后下角的路径数，没经过一个格子，黑的不变，白的变黑思路: 从输入样例可以看出，对于每一列来讲除了第一列和最后一列，每一列都有三种情况，第一列和最后一列只有两种情况，所以路径数为3^{n-2}*2*2 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull n;ull poww(ull a, ull b) &#123; ull ans = 1, base = a; while (b != 0) &#123; if (b &amp; 1 != 0) &#123; ans =ans* base%1000000007; &#125; base = base*base%1000000007; b &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; while(scanf("%lld", &amp;n)!=EOF)&#123; if(n==1)&#123; printf("1\n"); &#125; else&#123; ull ans = poww(3, n - 2); printf("%lld\n", ans*4%1000000007); &#125; &#125; return 0;&#125; 总结：快速幂且取模1234567891011121314151617181920// 位运算typedef long long ll;ll mod_pow(ll x,ll n,ll mod)&#123; ll res=1; while(n&gt;0)&#123; if(n&amp;1) res=res*x%mod; x=x*x%mod; n&gt;&gt;=1; &#125; return res;&#125;// 递归typedef long long ll;ll mod_pow(ll x,ll n,ll mod)&#123; if(n==0) return 1; ll res=mod_pow(x*x%mod,n/2,mod); if(n&amp;1) res=res*x%mod; return res;&#125;]]></content>
      <tags>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Triangle]]></title>
    <url>%2F2019%2F04%2F20%2FTriangle%2F</url>
    <content type="text"><![CDATA[2019中山大学程序设计竞赛（重现赛）虽然是签到题，但是自己没有AC… TriangleTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Problem DescriptionAfter Xiaoteng took a math class, he learned a lot of different shapes, but Xiaoteng’s favorite triangle is because he likes stable shapes, just like his style.After the Xiaoxun knew it, he wanted to give a triangle as a gift to Xiaoteng. He originally planned to do one, but he was too tired. So he decided to bring some wooden sticks to Xiaoteng and let Xiaoteng make a triangle himself.One day, Xiaoxun brought n sticks to Xiaoteng. Xiaoteng wanted to try to use three of them to form a triangle, but the number is too much, Xiaoteng stunned, so he can only ask for your help. InputThere are mutiple test cases.Each case starts with a line containing a integer $(1≤n≤5×10^6)$ which represent the number of sticks and this is followed by n positive intergers(smaller than $2^{31}−1$)separated by spaces.. OutputYES or NO for each case mean Xiaoteng can or can’t use three of sticks to form a triangle. Sample Input41 2 3 4 Sample OutputYES 题意： 给你n个数，问是否能从给的n个数从中组成一个三角形。题解：如果给的数成斐波那契数列，则不能构成三角形，且因为给的数是在$2^{32}-1$范围内，第50项斐波那契数为12586269025已经超过这个范围，即如果给了超过50个数，则必然能构成三角形。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int n;int vec[5000000+5];bool fun(int a,int b,int c)&#123; if(a&lt;c+b) return true; return false;&#125;bool compare(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int a; bool flag; while(scanf("%d",&amp;n)!=EOF)&#123; flag=0; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;vec[i]); &#125; if(n&lt;100)&#123; sort(vec,vec+n,compare); for(int i=0;i&lt;n-2;i++)&#123; flag=fun(vec[i],vec[i+1],vec[i+2]); if(flag) break; &#125; &#125; else flag=1; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 当时做并没有想到斐波那契数列….毕竟菜…如果不通过斐波那契数列来进行大判断会超时，然后我想换堆排序进行操作，用优先队列储存(实现了堆排序),结果卡内存…]]></content>
      <tags>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈STL]]></title>
    <url>%2F2019%2F04%2F18%2F%E6%B5%85%E8%B0%88STL%2F</url>
    <content type="text"><![CDATA[今天浅谈一下下STL。STL是指C++的标准模板库(Standard Template Library)。一个既好用又复杂的library。 不定长数组：vector 需要添加头文件 #include vector是一个模板类，需要用vectora或者vectorb这样的方式来声明一个vector。 我个人觉得vector就像一个数组，但却比数组方便。 vector的基本操作12345678910111213141516数组有的基本操作，vector都有... vector&lt;int&gt; a; a.back();//返回a的最后一个元素 a.front();//返回a的第一个元素 a.clear();//清空a中的元素 a.empty();//判断a是否为空，空则返回ture,不空则返回false a.pop_back();//删除a向量的最后一个元素 a.erase(index)//删除下标index的元素 a.erase(a.begin()+1,a.begin()+3); //删除区间 [a.begin()+1,a.begin()+3) 的数，STL里面大多数都是采用左闭右开的形式. a.push_back(n);//在a的最后一个向量后插入一个元素，其值为n vector也有insert函数，跟string差不多在此不再赘述了，详情请翻看[Some tips for String](https://ihopezero.github.io/2019/04/17/Some-tips-for-String/). a.size();//返回a中元素的个数 a.capacity();//返回a的空间大小 a.resize();//重新设置a的大小 a.find(n);//返回n出现的下标，类似string的find() 集合：set需要添加头文件 “set “,set中的元素已从小到大排好序了，set是用二叉搜索树维护的集合容器，效率很高O（log(n)） set的基本操作123456789101112131415161718192021222324//声明set&lt;int&gt; s;//插入元素s.insert(1);s.insert(3);s.insert(5);//查找元素set&lt;int&gt;::iterator ite;//iterator的意思是迭代器，是STL中的重要概念，类似指针.ite=s.find(1);if(ite==s.end())puts("not found");else puts("found"); //输出 found//其他的查找元素方法//删除元素s.erase(3);if(s.count(3)!=0)puts("found");else puts("not found"); //输出not found//判断集合是否为空s.empty();//清空集合的元素s.clear();//遍历所有元素for(ite=s.begin();ite!=s.end();ite++)&#123; cout&lt;&lt;*ite;&#125; 映射：map需要添加头文件 “map”，map也是用二叉搜索树维护的集合容器，效率很高O（log(n)）map就是从key到value的映射，因为重载了[ ]运算符,map像是数组的”高级版”1234567891011121314151617181920//声明（int为key，const char*为value）map&lt;int,const char*&gt;m;//插入元素m.insert(make_pair(1,"ONE"));m.insert(make_pair(10,"TEN"));m[100]="HUNDRED";//查找元素map&lt;int,const char*&gt;::iterator ite;ite=m.find(1);puts(ite-&gt;second); //(输出)ONEite=m.find(2);if(ite==m.end())puts("not found");else puts(ite-&gt;second);puts(m[10]);//删除元素m.erase(10);//遍历一遍所有元素for(ite=m.begin();ite!=m.end();ite++)&#123; printf("%d: %s\n",ite-&gt;first,ite-&gt;second);&#125; 栈需要添加头文件 “stack”, 一种“后进先出”的数据结构12345678910111213141516//声明stack&lt;int&gt; S;//入栈S.push(1);S.push(3);S.push(5);cout &lt;&lt; S.size() &lt;&lt;endl;//输出栈元素的数量cout &lt;&lt; S.top() &lt;&lt; endl;//输出栈顶元素（不删除）S.pop();//删除栈顶元素cout &lt;&lt; S.top() &lt;&lt;endl;S.pop();cout &lt;&lt; S.top() &lt;&lt;endl;S.push(5);cout &lt;&lt; S.top() &lt;&lt; endl;S.pop();cout &lt;&lt; S.top() &lt;&lt; endl; 队列需要添加头文件 “queue”, 一种“先进先出”的数据结构12345678910111213141516//声明 queue&lt;int&gt; Q; //入队 Q.push(1); Q.push(3); Q.push(5); cout &lt;&lt; Q.size() &lt;&lt;endl;//输出队列元素的数量 cout &lt;&lt; Q.front() &lt;&lt; endl;//输出对首元素（不删除） Q.pop();//删除队首元素 cout &lt;&lt; Q.front() &lt;&lt;endl; Q.pop(); cout &lt;&lt; Q.front() &lt;&lt;endl; Q.push(5); cout &lt;&lt; Q.front() &lt;&lt; endl; Q.pop(); cout &lt;&lt; Q.front() &lt;&lt; endl; 优先队列STL的优先队列也在“queue”头文件里，是一个“越小的整数优先级越低的优先队列”出队的方法由front()变为top()，且出队元素不是最先进队的元素优先队列是可以理解为实现了堆的数据结构，O（logn）12 //声明priority_queue&lt;int&gt; pq; STL也提供了“越小的整数优先级越大的优先队列”12345678910111213 //声明 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; pq.push(3); pq.push(5); pq.push(1); while(!pq.empty())&#123; printf("%d\n",pq.top()); pq.pop(); &#125; //输出135 二分查找在“algorithm”里头文件1234//lower_bound返回值一般是&gt;= 给定value的iteratorint a[MAX];int t=lower_bound(a.begin(),a.end(),x)-a//返回的是x的下标，如果没有找到就返回比x小的最大的数的下标，这里查找的范围为[a.begin(),a.end()），又是左闭右开的区间....//upper_bound返回值则是 &gt; 给定value的iterator，语法跟lower_bound类似 sort排序sort可以对任意对象排序，即使是自己定义的struct，不过要加判断方法,在“algorithm”头文件里时间复杂度是O（logn）123456789101112131415161718192021222324int a[MAX];sort(a,a+n);//对前n个元素进行升序排序sort（start，end，排序方法)#include&lt;bits/stdc++.h&gt;using namespace std;bool complare(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int a[10]=&#123;9,6,3,8,5,2,7,4,1,0&#125;; for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; sort(a,a+10,complare);//在这里就不需要对complare函数传入参数了。这是规则 for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125;//输出9 6 3 8 5 2 7 4 1 09 8 7 6 5 4 3 2 1 0 unique函数一个可以删除有序数组中的重复元素,在“algorithm”头文件里unique的作用是“去掉”容器中相邻元素的重复元素（不一定要求数组有序），它会把重复的元素添加到容器末尾（所以数组大小并没有改变），而返回值是去重之后的尾地址，12345678910111213141516171819202122232425262728293031323334iterator unique(iterator it_1,iterator it_2);iterator unique(iterator it_1,iterator it_2,bool MyFunc);//第三个参数是指自定义两个元素相等的规则，类似sort函数如果想真实删除重复元素可以在调用完unique函数之后，调用erase(it_2,a.end());进行删除#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; a.push_back(1); a.push_back(1); a.push_back(13); a.push_back(13); a.push_back(5); a.push_back(6); vector&lt;int&gt;::iterator it_1 = a.begin(); vector&lt;int&gt;::iterator it_2 = a.end(); vector&lt;int&gt;::iterator new_end; sort(it_1,it_2); for(int i = 0 ; i &lt; a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;" "; new_end = unique(it_1,it_2); //注意unique的返回值 cout&lt;&lt;endl; cout&lt;&lt;"调用unique()的 a : "; for(int i = 0 ; i &lt; a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;" "; a.erase(new_end,it_2); cout&lt;&lt;endl; cout&lt;&lt;"删除重复元素后的 a : "; for(int i = 0 ; i &lt; a.size(); i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl;&#125; reverse逆转元素12reverse(start,end)reverse_copy(start,end,b)//将逆转后的元素存入b数组中]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sudoku]]></title>
    <url>%2F2019%2F04%2F18%2FSudoku%2F</url>
    <content type="text"><![CDATA[POJ中有四道数独题，链接如下。难度大致为：2676=2918&lt;3074&lt;3076 http://poj.org/problem?id=2676http://poj.org/problem?id=2918http://poj.org/problem?id=3074http://poj.org/problem?id=3076 首先我们先来讲讲2676和2918这两道最简单的吧。想法1：因为是数独题，所以每行每列以及每个小方块的数字是不能重复的。因此我们可以用DFS尝试填数字上去。然后再加一些适当的剪枝就能AC 2676和2918题了。 以下给出2918的AC代码。 2918和2676只是输出格式不一样。改一下就能AC了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;using namespace std;int T;int tri[9][9];bool row[9][9];bool col[9][9];bool little_tri[9][9];int cnt=1;int No(int i,int j)&#123; //判断当前格子是属于哪个小方格的 return (i/3)*3+j/3;&#125;bool dfs(int i,int j)&#123; if(i==9)&#123; //出口 return true; &#125; int no=No(i,j); int temp=tri[i][j]; bool flag; if(temp)&#123; //如果该格子有数字就直接dfs下一个格子 if(j==8)&#123; flag= dfs(i+1,0); &#125; else&#123; flag= dfs(i,j+1); &#125; if(flag) return true; else return false; &#125; else&#123; for(int k=1;k&lt;=9;k++)&#123; //尝试1~9的数字 if(!row[i][k-1]&amp;&amp;!col[j][k-1]&amp;&amp;!little_tri[no][k-1])&#123; //前提是该格子允许填入k这个数字 tri[i][j]=k; row[i][k-1]=1; col[j][k-1]=1; little_tri[no][k-1]=1; if(j==8)&#123; flag= dfs(i+1,0); &#125; else&#123; flag= dfs(i,j+1); &#125; if(flag) return true; else &#123; //如果失败了，则回溯！ tri[i][j]=0; row[i][k-1]=0; col[j][k-1]=0; little_tri[no][k-1]=0; &#125; &#125; &#125; &#125; return false;&#125;void solve()&#123; string a; memset(tri,0,sizeof(tri)); memset(row,0,sizeof(row)); memset(col,0,sizeof(col)); memset(little_tri,0,sizeof(little_tri)); int tep; int no; for(int i=0;i&lt;9;i++)&#123; cin&gt;&gt;a; for(int j=0;j&lt;9;j++)&#123; tri[i][j]=a[j]-'0'; tep=tri[i][j]; no=No(i,j); if(tep)&#123; row[i][tep-1]=1; col[j][tep-1]=1; little_tri[no][tep-1]=1; &#125; &#125; &#125; dfs(0,0); printf("Scenario #%d:\n",cnt++); for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; cout&lt;&lt;tri[i][j]; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; //freopen("data.in","r",stdin); //freopen("data.out","w",stdout); scanf("%d",&amp;T); while(T--)&#123; solve(); if(T!=0)cout&lt;&lt;endl; &#125; return 0;&#125; 但这个算法是无法通过POJ3074的，因为3074题的空白格子比较多，该方法行不通，需要进一步优化。 现在讲一下POJ3074的思路想法2：考虑处理某一行时，对于某个还没有用过的数字，如果该行只有一个可行的空白格子，则将该数字填入该格子。对于列和方块也一样。反之，如果某个格子可填的数字只有一个，也只能将该数字填入该格子。 POJ3076的思路想法3：假设有一个只有两个候选数字的格子，如果选择其中一个产生了矛盾，那么就可以确定选择另一个。而对于有五个候选数字的格子，即使其中一个出现了矛盾，依然还有四个候选数字需要尝试。换句话说，选数字少的格子填数字比从左上角开始DFS更加高效.。 由于今晚比较晚了，下次有空补上 3074 和3076的代码。]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some tips for String]]></title>
    <url>%2F2019%2F04%2F17%2FSome-tips-for-String%2F</url>
    <content type="text"><![CDATA[Some tips for String笔者因为在做题时老是遇到String的坑，为此特意补一篇blog来尽量解决string 的坑…. 构造函数(Constructors)语法：12345678910111213141516string();string( size_type length, char ch );//构造length个ch string str1(10,'a');//构造十个astring( const char *str );string str2("hello wrold");//构造一个"hello wrold"的字符串string( const char *str, size_type length );//以index为索引开始的子串string str3(str2,6);//构造一个"wrold"的字符串string( string &amp;str, size_type index, size_type length );//以index为索引开始的子串，长度为lengthstring str4(str2,6,9);//构造一个"wrol"的字符串string( input_iterator start, input_iterator end );string str5(str2.begin(),str2.end());//构造一个"hello wrold"的子串 操作符(Operators)12345678910&gt;&lt;&gt;=&lt;=!=// 上面五个都是比较字符串用的+= === //判断两个字符串是否相等[index] //获取索引为index的字符,类似数组 函数at12//作用类似[]操作符at()函数返回一个引用，指向在index位置的字符. 如果index不在字符串范围内, at() 将报告"out of range"错误，并抛出out_of_range异常。 begin 和 end12begin()函数返回一个迭代器,指向字符串的第一个元素.end()函数返回一个迭代器,指向字符串的最后一个元素. c_str123c_str()函数返回一个指向正规C字符串的指针, 内容与本字符串相同.string str("hello wrold");printf("%s",str.c_str());//我理解为string 转换为char []; 比较(compare)123456789int compare( const basic_string &amp;str );//比较自己和strint compare( const char *str );//比较自己和strint compare( size_type index, size_type length, const basic_string &amp;str );//比较自己的子串和str,自己的子串以index索引开始，长度为lengthint compare( size_type index, size_type length, const basic_string &amp;str, size_type index2,size_type length2 );//比较自己的子串和str的子串，其中index2和length2引用str，index和length引用自己int compare( size_type index, size_type length, const char *str, size_type length2 );//比较自己的子串和str的子串，其中str的子串以索引0开始，长度为length2，自己的子串以index开始，长度为length 拷贝(copy)12size_type copy( char *str, size_type num, size_type index );copy()函数拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数 empty12bool empty();如果字符串为空则empty()返回真(true)，否则返回假(false). 删除(erase)123iterator erase( iterator pos );//删除pos指向的字符, 返回指向下一个字符的迭代器,iterator erase( iterator start, iterator end );//删除从start到end的所有字符, 返回一个迭代器,指向被删除的最后一个字符的下一个位置basic_string &amp;erase( size_type index = 0, size_type num = npos );//删除从index索引开始的num个字符, 返回*this. 查找(find)12345678910111213//返回str在字符串中第一次出现的位置（从index开始查找）。如果没找到则返回string::npossize_type find( const basic_string &amp;str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找）。如果没找到则返回string::npossize_type find( const char *str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找，长度为length）。如果没找到就返回string::npossize_type find( const char *str, size_type index, size_type length );//返回字符ch在字符串中第一次出现的位置（从index开始查找）。如果没找到就返回string::npossize_type find( char ch, size_type index );string::npos 直接输出：4294967295用来表示不存在的意思...例如：string str("hello wrold");cout&lt;&lt;str.find('a'); //就会打印出4294967295 下面提一下其他查找函数： find_first_of12345678//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，如果没找到就返回string::npossize_type find_first_of( const basic_string &amp;str, size_type index = 0 );//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，如果没找到就返回string::npossize_type find_first_of( const char *str, size_type index = 0 );//查找在字符串中第一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，最多搜索num个字符。如果没找到就返回string::npossize_type find_first_of( const char *str, size_type index, size_type num );//查找在字符串中第一个与ch匹配的字符，返回它的位置。搜索从index开始。size_type find_first_of( char ch, size_type index = 0 ); find_first_not_of12345678//在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_first_not_of( const basic_string &amp;str, size_type index = 0 );//在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_first_not_of( const char *str, size_type index = 0 );//在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始，最多查找num个字符。如果没找到就返回string::nopssize_type find_first_not_of( const char *str, size_type index, size_type num );//在字符串中查找第一个与ch不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_first_not_of( char ch, size_type index = 0 ); find_last_of1234567size_type find_last_of( const basic_string &amp;str, size_type index = npos );//在字符串中查找最后一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_of( const char *str, size_type index = npos );//在字符串中查找最后一个与str中的某个字符匹配的字符，返回它的位置。搜索从index开始，最多搜索num个字符。如果没找到就返回string::nopssize_type find_last_of( const char *str, size_type index, size_type num );//在字符串中查找最后一个与ch匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_of( char ch, size_type index = npos ); find_last_not_of1234567size_type find_last_not_of( const basic_string &amp;str, size_type index = npos );//在字符串中查找最后一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_not_of( const char *str, size_type index = npos);//在字符串中查找最后一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始，最多查找num个字符如果没找到就返回string::nopssize_type find_last_not_of( const char *str, size_type index, size_type num );//在字符串中查找最后一个与ch不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nopssize_type find_last_not_of( char ch, size_type index = npos ); 插入(insert)12345678910111213141516//在迭代器i表示的位置前面插入一个字符chiterator insert( iterator i, const char &amp;ch );//在字符串的位置index插入字符串strbasic_string &amp;insert( size_type index, const basic_string &amp;str );//在字符串的位置index插入字符串strbasic_string &amp;insert( size_type index, const char *str );//在字符串的位置index插入字符串str的子串(从index2开始，长num个字符)basic_string &amp;insert( size_type index1, const basic_string &amp;str, size_type index2, size_type num );//在字符串的位置index插入字符串str的num个字符basic_string &amp;insert( size_type index, const char *str, size_type num );//在字符串的位置index插入num个字符ch的拷贝basic_string &amp;insert( size_type index, size_type num, char ch );//在迭代器i表示的位置前面插入num个字符ch的拷贝,void insert( iterator i, size_type num, const char &amp;ch );//在迭代器i表示的位置前面插入一段字符，从start开始，以end结束.void insert( iterator i, iterator start, iterator end ); 长度(length)12size_type length();length()函数返回字符串的长度,这个函数跟size()函数应该差不多 substr()12345basic_string substr( size_type index, size_type num = npos );substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串string str("hello wrold");string a=str.substr();cout&lt;&lt;a;//输出hello wrold 替换(replace)1234567891011121314151617181920212223//用str中的num个字符替换本字符串中的字符,从index开始basic_string &amp;replace( size_type index, size_type num, const basic_string &amp;str );//用str中的num2个字符（从index2开始）替换本字符串中的字符，从index1开始，最多num1个字符basic_string &amp;replace( size_type index1, size_type num1, const basic_string &amp;str, size_type index2,size_type num2 );//用str中的num个字符（从index开始）替换本字符串中的字符basic_string &amp;replace( size_type index, size_type num, const char *str );//用str中的num2个字符（从index2开始）替换本字符串中的字符，从index1开始，num1个字符basic_string &amp;replace( size_type index, size_type num1, const char *str, size_type num2 );//用num2个ch字符替换本字符串中的字符，从index开始basic_string &amp;replace( size_type index, size_type num1, size_type num2, char ch );//用str中的字符替换本字符串中的字符,迭代器start和end指示范围basic_string &amp;replace( iterator start, iterator end, const basic_string &amp;str );//用str中的字符替换本字符串中的字符,迭代器start和end指示范围basic_string &amp;replace( iterator start, iterator end, const char *str );//用str中的num个字符替换本字符串中的内容,迭代器start和end指示范围basic_string &amp;replace( iterator start, iterator end, const char *str, size_type num );//用num个ch字符替换本字符串中的内容，迭代器start和end指示范围.basic_string &amp;replace( iterator start, iterator end, size_type num, char ch ); string str("hello wrold"); str.replace(6,3,"C++"); cout&lt;&lt;str;//输出hello C++ld 保留空间(reserve)12void reserve( size_type num ）reserve()函数设置本字符串的capacity 以保留num个字符空间。 reverse12345逆转元素 void reverse (BidirectionalIterator first, BidirectionalIterator last) string str("123456789"); reverse(str.begin(),str.end()); cout&lt;&lt;str;//输出987654321 clean12清空str的元素str.clear(); 关于string大概就讲这么多…以后再被坑到再接着补充。如果读者想了解更多的话，可以去查看官方文档。今天的总结就到这里吧…..]]></content>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六学家的困惑]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%85%AD%E5%AD%A6%E5%AE%B6%E7%9A%84%E5%9B%B0%E6%83%91%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/contest/625/C来源：牛客网题意：给你两个数串，只能从两个数串的头和尾取数，然后请你输出这两个数串能组成的最大的数串….一道水题，当时并没有做出来，很难受，而且当时思路很模糊，是记录数串下标来输出，结果测试用例对了，但是不能AC，不知道哪里错了，看了别人的代码后，恍然大悟，痛感自己实力不足！！！123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std; int main()&#123; //ios::sync_with_stdio(false); int T,cnt=0; string s[4]; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;s[0]&gt;&gt;s[2]; s[1] = s[0]; s[3] = s[2]; reverse(s[1].begin(),s[1].end()); reverse(s[3].begin(),s[3].end()); int n = s[0].size()+s[2].size(); string ans; while(n--)&#123; int id =0; for(int i=0;i&lt;=3;i++) if(s[i]&gt;s[id]) id = i; ans+=s[id][0]; s[id].erase(s[id].begin()); s[id^1].erase(s[id^1].end()-1); &#125; printf("Case #%d: ",++cnt); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 在字符串上面吃了好多次亏了，不行，我要准备写一篇关于字符串的blog才行，不能再在这上面吃亏了！！！]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Some tips for input]]></title>
    <url>%2F2019%2F04%2F15%2FSome-tips-for-input%2F</url>
    <content type="text"><![CDATA[Some tips for input 使用scanf和printf函数在C++程序中使用scanf 和printf需要“cstdio”头文件.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//case 1 输入输出整数#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int T; scanf("%d",&amp;T); printf("%d",T); return 0;&#125;// case 2 输入输出浮点数#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double T; scanf("%lf",&amp;T); printf("%lf",T); //默认输出小数点后六位 //printf（"%.n",T）; 输出小数点后n位 return 0;&#125;// case 3 按格式输入输出#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int year; int month; int day; printf("请输入需要转换的日期："); scanf("%d/%d/%d", &amp;year, &amp;month, &amp;day); // %d中间的/是定义好的分隔符，用户输入的时候会以-为分隔符将值分别赋值给变量 year、month、day // 注：用户输入数据的时候必须按照这种格式来写，否则会出现意想不到的错误 printf("转换后的日期格式为：%d/%d/%d \n", year, month, day);&#125;//对于scanf函数来说，空格、TAB、回车都是无关紧要的。// case 4 输入输出string类型#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a; a.resize(100);//说明string的长度 scanf("%s",&amp;a[0]); printf("%s",a.c_str());//如果写成printf("%s",a);会乱码&#125;//个人比较建议用cin来输入string类型； 使用cin 和 cout 函数 C++中可以使用流简化输入输出操作。 标准输入输出流在头文件iostream中定义，存在于名称空间std中。如果使用了using namespace std语句，则可以直接使用。 cin可以连续从键盘读取想要的数据，以空格、tab或换行作为分隔符1234567891011// case 1#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;&#125;程序输入"Hello World"，将会在下一行输出"Hello World"；其中输入的"Hello"赋值给a，"World"赋值给b，中间的空格就是分隔符。 虽然使用cin很方便，但是它比scanf慢。在某些题上，可能会因为这个cin而吃亏。 解决方法：12//在main函数里添加ios::sync_with_stdio(false); 此时的cin就会比scanf快，那么请问还有没有更快的呢？ 答案是肯定的！ 在看题解的时候，我看见有大佬是这样写的：12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;inline int read() &#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123;if(c == '-') f = -1; c = getchar();&#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') x = x * 10 + c - '0', c = getchar(); return x * f;&#125;int main()&#123; int a,b; //cin&gt;&gt;a&gt;&gt;b; a=read(); b=read(); cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;&#125; 输入速度大致：read() &lt; 加了ios::sync_with_stdio(false)的cin &lt; scanf() &lt; cin ; 使用文件输入输出先说个最简单的吧—重定向123//只要在main()函数里加入这两句话就可以了。(用于测试，如果比赛采用标准输入输出，就必须在测试完后删除掉。)freopen("data.in","r",stdin);freopen("data.out","w",stdout); 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; freopen("data.in","r",stdin); freopen("data.out","w",stdout); int a,b; scanf("%d%d",&amp;a,&amp;b); printf("%d %d",a,b); return 0;&#125;//文件data.in预先留有数据//运行完之后，data.out就会保存程序输出的数据 如果比赛要求用文件输入输出，但是禁止用重定向的方式————fopen123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; FILE*fin,*fout; fin=fopen("data.in","rb"); fout=fopen("data.out","wb"); int a,b; fscanf(fin,"%d%d",&amp;a,&amp;b); fprintf(fout,"%d %d",a,b); fclose(fin); fclose(fout); return 0;&#125;//如果不能用重定向方式读写数据，应使用fopen和fscanf/fprintf进行输入输出. 重定向的方法写起来简单，但是不能同时读写文件和标准输入输出; fopen写法比较繁琐，但可以改成读写标准输入输出，只需&quot;fin=stdin;fout=stdout;&quot;，不调用fopen和fclose; 计时函数clock()1234#include&lt;time.h&gt;int main()&#123; printf("Time used=%.2f\n",(double)clock()/CLOCKS_PER_SEC);&#125;]]></content>
      <tags>
        <tag>输入输出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Average distance]]></title>
    <url>%2F2019%2F04%2F14%2FAverage-distance%2F</url>
    <content type="text"><![CDATA[Average distance Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 1830 Accepted Submission(s): 659Special JudgeProblem DescriptionGiven a tree, calculate the average distance between two vertices in the tree. For example, the average distance between two vertices in the following tree is $(d_{01} + d_{02} + d_{03} + d_{04} + d_{12} +d_{13} +d_{14} +d_{23} +d_{24} +d_{34})/10 = (6+3+7+9+9+13+15+10+12+2)/10 = 8.6$. InputOn the first line an integer t (1 &lt;= t &lt;= 100): the number of test cases. Then for each test case:One line with an integer n (2 &lt;= n &lt;= 10 000): the number of nodes in the tree. The nodes are numbered from 0 to n - 1.n - 1 lines, each with three integers a (0 &lt;= a &lt; n), b (0 &lt;= b &lt; n) and d (1 &lt;= d &lt;= 1 000). There is an edge between the nodes with numbers a and b of length d. The resulting graph will be a tree.OutputFor each testcase:One line with the average distance between two vertices. This value should have either an absolute or a relative error of at most $10^{-6}$Sample Input150 1 60 2 30 3 73 4 2Sample Output8.6 引：如果暴力枚举两点再求距离是显然会超时的。转换一下思路，我们可以对每条边，求所有可能的路径经过此边的次数：设这条边两端的点数分别为A和B，那 么这条边被经过的次数就是AB，它对总的距离和的贡献就是(AB此边长度)。我们把所有边的贡献求总和，再除以总路径数N(N-1)/2，即为最 后所求。下面是AC的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;int T;int n;struct Node&#123; int value; int point;&#125;;double ans[10000+5];double sum[10000+5];vector&lt;Node&gt; node[10000+5];void dfs(int son,int father)&#123; sum[son]=1; for(int i=0;i&lt;node[son].size();i++)&#123; int p=node[son][i].point; int v=node[son][i].value; if(p==father)&#123;continue;&#125; dfs(p,son); sum[son]+=sum[p]; ans[son]+=ans[p]+sum[p]*(n-sum[p])*v; &#125;&#125;void solve()&#123; scanf("%d",&amp;n); int a,b,d; for(int i=0;i&lt;n;i++)&#123; node[i].clear(); &#125; memset(ans,0,sizeof(ans)); memset(sum,0,sizeof(sum)); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;d); Node temp; temp.point=b; temp.value=d; node[a].push_back(temp); temp.point=a; node[b].push_back(temp); &#125; dfs(0,-1); double number=n*(n-1)/2; //cout&lt;&lt;ans[0]/number&lt;&lt;endl; printf("%.7f\n",ans[0]/number);&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
